/*! For license information please see main.30c01397.js.LICENSE.txt */
(() => {
  "use strict";
  var e = {
      4: (e, t, n) => {
        var r = n(853),
          i = n(43),
          s = n(950);

        function o(e) {
          var t = "https://react.dev/errors/" + e;
          if (1 < arguments.length) {
            t += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n])
          }
          return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
        }

        function a(e) {
          return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
        }

        function l(e) {
          var t = e,
            n = e;
          if (e.alternate)
            for (; t.return;) t = t.return;
          else {
            e = t;
            do {
              0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
            } while (e)
          }
          return 3 === t.tag ? n : null
        }

        function c(e) {
          if (13 === e.tag) {
            var t = e.memoizedState;
            if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
          }
          return null
        }

        function u(e) {
          if (31 === e.tag) {
            var t = e.memoizedState;
            if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
          }
          return null
        }

        function h(e) {
          if (l(e) !== e) throw Error(o(188))
        }

        function d(e) {
          var t = e.tag;
          if (5 === t || 26 === t || 27 === t || 6 === t) return e;
          for (e = e.child; null !== e;) {
            if (null !== (t = d(e))) return t;
            e = e.sibling
          }
          return null
        }
        var f = Object.assign,
          p = Symbol.for("react.element"),
          g = Symbol.for("react.transitional.element"),
          m = Symbol.for("react.portal"),
          y = Symbol.for("react.fragment"),
          v = Symbol.for("react.strict_mode"),
          b = Symbol.for("react.profiler"),
          w = Symbol.for("react.consumer"),
          _ = Symbol.for("react.context"),
          x = Symbol.for("react.forward_ref"),
          k = Symbol.for("react.suspense"),
          S = Symbol.for("react.suspense_list"),
          E = Symbol.for("react.memo"),
          T = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var C = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden"), Symbol.for("react.tracing_marker");
        var O = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var P = Symbol.iterator;

        function A(e) {
          return null === e || "object" !== typeof e ? null : "function" === typeof(e = P && e[P] || e["@@iterator"]) ? e : null
        }
        var R = Symbol.for("react.client.reference");

        function M(e) {
          if (null == e) return null;
          if ("function" === typeof e) return e.$$typeof === R ? null : e.displayName || e.name || null;
          if ("string" === typeof e) return e;
          switch (e) {
            case y:
              return "Fragment";
            case b:
              return "Profiler";
            case v:
              return "StrictMode";
            case k:
              return "Suspense";
            case S:
              return "SuspenseList";
            case C:
              return "Activity"
          }
          if ("object" === typeof e) switch (e.$$typeof) {
            case m:
              return "Portal";
            case _:
              return e.displayName || "Context";
            case w:
              return (e._context.displayName || "Context") + ".Consumer";
            case x:
              var t = e.render;
              return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
            case E:
              return null !== (t = e.displayName || null) ? t : M(e.type) || "Memo";
            case T:
              t = e._payload, e = e._init;
              try {
                return M(e(t))
              } catch (n) {}
          }
          return null
        }
        var L = Array.isArray,
          j = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          N = s.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          I = {
            pending: !1,
            data: null,
            method: null,
            action: null
          },
          D = [],
          z = -1;

        function F(e) {
          return {
            current: e
          }
        }

        function B(e) {
          0 > z || (e.current = D[z], D[z] = null, z--)
        }

        function U(e, t) {
          z++, D[z] = e.current, e.current = t
        }
        var W, H, V = F(null),
          q = F(null),
          K = F(null),
          $ = F(null);

        function Y(e, t) {
          switch (U(K, t), U(q, e), U(V, null), t.nodeType) {
            case 9:
            case 11:
              e = (e = t.documentElement) && (e = e.namespaceURI) ? vh(e) : 0;
              break;
            default:
              if (e = t.tagName, t = t.namespaceURI) e = bh(t = vh(t), e);
              else switch (e) {
                case "svg":
                  e = 1;
                  break;
                case "math":
                  e = 2;
                  break;
                default:
                  e = 0
              }
          }
          B(V), U(V, e)
        }

        function J() {
          B(V), B(q), B(K)
        }

        function G(e) {
          null !== e.memoizedState && U($, e);
          var t = V.current,
            n = bh(t, e.type);
          t !== n && (U(q, e), U(V, n))
        }

        function Q(e) {
          q.current === e && (B(V), B(q)), $.current === e && (B($), hd._currentValue = I)
        }

        function X(e) {
          if (void 0 === W) try {
            throw Error()
          } catch (n) {
            var t = n.stack.trim().match(/\n( *(at )?)/);
            W = t && t[1] || "", H = -1 < n.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < n.stack.indexOf("@") ? "@unknown:0:0" : ""
          }
          return "\n" + W + e + H
        }
        var Z = !1;

        function ee(e, t) {
          if (!e || Z) return "";
          Z = !0;
          var n = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            var r = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (t) {
                    var n = function() {
                      throw Error()
                    };
                    if (Object.defineProperty(n.prototype, "props", {
                        set: function() {
                          throw Error()
                        }
                      }), "object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(n, [])
                      } catch (i) {
                        var r = i
                      }
                      Reflect.construct(e, [], n)
                    } else {
                      try {
                        n.call()
                      } catch (s) {
                        r = s
                      }
                      e.call(n.prototype)
                    }
                  } else {
                    try {
                      throw Error()
                    } catch (o) {
                      r = o
                    }(n = e()) && "function" === typeof n.catch && n.catch(function() {})
                  }
                } catch (ai) {
                  if (ai && r && "string" === typeof ai.stack) return [ai.stack, r.stack]
                }
                return [null, null]
              }
            };
            r.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var i = Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot, "name");
            i && i.configurable && Object.defineProperty(r.DetermineComponentFrameRoot, "name", {
              value: "DetermineComponentFrameRoot"
            });
            var s = r.DetermineComponentFrameRoot(),
              o = s[0],
              a = s[1];
            if (o && a) {
              var l = o.split("\n"),
                c = a.split("\n");
              for (i = r = 0; r < l.length && !l[r].includes("DetermineComponentFrameRoot");) r++;
              for (; i < c.length && !c[i].includes("DetermineComponentFrameRoot");) i++;
              if (r === l.length || i === c.length)
                for (r = l.length - 1, i = c.length - 1; 1 <= r && 0 <= i && l[r] !== c[i];) i--;
              for (; 1 <= r && 0 <= i; r--, i--)
                if (l[r] !== c[i]) {
                  if (1 !== r || 1 !== i)
                    do {
                      if (r--, 0 > --i || l[r] !== c[i]) {
                        var u = "\n" + l[r].replace(" at new ", " at ");
                        return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)), u
                      }
                    } while (1 <= r && 0 <= i);
                  break
                }
            }
          } finally {
            Z = !1, Error.prepareStackTrace = n
          }
          return (n = e ? e.displayName || e.name : "") ? X(n) : ""
        }

        function te(e, t) {
          switch (e.tag) {
            case 26:
            case 27:
            case 5:
              return X(e.type);
            case 16:
              return X("Lazy");
            case 13:
              return e.child !== t && null !== t ? X("Suspense Fallback") : X("Suspense");
            case 19:
              return X("SuspenseList");
            case 0:
            case 15:
              return ee(e.type, !1);
            case 11:
              return ee(e.type.render, !1);
            case 1:
              return ee(e.type, !0);
            case 31:
              return X("Activity");
            default:
              return ""
          }
        }

        function ne(e) {
          try {
            var t = "",
              n = null;
            do {
              t += te(e, n), n = e, e = e.return
            } while (e);
            return t
          } catch (r) {
            return "\nError generating stack: " + r.message + "\n" + r.stack
          }
        }
        var re = Object.prototype.hasOwnProperty,
          ie = r.unstable_scheduleCallback,
          se = r.unstable_cancelCallback,
          oe = r.unstable_shouldYield,
          ae = r.unstable_requestPaint,
          le = r.unstable_now,
          ce = r.unstable_getCurrentPriorityLevel,
          ue = r.unstable_ImmediatePriority,
          he = r.unstable_UserBlockingPriority,
          de = r.unstable_NormalPriority,
          fe = r.unstable_LowPriority,
          pe = r.unstable_IdlePriority,
          ge = r.log,
          me = r.unstable_setDisableYieldValue,
          ye = null,
          ve = null;

        function be(e) {
          if ("function" === typeof ge && me(e), ve && "function" === typeof ve.setStrictMode) try {
            ve.setStrictMode(ye, e)
          } catch (t) {}
        }
        var we = Math.clz32 ? Math.clz32 : function(e) {
            return 0 === (e >>>= 0) ? 32 : 31 - (_e(e) / xe | 0) | 0
          },
          _e = Math.log,
          xe = Math.LN2;
        var ke = 256,
          Se = 262144,
          Ee = 4194304;

        function Te(e) {
          var t = 42 & e;
          if (0 !== t) return t;
          switch (e & -e) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
              return 261888 & e;
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return 3932160 & e;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return 62914560 & e;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return e
          }
        }

        function Ce(e, t, n) {
          var r = e.pendingLanes;
          if (0 === r) return 0;
          var i = 0,
            s = e.suspendedLanes,
            o = e.pingedLanes;
          e = e.warmLanes;
          var a = 134217727 & r;
          return 0 !== a ? 0 !== (r = a & ~s) ? i = Te(r) : 0 !== (o &= a) ? i = Te(o) : n || 0 !== (n = a & ~e) && (i = Te(n)) : 0 !== (a = r & ~s) ? i = Te(a) : 0 !== o ? i = Te(o) : n || 0 !== (n = r & ~e) && (i = Te(n)), 0 === i ? 0 : 0 !== t && t !== i && 0 === (t & s) && ((s = i & -i) >= (n = t & -t) || 32 === s && 0 !== (4194048 & n)) ? t : i
        }

        function Oe(e, t) {
          return 0 === (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t)
        }

        function Pe(e, t) {
          switch (e) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return t + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return t + 5e3;
            default:
              return -1
          }
        }

        function Ae() {
          var e = Ee;
          return 0 === (62914560 & (Ee <<= 1)) && (Ee = 4194304), e
        }

        function Re(e) {
          for (var t = [], n = 0; 31 > n; n++) t.push(e);
          return t
        }

        function Me(e, t) {
          e.pendingLanes |= t, 268435456 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0)
        }

        function Le(e, t, n) {
          e.pendingLanes |= t, e.suspendedLanes &= ~t;
          var r = 31 - we(t);
          e.entangledLanes |= t, e.entanglements[r] = 1073741824 | e.entanglements[r] | 261930 & n
        }

        function je(e, t) {
          var n = e.entangledLanes |= t;
          for (e = e.entanglements; n;) {
            var r = 31 - we(n),
              i = 1 << r;
            i & t | e[r] & t && (e[r] |= t), n &= ~i
          }
        }

        function Ne(e, t) {
          var n = t & -t;
          return 0 !== ((n = 0 !== (42 & n) ? 1 : Ie(n)) & (e.suspendedLanes | t)) ? 0 : n
        }

        function Ie(e) {
          switch (e) {
            case 2:
              e = 1;
              break;
            case 8:
              e = 4;
              break;
            case 32:
              e = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              e = 128;
              break;
            case 268435456:
              e = 134217728;
              break;
            default:
              e = 0
          }
          return e
        }

        function De(e) {
          return 2 < (e &= -e) ? 8 < e ? 0 !== (134217727 & e) ? 32 : 268435456 : 8 : 2
        }

        function ze() {
          var e = N.p;
          return 0 !== e ? e : void 0 === (e = window.event) ? 32 : Cd(e.type)
        }

        function Fe(e, t) {
          var n = N.p;
          try {
            return N.p = e, t()
          } finally {
            N.p = n
          }
        }
        var Be = Math.random().toString(36).slice(2),
          Ue = "__reactFiber$" + Be,
          We = "__reactProps$" + Be,
          He = "__reactContainer$" + Be,
          Ve = "__reactEvents$" + Be,
          qe = "__reactListeners$" + Be,
          Ke = "__reactHandles$" + Be,
          $e = "__reactResources$" + Be,
          Ye = "__reactMarker$" + Be;

        function Je(e) {
          delete e[Ue], delete e[We], delete e[Ve], delete e[qe], delete e[Ke]
        }

        function Ge(e) {
          var t = e[Ue];
          if (t) return t;
          for (var n = e.parentNode; n;) {
            if (t = n[He] || n[Ue]) {
              if (n = t.alternate, null !== t.child || null !== n && null !== n.child)
                for (e = Dh(e); null !== e;) {
                  if (n = e[Ue]) return n;
                  e = Dh(e)
                }
              return t
            }
            n = (e = n).parentNode
          }
          return null
        }

        function Qe(e) {
          if (e = e[Ue] || e[He]) {
            var t = e.tag;
            if (5 === t || 6 === t || 13 === t || 31 === t || 26 === t || 27 === t || 3 === t) return e
          }
          return null
        }

        function Xe(e) {
          var t = e.tag;
          if (5 === t || 26 === t || 27 === t || 6 === t) return e.stateNode;
          throw Error(o(33))
        }

        function Ze(e) {
          var t = e[$e];
          return t || (t = e[$e] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
          }), t
        }

        function et(e) {
          e[Ye] = !0
        }
        var tt = new Set,
          nt = {};

        function rt(e, t) {
          it(e, t), it(e + "Capture", t)
        }

        function it(e, t) {
          for (nt[e] = t, e = 0; e < t.length; e++) tt.add(t[e])
        }
        var st = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
          ot = {},
          at = {};

        function lt(e, t, n) {
          if (i = t, re.call(at, i) || !re.call(ot, i) && (st.test(i) ? at[i] = !0 : (ot[i] = !0, 0)))
            if (null === n) e.removeAttribute(t);
            else {
              switch (typeof n) {
                case "undefined":
                case "function":
                case "symbol":
                  return void e.removeAttribute(t);
                case "boolean":
                  var r = t.toLowerCase().slice(0, 5);
                  if ("data-" !== r && "aria-" !== r) return void e.removeAttribute(t)
              }
              e.setAttribute(t, "" + n)
            } var i
        }

        function ct(e, t, n) {
          if (null === n) e.removeAttribute(t);
          else {
            switch (typeof n) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return void e.removeAttribute(t)
            }
            e.setAttribute(t, "" + n)
          }
        }

        function ut(e, t, n, r) {
          if (null === r) e.removeAttribute(n);
          else {
            switch (typeof r) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return void e.removeAttribute(n)
            }
            e.setAttributeNS(t, n, "" + r)
          }
        }

        function ht(e) {
          switch (typeof e) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
            case "object":
              return e;
            default:
              return ""
          }
        }

        function dt(e) {
          var t = e.type;
          return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
        }

        function ft(e) {
          if (!e._valueTracker) {
            var t = dt(e) ? "checked" : "value";
            e._valueTracker = function(e, t, n) {
              var r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
              if (!e.hasOwnProperty(t) && "undefined" !== typeof r && "function" === typeof r.get && "function" === typeof r.set) {
                var i = r.get,
                  s = r.set;
                return Object.defineProperty(e, t, {
                  configurable: !0,
                  get: function() {
                    return i.call(this)
                  },
                  set: function(e) {
                    n = "" + e, s.call(this, e)
                  }
                }), Object.defineProperty(e, t, {
                  enumerable: r.enumerable
                }), {
                  getValue: function() {
                    return n
                  },
                  setValue: function(e) {
                    n = "" + e
                  },
                  stopTracking: function() {
                    e._valueTracker = null, delete e[t]
                  }
                }
              }
            }(e, t, "" + e[t])
          }
        }

        function pt(e) {
          if (!e) return !1;
          var t = e._valueTracker;
          if (!t) return !0;
          var n = t.getValue(),
            r = "";
          return e && (r = dt(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
        }

        function gt(e) {
          if ("undefined" === typeof(e = e || ("undefined" !== typeof document ? document : void 0))) return null;
          try {
            return e.activeElement || e.body
          } catch (t) {
            return e.body
          }
        }
        var mt = /[\n"\\]/g;

        function yt(e) {
          return e.replace(mt, function(e) {
            return "\\" + e.charCodeAt(0).toString(16) + " "
          })
        }

        function vt(e, t, n, r, i, s, o, a) {
          e.name = "", null != o && "function" !== typeof o && "symbol" !== typeof o && "boolean" !== typeof o ? e.type = o : e.removeAttribute("type"), null != t ? "number" === o ? (0 === t && "" === e.value || e.value != t) && (e.value = "" + ht(t)) : e.value !== "" + ht(t) && (e.value = "" + ht(t)) : "submit" !== o && "reset" !== o || e.removeAttribute("value"), null != t ? wt(e, o, ht(t)) : null != n ? wt(e, o, ht(n)) : null != r && e.removeAttribute("value"), null == i && null != s && (e.defaultChecked = !!s), null != i && (e.checked = i && "function" !== typeof i && "symbol" !== typeof i), null != a && "function" !== typeof a && "symbol" !== typeof a && "boolean" !== typeof a ? e.name = "" + ht(a) : e.removeAttribute("name")
        }

        function bt(e, t, n, r, i, s, o, a) {
          if (null != s && "function" !== typeof s && "symbol" !== typeof s && "boolean" !== typeof s && (e.type = s), null != t || null != n) {
            if (!("submit" !== s && "reset" !== s || void 0 !== t && null !== t)) return void ft(e);
            n = null != n ? "" + ht(n) : "", t = null != t ? "" + ht(t) : n, a || t === e.value || (e.value = t), e.defaultValue = t
          }
          r = "function" !== typeof(r = null != r ? r : i) && "symbol" !== typeof r && !!r, e.checked = a ? e.checked : !!r, e.defaultChecked = !!r, null != o && "function" !== typeof o && "symbol" !== typeof o && "boolean" !== typeof o && (e.name = o), ft(e)
        }

        function wt(e, t, n) {
          "number" === t && gt(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n)
        }

        function _t(e, t, n, r) {
          if (e = e.options, t) {
            t = {};
            for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
            for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
          } else {
            for (n = "" + ht(n), t = null, i = 0; i < e.length; i++) {
              if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
              null !== t || e[i].disabled || (t = e[i])
            }
            null !== t && (t.selected = !0)
          }
        }

        function xt(e, t, n) {
          null == t || ((t = "" + ht(t)) !== e.value && (e.value = t), null != n) ? e.defaultValue = null != n ? "" + ht(n) : "" : e.defaultValue !== t && (e.defaultValue = t)
        }

        function kt(e, t, n, r) {
          if (null == t) {
            if (null != r) {
              if (null != n) throw Error(o(92));
              if (L(r)) {
                if (1 < r.length) throw Error(o(93));
                r = r[0]
              }
              n = r
            }
            null == n && (n = ""), t = n
          }
          n = ht(t), e.defaultValue = n, (r = e.textContent) === n && "" !== r && null !== r && (e.value = r), ft(e)
        }

        function St(e, t) {
          if (t) {
            var n = e.firstChild;
            if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
          }
          e.textContent = t
        }
        var Et = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));

        function Tt(e, t, n) {
          var r = 0 === t.indexOf("--");
          null == n || "boolean" === typeof n || "" === n ? r ? e.setProperty(t, "") : "float" === t ? e.cssFloat = "" : e[t] = "" : r ? e.setProperty(t, n) : "number" !== typeof n || 0 === n || Et.has(t) ? "float" === t ? e.cssFloat = n : e[t] = ("" + n).trim() : e[t] = n + "px"
        }

        function Ct(e, t, n) {
          if (null != t && "object" !== typeof t) throw Error(o(62));
          if (e = e.style, null != n) {
            for (var r in n) !n.hasOwnProperty(r) || null != t && t.hasOwnProperty(r) || (0 === r.indexOf("--") ? e.setProperty(r, "") : "float" === r ? e.cssFloat = "" : e[r] = "");
            for (var i in t) r = t[i], t.hasOwnProperty(i) && n[i] !== r && Tt(e, i, r)
          } else
            for (var s in t) t.hasOwnProperty(s) && Tt(e, s, t[s])
        }

        function Ot(e) {
          if (-1 === e.indexOf("-")) return !1;
          switch (e) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return !1;
            default:
              return !0
          }
        }
        var Pt = new Map([
            ["acceptCharset", "accept-charset"],
            ["htmlFor", "for"],
            ["httpEquiv", "http-equiv"],
            ["crossOrigin", "crossorigin"],
            ["accentHeight", "accent-height"],
            ["alignmentBaseline", "alignment-baseline"],
            ["arabicForm", "arabic-form"],
            ["baselineShift", "baseline-shift"],
            ["capHeight", "cap-height"],
            ["clipPath", "clip-path"],
            ["clipRule", "clip-rule"],
            ["colorInterpolation", "color-interpolation"],
            ["colorInterpolationFilters", "color-interpolation-filters"],
            ["colorProfile", "color-profile"],
            ["colorRendering", "color-rendering"],
            ["dominantBaseline", "dominant-baseline"],
            ["enableBackground", "enable-background"],
            ["fillOpacity", "fill-opacity"],
            ["fillRule", "fill-rule"],
            ["floodColor", "flood-color"],
            ["floodOpacity", "flood-opacity"],
            ["fontFamily", "font-family"],
            ["fontSize", "font-size"],
            ["fontSizeAdjust", "font-size-adjust"],
            ["fontStretch", "font-stretch"],
            ["fontStyle", "font-style"],
            ["fontVariant", "font-variant"],
            ["fontWeight", "font-weight"],
            ["glyphName", "glyph-name"],
            ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
            ["glyphOrientationVertical", "glyph-orientation-vertical"],
            ["horizAdvX", "horiz-adv-x"],
            ["horizOriginX", "horiz-origin-x"],
            ["imageRendering", "image-rendering"],
            ["letterSpacing", "letter-spacing"],
            ["lightingColor", "lighting-color"],
            ["markerEnd", "marker-end"],
            ["markerMid", "marker-mid"],
            ["markerStart", "marker-start"],
            ["overlinePosition", "overline-position"],
            ["overlineThickness", "overline-thickness"],
            ["paintOrder", "paint-order"],
            ["panose-1", "panose-1"],
            ["pointerEvents", "pointer-events"],
            ["renderingIntent", "rendering-intent"],
            ["shapeRendering", "shape-rendering"],
            ["stopColor", "stop-color"],
            ["stopOpacity", "stop-opacity"],
            ["strikethroughPosition", "strikethrough-position"],
            ["strikethroughThickness", "strikethrough-thickness"],
            ["strokeDasharray", "stroke-dasharray"],
            ["strokeDashoffset", "stroke-dashoffset"],
            ["strokeLinecap", "stroke-linecap"],
            ["strokeLinejoin", "stroke-linejoin"],
            ["strokeMiterlimit", "stroke-miterlimit"],
            ["strokeOpacity", "stroke-opacity"],
            ["strokeWidth", "stroke-width"],
            ["textAnchor", "text-anchor"],
            ["textDecoration", "text-decoration"],
            ["textRendering", "text-rendering"],
            ["transformOrigin", "transform-origin"],
            ["underlinePosition", "underline-position"],
            ["underlineThickness", "underline-thickness"],
            ["unicodeBidi", "unicode-bidi"],
            ["unicodeRange", "unicode-range"],
            ["unitsPerEm", "units-per-em"],
            ["vAlphabetic", "v-alphabetic"],
            ["vHanging", "v-hanging"],
            ["vIdeographic", "v-ideographic"],
            ["vMathematical", "v-mathematical"],
            ["vectorEffect", "vector-effect"],
            ["vertAdvY", "vert-adv-y"],
            ["vertOriginX", "vert-origin-x"],
            ["vertOriginY", "vert-origin-y"],
            ["wordSpacing", "word-spacing"],
            ["writingMode", "writing-mode"],
            ["xmlnsXlink", "xmlns:xlink"],
            ["xHeight", "x-height"]
          ]),
          At = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;

        function Rt(e) {
          return At.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e
        }

        function Mt() {}
        var Lt = null;

        function jt(e) {
          return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
        }
        var Nt = null,
          It = null;

        function Dt(e) {
          var t = Qe(e);
          if (t && (e = t.stateNode)) {
            var n = e[We] || null;
            e: switch (e = t.stateNode, t.type) {
              case "input":
                if (vt(e, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), t = n.name, "radio" === n.type && null != t) {
                  for (n = e; n.parentNode;) n = n.parentNode;
                  for (n = n.querySelectorAll('input[name="' + yt("" + t) + '"][type="radio"]'), t = 0; t < n.length; t++) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                      var i = r[We] || null;
                      if (!i) throw Error(o(90));
                      vt(r, i.value, i.defaultValue, i.defaultValue, i.checked, i.defaultChecked, i.type, i.name)
                    }
                  }
                  for (t = 0; t < n.length; t++)(r = n[t]).form === e.form && pt(r)
                }
                break e;
              case "textarea":
                xt(e, n.value, n.defaultValue);
                break e;
              case "select":
                null != (t = n.value) && _t(e, !!n.multiple, t, !1)
            }
          }
        }
        var zt = !1;

        function Ft(e, t, n) {
          if (zt) return e(t, n);
          zt = !0;
          try {
            return e(t)
          } finally {
            if (zt = !1, (null !== Nt || null !== It) && (eu(), Nt && (t = Nt, e = It, It = Nt = null, Dt(t), e)))
              for (t = 0; t < e.length; t++) Dt(e[t])
          }
        }

        function Bt(e, t) {
          var n = e.stateNode;
          if (null === n) return null;
          var r = n[We] || null;
          if (null === r) return null;
          n = r[t];
          e: switch (t) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
              break e;
            default:
              e = !1
          }
          if (e) return null;
          if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
          return n
        }
        var Ut = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
          Wt = !1;
        if (Ut) try {
          var Ht = {};
          Object.defineProperty(Ht, "passive", {
            get: function() {
              Wt = !0
            }
          }), window.addEventListener("test", Ht, Ht), window.removeEventListener("test", Ht, Ht)
        } catch (Xd) {
          Wt = !1
        }
        var Vt = null,
          qt = null,
          Kt = null;

        function $t() {
          if (Kt) return Kt;
          var e, t, n = qt,
            r = n.length,
            i = "value" in Vt ? Vt.value : Vt.textContent,
            s = i.length;
          for (e = 0; e < r && n[e] === i[e]; e++);
          var o = r - e;
          for (t = 1; t <= o && n[r - t] === i[s - t]; t++);
          return Kt = i.slice(e, 1 < t ? 1 - t : void 0)
        }

        function Yt(e) {
          var t = e.keyCode;
          return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
        }

        function Jt() {
          return !0
        }

        function Gt() {
          return !1
        }

        function Qt(e) {
          function t(t, n, r, i, s) {
            for (var o in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = s, this.currentTarget = null, e) e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]);
            return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? Jt : Gt, this.isPropagationStopped = Gt, this
          }
          return f(t.prototype, {
            preventDefault: function() {
              this.defaultPrevented = !0;
              var e = this.nativeEvent;
              e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = Jt)
            },
            stopPropagation: function() {
              var e = this.nativeEvent;
              e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = Jt)
            },
            persist: function() {},
            isPersistent: Jt
          }), t
        }
        var Xt, Zt, en, tn = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(e) {
              return e.timeStamp || Date.now()
            },
            defaultPrevented: 0,
            isTrusted: 0
          },
          nn = Qt(tn),
          rn = f({}, tn, {
            view: 0,
            detail: 0
          }),
          sn = Qt(rn),
          on = f({}, rn, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: yn,
            button: 0,
            buttons: 0,
            relatedTarget: function(e) {
              return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
            },
            movementX: function(e) {
              return "movementX" in e ? e.movementX : (e !== en && (en && "mousemove" === e.type ? (Xt = e.screenX - en.screenX, Zt = e.screenY - en.screenY) : Zt = Xt = 0, en = e), Xt)
            },
            movementY: function(e) {
              return "movementY" in e ? e.movementY : Zt
            }
          }),
          an = Qt(on),
          ln = Qt(f({}, on, {
            dataTransfer: 0
          })),
          cn = Qt(f({}, rn, {
            relatedTarget: 0
          })),
          un = Qt(f({}, tn, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          })),
          hn = Qt(f({}, tn, {
            clipboardData: function(e) {
              return "clipboardData" in e ? e.clipboardData : window.clipboardData
            }
          })),
          dn = Qt(f({}, tn, {
            data: 0
          })),
          fn = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          },
          pn = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
          },
          gn = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };

        function mn(e) {
          var t = this.nativeEvent;
          return t.getModifierState ? t.getModifierState(e) : !!(e = gn[e]) && !!t[e]
        }

        function yn() {
          return mn
        }
        var vn = Qt(f({}, rn, {
            key: function(e) {
              if (e.key) {
                var t = fn[e.key] || e.key;
                if ("Unidentified" !== t) return t
              }
              return "keypress" === e.type ? 13 === (e = Yt(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? pn[e.keyCode] || "Unidentified" : ""
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: yn,
            charCode: function(e) {
              return "keypress" === e.type ? Yt(e) : 0
            },
            keyCode: function(e) {
              return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
            },
            which: function(e) {
              return "keypress" === e.type ? Yt(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
            }
          })),
          bn = Qt(f({}, on, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          })),
          wn = Qt(f({}, rn, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: yn
          })),
          _n = Qt(f({}, tn, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          })),
          xn = Qt(f({}, on, {
            deltaX: function(e) {
              return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
            },
            deltaY: function(e) {
              return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
            },
            deltaZ: 0,
            deltaMode: 0
          })),
          kn = Qt(f({}, tn, {
            newState: 0,
            oldState: 0
          })),
          Sn = [9, 13, 27, 32],
          En = Ut && "CompositionEvent" in window,
          Tn = null;
        Ut && "documentMode" in document && (Tn = document.documentMode);
        var Cn = Ut && "TextEvent" in window && !Tn,
          On = Ut && (!En || Tn && 8 < Tn && 11 >= Tn),
          Pn = String.fromCharCode(32),
          An = !1;

        function Rn(e, t) {
          switch (e) {
            case "keyup":
              return -1 !== Sn.indexOf(t.keyCode);
            case "keydown":
              return 229 !== t.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return !0;
            default:
              return !1
          }
        }

        function Mn(e) {
          return "object" === typeof(e = e.detail) && "data" in e ? e.data : null
        }
        var Ln = !1;
        var jn = {
          color: !0,
          date: !0,
          datetime: !0,
          "datetime-local": !0,
          email: !0,
          month: !0,
          number: !0,
          password: !0,
          range: !0,
          search: !0,
          tel: !0,
          text: !0,
          time: !0,
          url: !0,
          week: !0
        };

        function Nn(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return "input" === t ? !!jn[e.type] : "textarea" === t
        }

        function In(e, t, n, r) {
          Nt ? It ? It.push(r) : It = [r] : Nt = r, 0 < (t = ih(t, "onChange")).length && (n = new nn("onChange", "change", null, n, r), e.push({
            event: n,
            listeners: t
          }))
        }
        var Dn = null,
          zn = null;

        function Fn(e) {
          Gu(e, 0)
        }

        function Bn(e) {
          if (pt(Xe(e))) return e
        }

        function Un(e, t) {
          if ("change" === e) return t
        }
        var Wn = !1;
        if (Ut) {
          var Hn;
          if (Ut) {
            var Vn = "oninput" in document;
            if (!Vn) {
              var qn = document.createElement("div");
              qn.setAttribute("oninput", "return;"), Vn = "function" === typeof qn.oninput
            }
            Hn = Vn
          } else Hn = !1;
          Wn = Hn && (!document.documentMode || 9 < document.documentMode)
        }

        function Kn() {
          Dn && (Dn.detachEvent("onpropertychange", $n), zn = Dn = null)
        }

        function $n(e) {
          if ("value" === e.propertyName && Bn(zn)) {
            var t = [];
            In(t, zn, e, jt(e)), Ft(Fn, t)
          }
        }

        function Yn(e, t, n) {
          "focusin" === e ? (Kn(), zn = n, (Dn = t).attachEvent("onpropertychange", $n)) : "focusout" === e && Kn()
        }

        function Jn(e) {
          if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Bn(zn)
        }

        function Gn(e, t) {
          if ("click" === e) return Bn(t)
        }

        function Qn(e, t) {
          if ("input" === e || "change" === e) return Bn(t)
        }
        var Xn = "function" === typeof Object.is ? Object.is : function(e, t) {
          return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
        };

        function Zn(e, t) {
          if (Xn(e, t)) return !0;
          if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
          var n = Object.keys(e),
            r = Object.keys(t);
          if (n.length !== r.length) return !1;
          for (r = 0; r < n.length; r++) {
            var i = n[r];
            if (!re.call(t, i) || !Xn(e[i], t[i])) return !1
          }
          return !0
        }

        function er(e) {
          for (; e && e.firstChild;) e = e.firstChild;
          return e
        }

        function tr(e, t) {
          var n, r = er(e);
          for (e = 0; r;) {
            if (3 === r.nodeType) {
              if (n = e + r.textContent.length, e <= t && n >= t) return {
                node: r,
                offset: t - e
              };
              e = n
            }
            e: {
              for (; r;) {
                if (r.nextSibling) {
                  r = r.nextSibling;
                  break e
                }
                r = r.parentNode
              }
              r = void 0
            }
            r = er(r)
          }
        }

        function nr(e, t) {
          return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? nr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
        }

        function rr(e) {
          for (var t = gt((e = null != e && null != e.ownerDocument && null != e.ownerDocument.defaultView ? e.ownerDocument.defaultView : window).document); t instanceof e.HTMLIFrameElement;) {
            try {
              var n = "string" === typeof t.contentWindow.location.href
            } catch (r) {
              n = !1
            }
            if (!n) break;
            t = gt((e = t.contentWindow).document)
          }
          return t
        }

        function ir(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
        }
        var sr = Ut && "documentMode" in document && 11 >= document.documentMode,
          or = null,
          ar = null,
          lr = null,
          cr = !1;

        function ur(e, t, n) {
          var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
          cr || null == or || or !== gt(r) || ("selectionStart" in (r = or) && ir(r) ? r = {
            start: r.selectionStart,
            end: r.selectionEnd
          } : r = {
            anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset
          }, lr && Zn(lr, r) || (lr = r, 0 < (r = ih(ar, "onSelect")).length && (t = new nn("onSelect", "select", null, t, n), e.push({
            event: t,
            listeners: r
          }), t.target = or)))
        }

        function hr(e, t) {
          var n = {};
          return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
        }
        var dr = {
            animationend: hr("Animation", "AnimationEnd"),
            animationiteration: hr("Animation", "AnimationIteration"),
            animationstart: hr("Animation", "AnimationStart"),
            transitionrun: hr("Transition", "TransitionRun"),
            transitionstart: hr("Transition", "TransitionStart"),
            transitioncancel: hr("Transition", "TransitionCancel"),
            transitionend: hr("Transition", "TransitionEnd")
          },
          fr = {},
          pr = {};

        function gr(e) {
          if (fr[e]) return fr[e];
          if (!dr[e]) return e;
          var t, n = dr[e];
          for (t in n)
            if (n.hasOwnProperty(t) && t in pr) return fr[e] = n[t];
          return e
        }
        Ut && (pr = document.createElement("div").style, "AnimationEvent" in window || (delete dr.animationend.animation, delete dr.animationiteration.animation, delete dr.animationstart.animation), "TransitionEvent" in window || delete dr.transitionend.transition);
        var mr = gr("animationend"),
          yr = gr("animationiteration"),
          vr = gr("animationstart"),
          br = gr("transitionrun"),
          wr = gr("transitionstart"),
          _r = gr("transitioncancel"),
          xr = gr("transitionend"),
          kr = new Map,
          Sr = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

        function Er(e, t) {
          kr.set(e, t), rt(t, [e])
        }
        Sr.push("scrollEnd");
        var Tr = "function" === typeof reportError ? reportError : function(e) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
              var t = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof e && null !== e && "string" === typeof e.message ? String(e.message) : String(e),
                error: e
              });
              if (!window.dispatchEvent(t)) return
            } else if ("object" === typeof process && "function" === typeof process.emit) return void process.emit("uncaughtException", e);
            console.error(e)
          },
          Cr = [],
          Or = 0,
          Pr = 0;

        function Ar() {
          for (var e = Or, t = Pr = Or = 0; t < e;) {
            var n = Cr[t];
            Cr[t++] = null;
            var r = Cr[t];
            Cr[t++] = null;
            var i = Cr[t];
            Cr[t++] = null;
            var s = Cr[t];
            if (Cr[t++] = null, null !== r && null !== i) {
              var o = r.pending;
              null === o ? i.next = i : (i.next = o.next, o.next = i), r.pending = i
            }
            0 !== s && jr(n, i, s)
          }
        }

        function Rr(e, t, n, r) {
          Cr[Or++] = e, Cr[Or++] = t, Cr[Or++] = n, Cr[Or++] = r, Pr |= r, e.lanes |= r, null !== (e = e.alternate) && (e.lanes |= r)
        }

        function Mr(e, t, n, r) {
          return Rr(e, t, n, r), Nr(e)
        }

        function Lr(e, t) {
          return Rr(e, null, null, t), Nr(e)
        }

        function jr(e, t, n) {
          e.lanes |= n;
          var r = e.alternate;
          null !== r && (r.lanes |= n);
          for (var i = !1, s = e.return; null !== s;) s.childLanes |= n, null !== (r = s.alternate) && (r.childLanes |= n), 22 === s.tag && (null === (e = s.stateNode) || 1 & e._visibility || (i = !0)), e = s, s = s.return;
          return 3 === e.tag ? (s = e.stateNode, i && null !== t && (i = 31 - we(n), null === (r = (e = s.hiddenUpdates)[i]) ? e[i] = [t] : r.push(t), t.lane = 536870912 | n), s) : null
        }

        function Nr(e) {
          if (50 < qc) throw qc = 0, Kc = null, Error(o(185));
          for (var t = e.return; null !== t;) t = (e = t).return;
          return 3 === e.tag ? e.stateNode : null
        }
        var Ir = {};

        function Dr(e, t, n, r) {
          this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
        }

        function zr(e, t, n, r) {
          return new Dr(e, t, n, r)
        }

        function Fr(e) {
          return !(!(e = e.prototype) || !e.isReactComponent)
        }

        function Br(e, t) {
          var n = e.alternate;
          return null === n ? ((n = zr(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 65011712 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
            lanes: t.lanes,
            firstContext: t.firstContext
          }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n
        }

        function Ur(e, t) {
          e.flags &= 65011714;
          var n = e.alternate;
          return null === n ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = null === t ? null : {
            lanes: t.lanes,
            firstContext: t.firstContext
          }), e
        }

        function Wr(e, t, n, r, i, s) {
          var a = 0;
          if (r = e, "function" === typeof e) Fr(e) && (a = 1);
          else if ("string" === typeof e) a = function(e, t, n) {
            if (1 === n || null != t.itemProp) return !1;
            switch (e) {
              case "meta":
              case "title":
                return !0;
              case "style":
                if ("string" !== typeof t.precedence || "string" !== typeof t.href || "" === t.href) break;
                return !0;
              case "link":
                if ("string" !== typeof t.rel || "string" !== typeof t.href || "" === t.href || t.onLoad || t.onError) break;
                return "stylesheet" !== t.rel || (e = t.disabled, "string" === typeof t.precedence && null == e);
              case "script":
                if (t.async && "function" !== typeof t.async && "symbol" !== typeof t.async && !t.onLoad && !t.onError && t.src && "string" === typeof t.src) return !0
            }
            return !1
          }(e, n, V.current) ? 26 : "html" === e || "head" === e || "body" === e ? 27 : 5;
          else e: switch (e) {
            case C:
              return (e = zr(31, n, t, i)).elementType = C, e.lanes = s, e;
            case y:
              return Hr(n.children, i, s, t);
            case v:
              a = 8, i |= 24;
              break;
            case b:
              return (e = zr(12, n, t, 2 | i)).elementType = b, e.lanes = s, e;
            case k:
              return (e = zr(13, n, t, i)).elementType = k, e.lanes = s, e;
            case S:
              return (e = zr(19, n, t, i)).elementType = S, e.lanes = s, e;
            default:
              if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                case _:
                  a = 10;
                  break e;
                case w:
                  a = 9;
                  break e;
                case x:
                  a = 11;
                  break e;
                case E:
                  a = 14;
                  break e;
                case T:
                  a = 16, r = null;
                  break e
              }
              a = 29, n = Error(o(130, null === e ? "null" : typeof e, "")), r = null
          }
          return (t = zr(a, n, t, i)).elementType = e, t.type = r, t.lanes = s, t
        }

        function Hr(e, t, n, r) {
          return (e = zr(7, e, r, t)).lanes = n, e
        }

        function Vr(e, t, n) {
          return (e = zr(6, e, null, t)).lanes = n, e
        }

        function qr(e) {
          var t = zr(18, null, null, 0);
          return t.stateNode = e, t
        }

        function Kr(e, t, n) {
          return (t = zr(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
            containerInfo: e.containerInfo,
            pendingChildren: null,
            implementation: e.implementation
          }, t
        }
        var $r = new WeakMap;

        function Yr(e, t) {
          if ("object" === typeof e && null !== e) {
            var n = $r.get(e);
            return void 0 !== n ? n : (t = {
              value: e,
              source: t,
              stack: ne(t)
            }, $r.set(e, t), t)
          }
          return {
            value: e,
            source: t,
            stack: ne(t)
          }
        }
        var Jr = [],
          Gr = 0,
          Qr = null,
          Xr = 0,
          Zr = [],
          ei = 0,
          ti = null,
          ni = 1,
          ri = "";

        function ii(e, t) {
          Jr[Gr++] = Xr, Jr[Gr++] = Qr, Qr = e, Xr = t
        }

        function si(e, t, n) {
          Zr[ei++] = ni, Zr[ei++] = ri, Zr[ei++] = ti, ti = e;
          var r = ni;
          e = ri;
          var i = 32 - we(r) - 1;
          r &= ~(1 << i), n += 1;
          var s = 32 - we(t) + i;
          if (30 < s) {
            var o = i - i % 5;
            s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, ni = 1 << 32 - we(t) + i | n << i | r, ri = s + e
          } else ni = 1 << s | n << i | r, ri = e
        }

        function oi(e) {
          null !== e.return && (ii(e, 1), si(e, 1, 0))
        }

        function li(e) {
          for (; e === Qr;) Qr = Jr[--Gr], Jr[Gr] = null, Xr = Jr[--Gr], Jr[Gr] = null;
          for (; e === ti;) ti = Zr[--ei], Zr[ei] = null, ri = Zr[--ei], Zr[ei] = null, ni = Zr[--ei], Zr[ei] = null
        }

        function ci(e, t) {
          Zr[ei++] = ni, Zr[ei++] = ri, Zr[ei++] = ti, ni = t.id, ri = t.overflow, ti = e
        }
        var ui = null,
          hi = null,
          di = !1,
          fi = null,
          pi = !1,
          gi = Error(o(519));

        function mi(e) {
          throw xi(Yr(Error(o(418, 1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML", "")), e)), gi
        }

        function yi(e) {
          var t = e.stateNode,
            n = e.type,
            r = e.memoizedProps;
          switch (t[Ue] = e, t[We] = r, n) {
            case "dialog":
              Qu("cancel", t), Qu("close", t);
              break;
            case "iframe":
            case "object":
            case "embed":
              Qu("load", t);
              break;
            case "video":
            case "audio":
              for (n = 0; n < Yu.length; n++) Qu(Yu[n], t);
              break;
            case "source":
              Qu("error", t);
              break;
            case "img":
            case "image":
            case "link":
              Qu("error", t), Qu("load", t);
              break;
            case "details":
              Qu("toggle", t);
              break;
            case "input":
              Qu("invalid", t), bt(t, r.value, r.defaultValue, r.checked, r.defaultChecked, r.type, r.name, !0);
              break;
            case "select":
              Qu("invalid", t);
              break;
            case "textarea":
              Qu("invalid", t), kt(t, r.value, r.defaultValue, r.children)
          }
          "string" !== typeof(n = r.children) && "number" !== typeof n && "bigint" !== typeof n || t.textContent === "" + n || !0 === r.suppressHydrationWarning || uh(t.textContent, n) ? (null != r.popover && (Qu("beforetoggle", t), Qu("toggle", t)), null != r.onScroll && Qu("scroll", t), null != r.onScrollEnd && Qu("scrollend", t), null != r.onClick && (t.onclick = Mt), t = !0) : t = !1, t || mi(e, !0)
        }

        function vi(e) {
          for (ui = e.return; ui;) switch (ui.tag) {
            case 5:
            case 31:
            case 13:
              return void(pi = !1);
            case 27:
            case 3:
              return void(pi = !0);
            default:
              ui = ui.return
          }
        }

        function bi(e) {
          if (e !== ui) return !1;
          if (!di) return vi(e), di = !0, !1;
          var t, n = e.tag;
          if ((t = 3 !== n && 27 !== n) && ((t = 5 === n) && (t = !("form" !== (t = e.type) && "button" !== t) || wh(e.type, e.memoizedProps)), t = !t), t && hi && mi(e), vi(e), 13 === n) {
            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
            hi = Ih(e)
          } else if (31 === n) {
            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
            hi = Ih(e)
          } else 27 === n ? (n = hi, Ch(e.type) ? (e = Nh, Nh = null, hi = e) : hi = n) : hi = ui ? jh(e.stateNode.nextSibling) : null;
          return !0
        }

        function wi() {
          hi = ui = null, di = !1
        }

        function _i() {
          var e = fi;
          return null !== e && (null === Rc ? Rc = e : Rc.push.apply(Rc, e), fi = null), e
        }

        function xi(e) {
          null === fi ? fi = [e] : fi.push(e)
        }
        var ki = F(null),
          Si = null,
          Ei = null;

        function Ti(e, t, n) {
          U(ki, t._currentValue), t._currentValue = n
        }

        function Ci(e) {
          e._currentValue = ki.current, B(ki)
        }

        function Oi(e, t, n) {
          for (; null !== e;) {
            var r = e.alternate;
            if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
            e = e.return
          }
        }

        function Pi(e, t, n, r) {
          var i = e.child;
          for (null !== i && (i.return = e); null !== i;) {
            var s = i.dependencies;
            if (null !== s) {
              var a = i.child;
              s = s.firstContext;
              e: for (; null !== s;) {
                var l = s;
                s = i;
                for (var c = 0; c < t.length; c++)
                  if (l.context === t[c]) {
                    s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), Oi(s.return, n, e), r || (a = null);
                    break e
                  } s = l.next
              }
            } else if (18 === i.tag) {
              if (null === (a = i.return)) throw Error(o(341));
              a.lanes |= n, null !== (s = a.alternate) && (s.lanes |= n), Oi(a, n, e), a = null
            } else a = i.child;
            if (null !== a) a.return = i;
            else
              for (a = i; null !== a;) {
                if (a === e) {
                  a = null;
                  break
                }
                if (null !== (i = a.sibling)) {
                  i.return = a.return, a = i;
                  break
                }
                a = a.return
              }
            i = a
          }
        }

        function Ai(e, t, n, r) {
          e = null;
          for (var i = t, s = !1; null !== i;) {
            if (!s)
              if (0 !== (524288 & i.flags)) s = !0;
              else if (0 !== (262144 & i.flags)) break;
            if (10 === i.tag) {
              var a = i.alternate;
              if (null === a) throw Error(o(387));
              if (null !== (a = a.memoizedProps)) {
                var l = i.type;
                Xn(i.pendingProps.value, a.value) || (null !== e ? e.push(l) : e = [l])
              }
            } else if (i === $.current) {
              if (null === (a = i.alternate)) throw Error(o(387));
              a.memoizedState.memoizedState !== i.memoizedState.memoizedState && (null !== e ? e.push(hd) : e = [hd])
            }
            i = i.return
          }
          null !== e && Pi(t, e, n, r), t.flags |= 262144
        }

        function Ri(e) {
          for (e = e.firstContext; null !== e;) {
            if (!Xn(e.context._currentValue, e.memoizedValue)) return !0;
            e = e.next
          }
          return !1
        }

        function Mi(e) {
          Si = e, Ei = null, null !== (e = e.dependencies) && (e.firstContext = null)
        }

        function Li(e) {
          return Ni(Si, e)
        }

        function ji(e, t) {
          return null === Si && Mi(e), Ni(e, t)
        }

        function Ni(e, t) {
          var n = t._currentValue;
          if (t = {
              context: t,
              memoizedValue: n,
              next: null
            }, null === Ei) {
            if (null === e) throw Error(o(308));
            Ei = t, e.dependencies = {
              lanes: 0,
              firstContext: t
            }, e.flags |= 524288
          } else Ei = Ei.next = t;
          return n
        }
        var Ii = "undefined" !== typeof AbortController ? AbortController : function() {
            var e = [],
              t = this.signal = {
                aborted: !1,
                addEventListener: function(t, n) {
                  e.push(n)
                }
              };
            this.abort = function() {
              t.aborted = !0, e.forEach(function(e) {
                return e()
              })
            }
          },
          Di = r.unstable_scheduleCallback,
          zi = r.unstable_NormalPriority,
          Fi = {
            $$typeof: _,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0
          };

        function Bi() {
          return {
            controller: new Ii,
            data: new Map,
            refCount: 0
          }
        }

        function Ui(e) {
          e.refCount--, 0 === e.refCount && Di(zi, function() {
            e.controller.abort()
          })
        }
        var Wi = null,
          Hi = 0,
          Vi = 0,
          qi = null;

        function Ki() {
          if (0 === --Hi && null !== Wi) {
            null !== qi && (qi.status = "fulfilled");
            var e = Wi;
            Wi = null, Vi = 0, qi = null;
            for (var t = 0; t < e.length; t++)(0, e[t])()
          }
        }
        var $i = j.S;
        j.S = function(e, t) {
          jc = le(), "object" === typeof t && null !== t && "function" === typeof t.then && function(e, t) {
            if (null === Wi) {
              var n = Wi = [];
              Hi = 0, Vi = Hu(), qi = {
                status: "pending",
                value: void 0,
                then: function(e) {
                  n.push(e)
                }
              }
            }
            Hi++, t.then(Ki, Ki)
          }(0, t), null !== $i && $i(e, t)
        };
        var Yi = F(null);

        function Ji() {
          var e = Yi.current;
          return null !== e ? e : gc.pooledCache
        }

        function Gi(e, t) {
          U(Yi, null === t ? Yi.current : t.pool)
        }

        function Qi() {
          var e = Ji();
          return null === e ? null : {
            parent: Fi._currentValue,
            pool: e
          }
        }
        var Xi = Error(o(460)),
          Zi = Error(o(474)),
          es = Error(o(542)),
          ts = {
            then: function() {}
          };

        function ns(e) {
          return "fulfilled" === (e = e.status) || "rejected" === e
        }

        function rs(e, t, n) {
          switch (void 0 === (n = e[n]) ? e.push(t) : n !== t && (t.then(Mt, Mt), t = n), t.status) {
            case "fulfilled":
              return t.value;
            case "rejected":
              throw as(e = t.reason), e;
            default:
              if ("string" === typeof t.status) t.then(Mt, Mt);
              else {
                if (null !== (e = gc) && 100 < e.shellSuspendCounter) throw Error(o(482));
                (e = t).status = "pending", e.then(function(e) {
                  if ("pending" === t.status) {
                    var n = t;
                    n.status = "fulfilled", n.value = e
                  }
                }, function(e) {
                  if ("pending" === t.status) {
                    var n = t;
                    n.status = "rejected", n.reason = e
                  }
                })
              }
              switch (t.status) {
                case "fulfilled":
                  return t.value;
                case "rejected":
                  throw as(e = t.reason), e
              }
              throw ss = t, Xi
          }
        }

        function is(e) {
          try {
            return (0, e._init)(e._payload)
          } catch (t) {
            if (null !== t && "object" === typeof t && "function" === typeof t.then) throw ss = t, Xi;
            throw t
          }
        }
        var ss = null;

        function os() {
          if (null === ss) throw Error(o(459));
          var e = ss;
          return ss = null, e
        }

        function as(e) {
          if (e === Xi || e === es) throw Error(o(483))
        }
        var ls = null,
          cs = 0;

        function us(e) {
          var t = cs;
          return cs += 1, null === ls && (ls = []), rs(ls, e, t)
        }

        function hs(e, t) {
          t = t.props.ref, e.ref = void 0 !== t ? t : null
        }

        function ds(e, t) {
          if (t.$$typeof === p) throw Error(o(525));
          throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
        }

        function fs(e) {
          function t(t, n) {
            if (e) {
              var r = t.deletions;
              null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
            }
          }

          function n(n, r) {
            if (!e) return null;
            for (; null !== r;) t(n, r), r = r.sibling;
            return null
          }

          function r(e) {
            for (var t = new Map; null !== e;) null !== e.key ? t.set(e.key, e) : t.set(e.index, e), e = e.sibling;
            return t
          }

          function i(e, t) {
            return (e = Br(e, t)).index = 0, e.sibling = null, e
          }

          function s(t, n, r) {
            return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 67108866, n) : r : (t.flags |= 67108866, n) : (t.flags |= 1048576, n)
          }

          function a(t) {
            return e && null === t.alternate && (t.flags |= 67108866), t
          }

          function l(e, t, n, r) {
            return null === t || 6 !== t.tag ? ((t = Vr(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
          }

          function c(e, t, n, r) {
            var s = n.type;
            return s === y ? h(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === s || "object" === typeof s && null !== s && s.$$typeof === T && is(s) === t.type) ? (hs(t = i(t, n.props), n), t.return = e, t) : (hs(t = Wr(n.type, n.key, n.props, null, e.mode, r), n), t.return = e, t)
          }

          function u(e, t, n, r) {
            return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Kr(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
          }

          function h(e, t, n, r, s) {
            return null === t || 7 !== t.tag ? ((t = Hr(n, e.mode, r, s)).return = e, t) : ((t = i(t, n)).return = e, t)
          }

          function d(e, t, n) {
            if ("string" === typeof t && "" !== t || "number" === typeof t || "bigint" === typeof t) return (t = Vr("" + t, e.mode, n)).return = e, t;
            if ("object" === typeof t && null !== t) {
              switch (t.$$typeof) {
                case g:
                  return hs(n = Wr(t.type, t.key, t.props, null, e.mode, n), t), n.return = e, n;
                case m:
                  return (t = Kr(t, e.mode, n)).return = e, t;
                case T:
                  return d(e, t = is(t), n)
              }
              if (L(t) || A(t)) return (t = Hr(t, e.mode, n, null)).return = e, t;
              if ("function" === typeof t.then) return d(e, us(t), n);
              if (t.$$typeof === _) return d(e, ji(e, t), n);
              ds(e, t)
            }
            return null
          }

          function f(e, t, n, r) {
            var i = null !== t ? t.key : null;
            if ("string" === typeof n && "" !== n || "number" === typeof n || "bigint" === typeof n) return null !== i ? null : l(e, t, "" + n, r);
            if ("object" === typeof n && null !== n) {
              switch (n.$$typeof) {
                case g:
                  return n.key === i ? c(e, t, n, r) : null;
                case m:
                  return n.key === i ? u(e, t, n, r) : null;
                case T:
                  return f(e, t, n = is(n), r)
              }
              if (L(n) || A(n)) return null !== i ? null : h(e, t, n, r, null);
              if ("function" === typeof n.then) return f(e, t, us(n), r);
              if (n.$$typeof === _) return f(e, t, ji(e, n), r);
              ds(e, n)
            }
            return null
          }

          function p(e, t, n, r, i) {
            if ("string" === typeof r && "" !== r || "number" === typeof r || "bigint" === typeof r) return l(t, e = e.get(n) || null, "" + r, i);
            if ("object" === typeof r && null !== r) {
              switch (r.$$typeof) {
                case g:
                  return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                case m:
                  return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                case T:
                  return p(e, t, n, r = is(r), i)
              }
              if (L(r) || A(r)) return h(t, e = e.get(n) || null, r, i, null);
              if ("function" === typeof r.then) return p(e, t, n, us(r), i);
              if (r.$$typeof === _) return p(e, t, n, ji(t, r), i);
              ds(t, r)
            }
            return null
          }

          function v(l, c, u, h) {
            if ("object" === typeof u && null !== u && u.type === y && null === u.key && (u = u.props.children), "object" === typeof u && null !== u) {
              switch (u.$$typeof) {
                case g:
                  e: {
                    for (var b = u.key; null !== c;) {
                      if (c.key === b) {
                        if ((b = u.type) === y) {
                          if (7 === c.tag) {
                            n(l, c.sibling), (h = i(c, u.props.children)).return = l, l = h;
                            break e
                          }
                        } else if (c.elementType === b || "object" === typeof b && null !== b && b.$$typeof === T && is(b) === c.type) {
                          n(l, c.sibling), hs(h = i(c, u.props), u), h.return = l, l = h;
                          break e
                        }
                        n(l, c);
                        break
                      }
                      t(l, c), c = c.sibling
                    }
                    u.type === y ? ((h = Hr(u.props.children, l.mode, h, u.key)).return = l, l = h) : (hs(h = Wr(u.type, u.key, u.props, null, l.mode, h), u), h.return = l, l = h)
                  }
                  return a(l);
                case m:
                  e: {
                    for (b = u.key; null !== c;) {
                      if (c.key === b) {
                        if (4 === c.tag && c.stateNode.containerInfo === u.containerInfo && c.stateNode.implementation === u.implementation) {
                          n(l, c.sibling), (h = i(c, u.children || [])).return = l, l = h;
                          break e
                        }
                        n(l, c);
                        break
                      }
                      t(l, c), c = c.sibling
                    }(h = Kr(u, l.mode, h)).return = l,
                    l = h
                  }
                  return a(l);
                case T:
                  return v(l, c, u = is(u), h)
              }
              if (L(u)) return function(i, o, a, l) {
                for (var c = null, u = null, h = o, g = o = 0, m = null; null !== h && g < a.length; g++) {
                  h.index > g ? (m = h, h = null) : m = h.sibling;
                  var y = f(i, h, a[g], l);
                  if (null === y) {
                    null === h && (h = m);
                    break
                  }
                  e && h && null === y.alternate && t(i, h), o = s(y, o, g), null === u ? c = y : u.sibling = y, u = y, h = m
                }
                if (g === a.length) return n(i, h), di && ii(i, g), c;
                if (null === h) {
                  for (; g < a.length; g++) null !== (h = d(i, a[g], l)) && (o = s(h, o, g), null === u ? c = h : u.sibling = h, u = h);
                  return di && ii(i, g), c
                }
                for (h = r(h); g < a.length; g++) null !== (m = p(h, i, g, a[g], l)) && (e && null !== m.alternate && h.delete(null === m.key ? g : m.key), o = s(m, o, g), null === u ? c = m : u.sibling = m, u = m);
                return e && h.forEach(function(e) {
                  return t(i, e)
                }), di && ii(i, g), c
              }(l, c, u, h);
              if (A(u)) {
                if ("function" !== typeof(b = A(u))) throw Error(o(150));
                return function(i, a, l, c) {
                  if (null == l) throw Error(o(151));
                  for (var u = null, h = null, g = a, m = a = 0, y = null, v = l.next(); null !== g && !v.done; m++, v = l.next()) {
                    g.index > m ? (y = g, g = null) : y = g.sibling;
                    var b = f(i, g, v.value, c);
                    if (null === b) {
                      null === g && (g = y);
                      break
                    }
                    e && g && null === b.alternate && t(i, g), a = s(b, a, m), null === h ? u = b : h.sibling = b, h = b, g = y
                  }
                  if (v.done) return n(i, g), di && ii(i, m), u;
                  if (null === g) {
                    for (; !v.done; m++, v = l.next()) null !== (v = d(i, v.value, c)) && (a = s(v, a, m), null === h ? u = v : h.sibling = v, h = v);
                    return di && ii(i, m), u
                  }
                  for (g = r(g); !v.done; m++, v = l.next()) null !== (v = p(g, i, m, v.value, c)) && (e && null !== v.alternate && g.delete(null === v.key ? m : v.key), a = s(v, a, m), null === h ? u = v : h.sibling = v, h = v);
                  return e && g.forEach(function(e) {
                    return t(i, e)
                  }), di && ii(i, m), u
                }(l, c, u = b.call(u), h)
              }
              if ("function" === typeof u.then) return v(l, c, us(u), h);
              if (u.$$typeof === _) return v(l, c, ji(l, u), h);
              ds(l, u)
            }
            return "string" === typeof u && "" !== u || "number" === typeof u || "bigint" === typeof u ? (u = "" + u, null !== c && 6 === c.tag ? (n(l, c.sibling), (h = i(c, u)).return = l, l = h) : (n(l, c), (h = Vr(u, l.mode, h)).return = l, l = h), a(l)) : n(l, c)
          }
          return function(e, t, n, r) {
            try {
              cs = 0;
              var i = v(e, t, n, r);
              return ls = null, i
            } catch (o) {
              if (o === Xi || o === es) throw o;
              var s = zr(29, o, null, e.mode);
              return s.lanes = r, s.return = e, s
            }
          }
        }
        var ps = fs(!0),
          gs = fs(!1),
          ms = !1;

        function ys(e) {
          e.updateQueue = {
            baseState: e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              lanes: 0,
              hiddenCallbacks: null
            },
            callbacks: null
          }
        }

        function vs(e, t) {
          e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
            baseState: e.baseState,
            firstBaseUpdate: e.firstBaseUpdate,
            lastBaseUpdate: e.lastBaseUpdate,
            shared: e.shared,
            callbacks: null
          })
        }

        function bs(e) {
          return {
            lane: e,
            tag: 0,
            payload: null,
            callback: null,
            next: null
          }
        }

        function ws(e, t, n) {
          var r = e.updateQueue;
          if (null === r) return null;
          if (r = r.shared, 0 !== (2 & pc)) {
            var i = r.pending;
            return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, t = Nr(e), jr(e, null, n), t
          }
          return Rr(e, r, t, n), Nr(e)
        }

        function _s(e, t, n) {
          if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194048 & n))) {
            var r = t.lanes;
            n |= r &= e.pendingLanes, t.lanes = n, je(e, n)
          }
        }

        function xs(e, t) {
          var n = e.updateQueue,
            r = e.alternate;
          if (null !== r && n === (r = r.updateQueue)) {
            var i = null,
              s = null;
            if (null !== (n = n.firstBaseUpdate)) {
              do {
                var o = {
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: null,
                  next: null
                };
                null === s ? i = s = o : s = s.next = o, n = n.next
              } while (null !== n);
              null === s ? i = s = t : s = s.next = t
            } else i = s = t;
            return n = {
              baseState: r.baseState,
              firstBaseUpdate: i,
              lastBaseUpdate: s,
              shared: r.shared,
              callbacks: r.callbacks
            }, void(e.updateQueue = n)
          }
          null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
        }
        var ks = !1;

        function Ss() {
          if (ks) {
            if (null !== qi) throw qi
          }
        }

        function Es(e, t, n, r) {
          ks = !1;
          var i = e.updateQueue;
          ms = !1;
          var s = i.firstBaseUpdate,
            o = i.lastBaseUpdate,
            a = i.shared.pending;
          if (null !== a) {
            i.shared.pending = null;
            var l = a,
              c = l.next;
            l.next = null, null === o ? s = c : o.next = c, o = l;
            var u = e.alternate;
            null !== u && ((a = (u = u.updateQueue).lastBaseUpdate) !== o && (null === a ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l))
          }
          if (null !== s) {
            var h = i.baseState;
            for (o = 0, u = c = l = null, a = s;;) {
              var d = -536870913 & a.lane,
                p = d !== a.lane;
              if (p ? (yc & d) === d : (r & d) === d) {
                0 !== d && d === Vi && (ks = !0), null !== u && (u = u.next = {
                  lane: 0,
                  tag: a.tag,
                  payload: a.payload,
                  callback: null,
                  next: null
                });
                e: {
                  var g = e,
                    m = a;d = t;
                  var y = n;
                  switch (m.tag) {
                    case 1:
                      if ("function" === typeof(g = m.payload)) {
                        h = g.call(y, h, d);
                        break e
                      }
                      h = g;
                      break e;
                    case 3:
                      g.flags = -65537 & g.flags | 128;
                    case 0:
                      if (null === (d = "function" === typeof(g = m.payload) ? g.call(y, h, d) : g) || void 0 === d) break e;
                      h = f({}, h, d);
                      break e;
                    case 2:
                      ms = !0
                  }
                }
                null !== (d = a.callback) && (e.flags |= 64, p && (e.flags |= 8192), null === (p = i.callbacks) ? i.callbacks = [d] : p.push(d))
              } else p = {
                lane: d,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
              }, null === u ? (c = u = p, l = h) : u = u.next = p, o |= d;
              if (null === (a = a.next)) {
                if (null === (a = i.shared.pending)) break;
                a = (p = a).next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null
              }
            }
            null === u && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null === s && (i.shared.lanes = 0), Ec |= o, e.lanes = o, e.memoizedState = h
          }
        }

        function Ts(e, t) {
          if ("function" !== typeof e) throw Error(o(191, e));
          e.call(t)
        }

        function Cs(e, t) {
          var n = e.callbacks;
          if (null !== n)
            for (e.callbacks = null, e = 0; e < n.length; e++) Ts(n[e], t)
        }
        var Os = F(null),
          Ps = F(0);

        function As(e, t) {
          U(Ps, e = kc), U(Os, t), kc = e | t.baseLanes
        }

        function Rs() {
          U(Ps, kc), U(Os, Os.current)
        }

        function Ms() {
          kc = Ps.current, B(Os), B(Ps)
        }
        var Ls = F(null),
          js = null;

        function Ns(e) {
          var t = e.alternate;
          U(Bs, 1 & Bs.current), U(Ls, e), null === js && (null === t || null !== Os.current || null !== t.memoizedState) && (js = e)
        }

        function Is(e) {
          U(Bs, Bs.current), U(Ls, e), null === js && (js = e)
        }

        function Ds(e) {
          22 === e.tag ? (U(Bs, Bs.current), U(Ls, e), null === js && (js = e)) : zs()
        }

        function zs() {
          U(Bs, Bs.current), U(Ls, Ls.current)
        }

        function Fs(e) {
          B(Ls), js === e && (js = null), B(Bs)
        }
        var Bs = F(0);

        function Us(e) {
          for (var t = e; null !== t;) {
            if (13 === t.tag) {
              var n = t.memoizedState;
              if (null !== n && (null === (n = n.dehydrated) || Mh(n) || Lh(n))) return t
            } else if (19 !== t.tag || "forwards" !== t.memoizedProps.revealOrder && "backwards" !== t.memoizedProps.revealOrder && "unstable_legacy-backwards" !== t.memoizedProps.revealOrder && "together" !== t.memoizedProps.revealOrder) {
              if (null !== t.child) {
                t.child.return = t, t = t.child;
                continue
              }
            } else if (0 !== (128 & t.flags)) return t;
            if (t === e) break;
            for (; null === t.sibling;) {
              if (null === t.return || t.return === e) return null;
              t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
          }
          return null
        }
        var Ws = 0,
          Hs = null,
          Vs = null,
          qs = null,
          Ks = !1,
          $s = !1,
          Ys = !1,
          Js = 0,
          Gs = 0,
          Qs = null,
          Xs = 0;

        function Zs() {
          throw Error(o(321))
        }

        function eo(e, t) {
          if (null === t) return !1;
          for (var n = 0; n < t.length && n < e.length; n++)
            if (!Xn(e[n], t[n])) return !1;
          return !0
        }

        function to(e, t, n, r, i, s) {
          return Ws = s, Hs = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, j.H = null === e || null === e.memoizedState ? ya : va, Ys = !1, s = n(r, i), Ys = !1, $s && (s = ro(t, n, r, i)), no(e), s
        }

        function no(e) {
          j.H = ma;
          var t = null !== Vs && null !== Vs.next;
          if (Ws = 0, qs = Vs = Hs = null, Ks = !1, Gs = 0, Qs = null, t) throw Error(o(300));
          null === e || ja || null !== (e = e.dependencies) && Ri(e) && (ja = !0)
        }

        function ro(e, t, n, r) {
          Hs = e;
          var i = 0;
          do {
            if ($s && (Qs = null), Gs = 0, $s = !1, 25 <= i) throw Error(o(301));
            if (i += 1, qs = Vs = null, null != e.updateQueue) {
              var s = e.updateQueue;
              s.lastEffect = null, s.events = null, s.stores = null, null != s.memoCache && (s.memoCache.index = 0)
            }
            j.H = ba, s = t(n, r)
          } while ($s);
          return s
        }

        function io() {
          var e = j.H,
            t = e.useState()[0];
          return t = "function" === typeof t.then ? uo(t) : t, e = e.useState()[0], (null !== Vs ? Vs.memoizedState : null) !== e && (Hs.flags |= 1024), t
        }

        function so() {
          var e = 0 !== Js;
          return Js = 0, e
        }

        function oo(e, t, n) {
          t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~n
        }

        function ao(e) {
          if (Ks) {
            for (e = e.memoizedState; null !== e;) {
              var t = e.queue;
              null !== t && (t.pending = null), e = e.next
            }
            Ks = !1
          }
          Ws = 0, qs = Vs = Hs = null, $s = !1, Gs = Js = 0, Qs = null
        }

        function lo() {
          var e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          return null === qs ? Hs.memoizedState = qs = e : qs = qs.next = e, qs
        }

        function co() {
          if (null === Vs) {
            var e = Hs.alternate;
            e = null !== e ? e.memoizedState : null
          } else e = Vs.next;
          var t = null === qs ? Hs.memoizedState : qs.next;
          if (null !== t) qs = t, Vs = e;
          else {
            if (null === e) {
              if (null === Hs.alternate) throw Error(o(467));
              throw Error(o(310))
            }
            e = {
              memoizedState: (Vs = e).memoizedState,
              baseState: Vs.baseState,
              baseQueue: Vs.baseQueue,
              queue: Vs.queue,
              next: null
            }, null === qs ? Hs.memoizedState = qs = e : qs = qs.next = e
          }
          return qs
        }

        function uo(e) {
          var t = Gs;
          return Gs += 1, null === Qs && (Qs = []), e = rs(Qs, e, t), t = Hs, null === (null === qs ? t.memoizedState : qs.next) && (t = t.alternate, j.H = null === t || null === t.memoizedState ? ya : va), e
        }

        function ho(e) {
          if (null !== e && "object" === typeof e) {
            if ("function" === typeof e.then) return uo(e);
            if (e.$$typeof === _) return Li(e)
          }
          throw Error(o(438, String(e)))
        }

        function fo(e) {
          var t = null,
            n = Hs.updateQueue;
          if (null !== n && (t = n.memoCache), null == t) {
            var r = Hs.alternate;
            null !== r && (null !== (r = r.updateQueue) && (null != (r = r.memoCache) && (t = {
              data: r.data.map(function(e) {
                return e.slice()
              }),
              index: 0
            })))
          }
          if (null == t && (t = {
              data: [],
              index: 0
            }), null === n && (n = {
              lastEffect: null,
              events: null,
              stores: null,
              memoCache: null
            }, Hs.updateQueue = n), n.memoCache = t, void 0 === (n = t.data[t.index]))
            for (n = t.data[t.index] = Array(e), r = 0; r < e; r++) n[r] = O;
          return t.index++, n
        }

        function po(e, t) {
          return "function" === typeof t ? t(e) : t
        }

        function go(e) {
          return mo(co(), Vs, e)
        }

        function mo(e, t, n) {
          var r = e.queue;
          if (null === r) throw Error(o(311));
          r.lastRenderedReducer = n;
          var i = e.baseQueue,
            s = r.pending;
          if (null !== s) {
            if (null !== i) {
              var a = i.next;
              i.next = s.next, s.next = a
            }
            t.baseQueue = i = s, r.pending = null
          }
          if (s = e.baseState, null === i) e.memoizedState = s;
          else {
            var l = a = null,
              c = null,
              u = t = i.next,
              h = !1;
            do {
              var d = -536870913 & u.lane;
              if (d !== u.lane ? (yc & d) === d : (Ws & d) === d) {
                var f = u.revertLane;
                if (0 === f) null !== c && (c = c.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: u.action,
                  hasEagerState: u.hasEagerState,
                  eagerState: u.eagerState,
                  next: null
                }), d === Vi && (h = !0);
                else {
                  if ((Ws & f) === f) {
                    u = u.next, f === Vi && (h = !0);
                    continue
                  }
                  d = {
                    lane: 0,
                    revertLane: u.revertLane,
                    gesture: null,
                    action: u.action,
                    hasEagerState: u.hasEagerState,
                    eagerState: u.eagerState,
                    next: null
                  }, null === c ? (l = c = d, a = s) : c = c.next = d, Hs.lanes |= f, Ec |= f
                }
                d = u.action, Ys && n(s, d), s = u.hasEagerState ? u.eagerState : n(s, d)
              } else f = {
                lane: d,
                revertLane: u.revertLane,
                gesture: u.gesture,
                action: u.action,
                hasEagerState: u.hasEagerState,
                eagerState: u.eagerState,
                next: null
              }, null === c ? (l = c = f, a = s) : c = c.next = f, Hs.lanes |= d, Ec |= d;
              u = u.next
            } while (null !== u && u !== t);
            if (null === c ? a = s : c.next = l, !Xn(s, e.memoizedState) && (ja = !0, h && null !== (n = qi))) throw n;
            e.memoizedState = s, e.baseState = a, e.baseQueue = c, r.lastRenderedState = s
          }
          return null === i && (r.lanes = 0), [e.memoizedState, r.dispatch]
        }

        function yo(e) {
          var t = co(),
            n = t.queue;
          if (null === n) throw Error(o(311));
          n.lastRenderedReducer = e;
          var r = n.dispatch,
            i = n.pending,
            s = t.memoizedState;
          if (null !== i) {
            n.pending = null;
            var a = i = i.next;
            do {
              s = e(s, a.action), a = a.next
            } while (a !== i);
            Xn(s, t.memoizedState) || (ja = !0), t.memoizedState = s, null === t.baseQueue && (t.baseState = s), n.lastRenderedState = s
          }
          return [s, r]
        }

        function vo(e, t, n) {
          var r = Hs,
            i = co(),
            s = di;
          if (s) {
            if (void 0 === n) throw Error(o(407));
            n = n()
          } else n = t();
          var a = !Xn((Vs || i).memoizedState, n);
          if (a && (i.memoizedState = n, ja = !0), i = i.queue, Ho(_o.bind(null, r, i, e), [e]), i.getSnapshot !== t || a || null !== qs && 1 & qs.memoizedState.tag) {
            if (r.flags |= 2048, zo(9, {
                destroy: void 0
              }, wo.bind(null, r, i, n, t), null), null === gc) throw Error(o(349));
            s || 0 !== (127 & Ws) || bo(r, t, n)
          }
          return n
        }

        function bo(e, t, n) {
          e.flags |= 16384, e = {
            getSnapshot: t,
            value: n
          }, null === (t = Hs.updateQueue) ? (t = {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
          }, Hs.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
        }

        function wo(e, t, n, r) {
          t.value = n, t.getSnapshot = r, xo(t) && ko(e)
        }

        function _o(e, t, n) {
          return n(function() {
            xo(t) && ko(e)
          })
        }

        function xo(e) {
          var t = e.getSnapshot;
          e = e.value;
          try {
            var n = t();
            return !Xn(e, n)
          } catch (r) {
            return !0
          }
        }

        function ko(e) {
          var t = Lr(e, 2);
          null !== t && Jc(t, e, 2)
        }

        function So(e) {
          var t = lo();
          if ("function" === typeof e) {
            var n = e;
            if (e = n(), Ys) {
              be(!0);
              try {
                n()
              } finally {
                be(!1)
              }
            }
          }
          return t.memoizedState = t.baseState = e, t.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: po,
            lastRenderedState: e
          }, t
        }

        function Eo(e, t, n, r) {
          return e.baseState = n, mo(e, Vs, "function" === typeof r ? r : po)
        }

        function To(e, t, n, r, i) {
          if (fa(e)) throw Error(o(485));
          if (null !== (e = t.action)) {
            var s = {
              payload: i,
              action: e,
              next: null,
              isTransition: !0,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(e) {
                s.listeners.push(e)
              }
            };
            null !== j.T ? n(!0) : s.isTransition = !1, r(s), null === (n = t.pending) ? (s.next = t.pending = s, Co(t, s)) : (s.next = n.next, t.pending = n.next = s)
          }
        }

        function Co(e, t) {
          var n = t.action,
            r = t.payload,
            i = e.state;
          if (t.isTransition) {
            var s = j.T,
              o = {};
            j.T = o;
            try {
              var a = n(i, r),
                l = j.S;
              null !== l && l(o, a), Oo(e, t, a)
            } catch (c) {
              Ao(e, t, c)
            } finally {
              null !== s && null !== o.types && (s.types = o.types), j.T = s
            }
          } else try {
            Oo(e, t, s = n(i, r))
          } catch (u) {
            Ao(e, t, u)
          }
        }

        function Oo(e, t, n) {
          null !== n && "object" === typeof n && "function" === typeof n.then ? n.then(function(n) {
            Po(e, t, n)
          }, function(n) {
            return Ao(e, t, n)
          }) : Po(e, t, n)
        }

        function Po(e, t, n) {
          t.status = "fulfilled", t.value = n, Ro(t), e.state = n, null !== (t = e.pending) && ((n = t.next) === t ? e.pending = null : (n = n.next, t.next = n, Co(e, n)))
        }

        function Ao(e, t, n) {
          var r = e.pending;
          if (e.pending = null, null !== r) {
            r = r.next;
            do {
              t.status = "rejected", t.reason = n, Ro(t), t = t.next
            } while (t !== r)
          }
          e.action = null
        }

        function Ro(e) {
          e = e.listeners;
          for (var t = 0; t < e.length; t++)(0, e[t])()
        }

        function Mo(e, t) {
          return t
        }

        function Lo(e, t) {
          if (di) {
            var n = gc.formState;
            if (null !== n) {
              e: {
                var r = Hs;
                if (di) {
                  if (hi) {
                    t: {
                      for (var i = hi, s = pi; 8 !== i.nodeType;) {
                        if (!s) {
                          i = null;
                          break t
                        }
                        if (null === (i = jh(i.nextSibling))) {
                          i = null;
                          break t
                        }
                      }
                      i = "F!" === (s = i.data) || "F" === s ? i : null
                    }
                    if (i) {
                      hi = jh(i.nextSibling), r = "F!" === i.data;
                      break e
                    }
                  }
                  mi(r)
                }
                r = !1
              }
              r && (t = n[0])
            }
          }
          return (n = lo()).memoizedState = n.baseState = t, r = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Mo,
            lastRenderedState: t
          }, n.queue = r, n = ua.bind(null, Hs, r), r.dispatch = n, r = So(!1), s = da.bind(null, Hs, !1, r.queue), i = {
            state: t,
            dispatch: null,
            action: e,
            pending: null
          }, (r = lo()).queue = i, n = To.bind(null, Hs, i, s, n), i.dispatch = n, r.memoizedState = e, [t, n, !1]
        }

        function jo(e) {
          return No(co(), Vs, e)
        }

        function No(e, t, n) {
          if (t = mo(e, t, Mo)[0], e = go(po)[0], "object" === typeof t && null !== t && "function" === typeof t.then) try {
            var r = uo(t)
          } catch (o) {
            if (o === Xi) throw es;
            throw o
          } else r = t;
          var i = (t = co()).queue,
            s = i.dispatch;
          return n !== t.memoizedState && (Hs.flags |= 2048, zo(9, {
            destroy: void 0
          }, Io.bind(null, i, n), null)), [r, s, e]
        }

        function Io(e, t) {
          e.action = t
        }

        function Do(e) {
          var t = co(),
            n = Vs;
          if (null !== n) return No(t, n, e);
          co(), t = t.memoizedState;
          var r = (n = co()).queue.dispatch;
          return n.memoizedState = e, [t, r, !1]
        }

        function zo(e, t, n, r) {
          return e = {
            tag: e,
            create: n,
            deps: r,
            inst: t,
            next: null
          }, null === (t = Hs.updateQueue) && (t = {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
          }, Hs.updateQueue = t), null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
        }

        function Fo() {
          return co().memoizedState
        }

        function Bo(e, t, n, r) {
          var i = lo();
          Hs.flags |= e, i.memoizedState = zo(1 | t, {
            destroy: void 0
          }, n, void 0 === r ? null : r)
        }

        function Uo(e, t, n, r) {
          var i = co();
          r = void 0 === r ? null : r;
          var s = i.memoizedState.inst;
          null !== Vs && null !== r && eo(r, Vs.memoizedState.deps) ? i.memoizedState = zo(t, s, n, r) : (Hs.flags |= e, i.memoizedState = zo(1 | t, s, n, r))
        }

        function Wo(e, t) {
          Bo(8390656, 8, e, t)
        }

        function Ho(e, t) {
          Uo(2048, 8, e, t)
        }

        function Vo(e) {
          var t = co().memoizedState;
          return function(e) {
              Hs.flags |= 4;
              var t = Hs.updateQueue;
              if (null === t) t = {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null
              }, Hs.updateQueue = t, t.events = [e];
              else {
                var n = t.events;
                null === n ? t.events = [e] : n.push(e)
              }
            }({
              ref: t,
              nextImpl: e
            }),
            function() {
              if (0 !== (2 & pc)) throw Error(o(440));
              return t.impl.apply(void 0, arguments)
            }
        }

        function qo(e, t) {
          return Uo(4, 2, e, t)
        }

        function Ko(e, t) {
          return Uo(4, 4, e, t)
        }

        function $o(e, t) {
          if ("function" === typeof t) {
            e = e();
            var n = t(e);
            return function() {
              "function" === typeof n ? n() : t(null)
            }
          }
          if (null !== t && void 0 !== t) return e = e(), t.current = e,
            function() {
              t.current = null
            }
        }

        function Yo(e, t, n) {
          n = null !== n && void 0 !== n ? n.concat([e]) : null, Uo(4, 4, $o.bind(null, t, e), n)
        }

        function Jo() {}

        function Go(e, t) {
          var n = co();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          return null !== t && eo(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
        }

        function Qo(e, t) {
          var n = co();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          if (null !== t && eo(t, r[1])) return r[0];
          if (r = e(), Ys) {
            be(!0);
            try {
              e()
            } finally {
              be(!1)
            }
          }
          return n.memoizedState = [r, t], r
        }

        function Xo(e, t, n) {
          return void 0 === n || 0 !== (1073741824 & Ws) && 0 === (261930 & yc) ? e.memoizedState = t : (e.memoizedState = n, e = Yc(), Hs.lanes |= e, Ec |= e, n)
        }

        function Zo(e, t, n, r) {
          return Xn(n, t) ? n : null !== Os.current ? (e = Xo(e, n, r), Xn(e, t) || (ja = !0), e) : 0 === (42 & Ws) || 0 !== (1073741824 & Ws) && 0 === (261930 & yc) ? (ja = !0, e.memoizedState = n) : (e = Yc(), Hs.lanes |= e, Ec |= e, t)
        }

        function ea(e, t, n, r, i) {
          var s = N.p;
          N.p = 0 !== s && 8 > s ? s : 8;
          var o = j.T,
            a = {};
          j.T = a, da(e, !1, t, n);
          try {
            var l = i(),
              c = j.S;
            if (null !== c && c(a, l), null !== l && "object" === typeof l && "function" === typeof l.then) {
              var u = function(e, t) {
                var n = [],
                  r = {
                    status: "pending",
                    value: null,
                    reason: null,
                    then: function(e) {
                      n.push(e)
                    }
                  };
                return e.then(function() {
                  r.status = "fulfilled", r.value = t;
                  for (var e = 0; e < n.length; e++)(0, n[e])(t)
                }, function(e) {
                  for (r.status = "rejected", r.reason = e, e = 0; e < n.length; e++)(0, n[e])(void 0)
                }), r
              }(l, r);
              ha(e, t, u, $c())
            } else ha(e, t, r, $c())
          } catch (h) {
            ha(e, t, {
              then: function() {},
              status: "rejected",
              reason: h
            }, $c())
          } finally {
            N.p = s, null !== o && null !== a.types && (o.types = a.types), j.T = o
          }
        }

        function ta() {}

        function na(e, t, n, r) {
          if (5 !== e.tag) throw Error(o(476));
          var i = ra(e).queue;
          ea(e, i, t, I, null === n ? ta : function() {
            return ia(e), n(r)
          })
        }

        function ra(e) {
          var t = e.memoizedState;
          if (null !== t) return t;
          var n = {};
          return (t = {
            memoizedState: I,
            baseState: I,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: po,
              lastRenderedState: I
            },
            next: null
          }).next = {
            memoizedState: n,
            baseState: n,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: po,
              lastRenderedState: n
            },
            next: null
          }, e.memoizedState = t, null !== (e = e.alternate) && (e.memoizedState = t), t
        }

        function ia(e) {
          var t = ra(e);
          null === t.next && (t = e.alternate.memoizedState), ha(e, t.next.queue, {}, $c())
        }

        function sa() {
          return Li(hd)
        }

        function oa() {
          return co().memoizedState
        }

        function aa() {
          return co().memoizedState
        }

        function la(e) {
          for (var t = e.return; null !== t;) {
            switch (t.tag) {
              case 24:
              case 3:
                var n = $c(),
                  r = ws(t, e = bs(n), n);
                return null !== r && (Jc(r, t, n), _s(r, t, n)), t = {
                  cache: Bi()
                }, void(e.payload = t)
            }
            t = t.return
          }
        }

        function ca(e, t, n) {
          var r = $c();
          n = {
            lane: r,
            revertLane: 0,
            gesture: null,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
          }, fa(e) ? pa(t, n) : null !== (n = Mr(e, t, n, r)) && (Jc(n, e, r), ga(n, t, r))
        }

        function ua(e, t, n) {
          ha(e, t, n, $c())
        }

        function ha(e, t, n, r) {
          var i = {
            lane: r,
            revertLane: 0,
            gesture: null,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
          };
          if (fa(e)) pa(t, i);
          else {
            var s = e.alternate;
            if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try {
              var o = t.lastRenderedState,
                a = s(o, n);
              if (i.hasEagerState = !0, i.eagerState = a, Xn(a, o)) return Rr(e, t, i, 0), null === gc && Ar(), !1
            } catch (l) {}
            if (null !== (n = Mr(e, t, i, r))) return Jc(n, e, r), ga(n, t, r), !0
          }
          return !1
        }

        function da(e, t, n, r) {
          if (r = {
              lane: 2,
              revertLane: Hu(),
              gesture: null,
              action: r,
              hasEagerState: !1,
              eagerState: null,
              next: null
            }, fa(e)) {
            if (t) throw Error(o(479))
          } else null !== (t = Mr(e, n, r, 2)) && Jc(t, e, 2)
        }

        function fa(e) {
          var t = e.alternate;
          return e === Hs || null !== t && t === Hs
        }

        function pa(e, t) {
          $s = Ks = !0;
          var n = e.pending;
          null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
        }

        function ga(e, t, n) {
          if (0 !== (4194048 & n)) {
            var r = t.lanes;
            n |= r &= e.pendingLanes, t.lanes = n, je(e, n)
          }
        }
        var ma = {
          readContext: Li,
          use: ho,
          useCallback: Zs,
          useContext: Zs,
          useEffect: Zs,
          useImperativeHandle: Zs,
          useLayoutEffect: Zs,
          useInsertionEffect: Zs,
          useMemo: Zs,
          useReducer: Zs,
          useRef: Zs,
          useState: Zs,
          useDebugValue: Zs,
          useDeferredValue: Zs,
          useTransition: Zs,
          useSyncExternalStore: Zs,
          useId: Zs,
          useHostTransitionStatus: Zs,
          useFormState: Zs,
          useActionState: Zs,
          useOptimistic: Zs,
          useMemoCache: Zs,
          useCacheRefresh: Zs
        };
        ma.useEffectEvent = Zs;
        var ya = {
            readContext: Li,
            use: ho,
            useCallback: function(e, t) {
              return lo().memoizedState = [e, void 0 === t ? null : t], e
            },
            useContext: Li,
            useEffect: Wo,
            useImperativeHandle: function(e, t, n) {
              n = null !== n && void 0 !== n ? n.concat([e]) : null, Bo(4194308, 4, $o.bind(null, t, e), n)
            },
            useLayoutEffect: function(e, t) {
              return Bo(4194308, 4, e, t)
            },
            useInsertionEffect: function(e, t) {
              Bo(4, 2, e, t)
            },
            useMemo: function(e, t) {
              var n = lo();
              t = void 0 === t ? null : t;
              var r = e();
              if (Ys) {
                be(!0);
                try {
                  e()
                } finally {
                  be(!1)
                }
              }
              return n.memoizedState = [r, t], r
            },
            useReducer: function(e, t, n) {
              var r = lo();
              if (void 0 !== n) {
                var i = n(t);
                if (Ys) {
                  be(!0);
                  try {
                    n(t)
                  } finally {
                    be(!1)
                  }
                }
              } else i = t;
              return r.memoizedState = r.baseState = i, e = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: e,
                lastRenderedState: i
              }, r.queue = e, e = e.dispatch = ca.bind(null, Hs, e), [r.memoizedState, e]
            },
            useRef: function(e) {
              return e = {
                current: e
              }, lo().memoizedState = e
            },
            useState: function(e) {
              var t = (e = So(e)).queue,
                n = ua.bind(null, Hs, t);
              return t.dispatch = n, [e.memoizedState, n]
            },
            useDebugValue: Jo,
            useDeferredValue: function(e, t) {
              return Xo(lo(), e, t)
            },
            useTransition: function() {
              var e = So(!1);
              return e = ea.bind(null, Hs, e.queue, !0, !1), lo().memoizedState = e, [!1, e]
            },
            useSyncExternalStore: function(e, t, n) {
              var r = Hs,
                i = lo();
              if (di) {
                if (void 0 === n) throw Error(o(407));
                n = n()
              } else {
                if (n = t(), null === gc) throw Error(o(349));
                0 !== (127 & yc) || bo(r, t, n)
              }
              i.memoizedState = n;
              var s = {
                value: n,
                getSnapshot: t
              };
              return i.queue = s, Wo(_o.bind(null, r, s, e), [e]), r.flags |= 2048, zo(9, {
                destroy: void 0
              }, wo.bind(null, r, s, n, t), null), n
            },
            useId: function() {
              var e = lo(),
                t = gc.identifierPrefix;
              if (di) {
                var n = ri;
                t = "_" + t + "R_" + (n = (ni & ~(1 << 32 - we(ni) - 1)).toString(32) + n), 0 < (n = Js++) && (t += "H" + n.toString(32)), t += "_"
              } else t = "_" + t + "r_" + (n = Xs++).toString(32) + "_";
              return e.memoizedState = t
            },
            useHostTransitionStatus: sa,
            useFormState: Lo,
            useActionState: Lo,
            useOptimistic: function(e) {
              var t = lo();
              t.memoizedState = t.baseState = e;
              var n = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
              };
              return t.queue = n, t = da.bind(null, Hs, !0, n), n.dispatch = t, [e, t]
            },
            useMemoCache: fo,
            useCacheRefresh: function() {
              return lo().memoizedState = la.bind(null, Hs)
            },
            useEffectEvent: function(e) {
              var t = lo(),
                n = {
                  impl: e
                };
              return t.memoizedState = n,
                function() {
                  if (0 !== (2 & pc)) throw Error(o(440));
                  return n.impl.apply(void 0, arguments)
                }
            }
          },
          va = {
            readContext: Li,
            use: ho,
            useCallback: Go,
            useContext: Li,
            useEffect: Ho,
            useImperativeHandle: Yo,
            useInsertionEffect: qo,
            useLayoutEffect: Ko,
            useMemo: Qo,
            useReducer: go,
            useRef: Fo,
            useState: function() {
              return go(po)
            },
            useDebugValue: Jo,
            useDeferredValue: function(e, t) {
              return Zo(co(), Vs.memoizedState, e, t)
            },
            useTransition: function() {
              var e = go(po)[0],
                t = co().memoizedState;
              return ["boolean" === typeof e ? e : uo(e), t]
            },
            useSyncExternalStore: vo,
            useId: oa,
            useHostTransitionStatus: sa,
            useFormState: jo,
            useActionState: jo,
            useOptimistic: function(e, t) {
              return Eo(co(), 0, e, t)
            },
            useMemoCache: fo,
            useCacheRefresh: aa
          };
        va.useEffectEvent = Vo;
        var ba = {
          readContext: Li,
          use: ho,
          useCallback: Go,
          useContext: Li,
          useEffect: Ho,
          useImperativeHandle: Yo,
          useInsertionEffect: qo,
          useLayoutEffect: Ko,
          useMemo: Qo,
          useReducer: yo,
          useRef: Fo,
          useState: function() {
            return yo(po)
          },
          useDebugValue: Jo,
          useDeferredValue: function(e, t) {
            var n = co();
            return null === Vs ? Xo(n, e, t) : Zo(n, Vs.memoizedState, e, t)
          },
          useTransition: function() {
            var e = yo(po)[0],
              t = co().memoizedState;
            return ["boolean" === typeof e ? e : uo(e), t]
          },
          useSyncExternalStore: vo,
          useId: oa,
          useHostTransitionStatus: sa,
          useFormState: Do,
          useActionState: Do,
          useOptimistic: function(e, t) {
            var n = co();
            return null !== Vs ? Eo(n, 0, e, t) : (n.baseState = e, [e, n.queue.dispatch])
          },
          useMemoCache: fo,
          useCacheRefresh: aa
        };

        function wa(e, t, n, r) {
          n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : f({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
        }
        ba.useEffectEvent = Vo;
        var _a = {
          enqueueSetState: function(e, t, n) {
            e = e._reactInternals;
            var r = $c(),
              i = bs(r);
            i.payload = t, void 0 !== n && null !== n && (i.callback = n), null !== (t = ws(e, i, r)) && (Jc(t, e, r), _s(t, e, r))
          },
          enqueueReplaceState: function(e, t, n) {
            e = e._reactInternals;
            var r = $c(),
              i = bs(r);
            i.tag = 1, i.payload = t, void 0 !== n && null !== n && (i.callback = n), null !== (t = ws(e, i, r)) && (Jc(t, e, r), _s(t, e, r))
          },
          enqueueForceUpdate: function(e, t) {
            e = e._reactInternals;
            var n = $c(),
              r = bs(n);
            r.tag = 2, void 0 !== t && null !== t && (r.callback = t), null !== (t = ws(e, r, n)) && (Jc(t, e, n), _s(t, e, n))
          }
        };

        function xa(e, t, n, r, i, s, o) {
          return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, o) : !t.prototype || !t.prototype.isPureReactComponent || (!Zn(n, r) || !Zn(i, s))
        }

        function ka(e, t, n, r) {
          e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && _a.enqueueReplaceState(t, t.state, null)
        }

        function Sa(e, t) {
          var n = t;
          if ("ref" in t)
            for (var r in n = {}, t) "ref" !== r && (n[r] = t[r]);
          if (e = e.defaultProps)
            for (var i in n === t && (n = f({}, n)), e) void 0 === n[i] && (n[i] = e[i]);
          return n
        }

        function Ea(e) {
          Tr(e)
        }

        function Ta(e) {
          console.error(e)
        }

        function Ca(e) {
          Tr(e)
        }

        function Oa(e, t) {
          try {
            (0, e.onUncaughtError)(t.value, {
              componentStack: t.stack
            })
          } catch (n) {
            setTimeout(function() {
              throw n
            })
          }
        }

        function Pa(e, t, n) {
          try {
            (0, e.onCaughtError)(n.value, {
              componentStack: n.stack,
              errorBoundary: 1 === t.tag ? t.stateNode : null
            })
          } catch (r) {
            setTimeout(function() {
              throw r
            })
          }
        }

        function Aa(e, t, n) {
          return (n = bs(n)).tag = 3, n.payload = {
            element: null
          }, n.callback = function() {
            Oa(e, t)
          }, n
        }

        function Ra(e) {
          return (e = bs(e)).tag = 3, e
        }

        function Ma(e, t, n, r) {
          var i = n.type.getDerivedStateFromError;
          if ("function" === typeof i) {
            var s = r.value;
            e.payload = function() {
              return i(s)
            }, e.callback = function() {
              Pa(t, n, r)
            }
          }
          var o = n.stateNode;
          null !== o && "function" === typeof o.componentDidCatch && (e.callback = function() {
            Pa(t, n, r), "function" !== typeof i && (null === Dc ? Dc = new Set([this]) : Dc.add(this));
            var e = r.stack;
            this.componentDidCatch(r.value, {
              componentStack: null !== e ? e : ""
            })
          })
        }
        var La = Error(o(461)),
          ja = !1;

        function Na(e, t, n, r) {
          t.child = null === e ? gs(t, null, n, r) : ps(t, e.child, n, r)
        }

        function Ia(e, t, n, r, i) {
          n = n.render;
          var s = t.ref;
          if ("ref" in r) {
            var o = {};
            for (var a in r) "ref" !== a && (o[a] = r[a])
          } else o = r;
          return Mi(t), r = to(e, t, n, o, s, i), a = so(), null === e || ja ? (di && a && oi(t), t.flags |= 1, Na(e, t, r, i), t.child) : (oo(e, t, i), sl(e, t, i))
        }

        function Da(e, t, n, r, i) {
          if (null === e) {
            var s = n.type;
            return "function" !== typeof s || Fr(s) || void 0 !== s.defaultProps || null !== n.compare ? ((e = Wr(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, za(e, t, s, r, i))
          }
          if (s = e.child, !ol(e, i)) {
            var o = s.memoizedProps;
            if ((n = null !== (n = n.compare) ? n : Zn)(o, r) && e.ref === t.ref) return sl(e, t, i)
          }
          return t.flags |= 1, (e = Br(s, r)).ref = t.ref, e.return = t, t.child = e
        }

        function za(e, t, n, r, i) {
          if (null !== e) {
            var s = e.memoizedProps;
            if (Zn(s, r) && e.ref === t.ref) {
              if (ja = !1, t.pendingProps = r = s, !ol(e, i)) return t.lanes = e.lanes, sl(e, t, i);
              0 !== (131072 & e.flags) && (ja = !0)
            }
          }
          return qa(e, t, n, r, i)
        }

        function Fa(e, t, n, r) {
          var i = r.children,
            s = null !== e ? e.memoizedState : null;
          if (null === e && null === t.stateNode && (t.stateNode = {
              _visibility: 1,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null
            }), "hidden" === r.mode) {
            if (0 !== (128 & t.flags)) {
              if (s = null !== s ? s.baseLanes | n : n, null !== e) {
                for (r = t.child = e.child, i = 0; null !== r;) i = i | r.lanes | r.childLanes, r = r.sibling;
                r = i & ~s
              } else r = 0, t.child = null;
              return Ua(e, t, s, n, r)
            }
            if (0 === (536870912 & n)) return r = t.lanes = 536870912, Ua(e, t, null !== s ? s.baseLanes | n : n, n, r);
            t.memoizedState = {
              baseLanes: 0,
              cachePool: null
            }, null !== e && Gi(0, null !== s ? s.cachePool : null), null !== s ? As(t, s) : Rs(), Ds(t)
          } else null !== s ? (Gi(0, s.cachePool), As(t, s), zs(), t.memoizedState = null) : (null !== e && Gi(0, null), Rs(), zs());
          return Na(e, t, i, n), t.child
        }

        function Ba(e, t) {
          return null !== e && 22 === e.tag || null !== t.stateNode || (t.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          }), t.sibling
        }

        function Ua(e, t, n, r, i) {
          var s = Ji();
          return s = null === s ? null : {
            parent: Fi._currentValue,
            pool: s
          }, t.memoizedState = {
            baseLanes: n,
            cachePool: s
          }, null !== e && Gi(0, null), Rs(), Ds(t), null !== e && Ai(e, t, r, !0), t.childLanes = i, null
        }

        function Wa(e, t) {
          return (t = el({
            mode: t.mode,
            children: t.children
          }, e.mode)).ref = e.ref, e.child = t, t.return = e, t
        }

        function Ha(e, t, n) {
          return ps(t, e.child, null, n), (e = Wa(t, t.pendingProps)).flags |= 2, Fs(t), t.memoizedState = null, e
        }

        function Va(e, t) {
          var n = t.ref;
          if (null === n) null !== e && null !== e.ref && (t.flags |= 4194816);
          else {
            if ("function" !== typeof n && "object" !== typeof n) throw Error(o(284));
            null !== e && e.ref === n || (t.flags |= 4194816)
          }
        }

        function qa(e, t, n, r, i) {
          return Mi(t), n = to(e, t, n, r, void 0, i), r = so(), null === e || ja ? (di && r && oi(t), t.flags |= 1, Na(e, t, n, i), t.child) : (oo(e, t, i), sl(e, t, i))
        }

        function Ka(e, t, n, r, i, s) {
          return Mi(t), t.updateQueue = null, n = ro(t, r, n, i), no(e), r = so(), null === e || ja ? (di && r && oi(t), t.flags |= 1, Na(e, t, n, s), t.child) : (oo(e, t, s), sl(e, t, s))
        }

        function $a(e, t, n, r, i) {
          if (Mi(t), null === t.stateNode) {
            var s = Ir,
              o = n.contextType;
            "object" === typeof o && null !== o && (s = Li(o)), s = new n(r, s), t.memoizedState = null !== s.state && void 0 !== s.state ? s.state : null, s.updater = _a, t.stateNode = s, s._reactInternals = t, (s = t.stateNode).props = r, s.state = t.memoizedState, s.refs = {}, ys(t), o = n.contextType, s.context = "object" === typeof o && null !== o ? Li(o) : Ir, s.state = t.memoizedState, "function" === typeof(o = n.getDerivedStateFromProps) && (wa(t, n, o, r), s.state = t.memoizedState), "function" === typeof n.getDerivedStateFromProps || "function" === typeof s.getSnapshotBeforeUpdate || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || (o = s.state, "function" === typeof s.componentWillMount && s.componentWillMount(), "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount(), o !== s.state && _a.enqueueReplaceState(s, s.state, null), Es(t, r, s, i), Ss(), s.state = t.memoizedState), "function" === typeof s.componentDidMount && (t.flags |= 4194308), r = !0
          } else if (null === e) {
            s = t.stateNode;
            var a = t.memoizedProps,
              l = Sa(n, a);
            s.props = l;
            var c = s.context,
              u = n.contextType;
            o = Ir, "object" === typeof u && null !== u && (o = Li(u));
            var h = n.getDerivedStateFromProps;
            u = "function" === typeof h || "function" === typeof s.getSnapshotBeforeUpdate, a = t.pendingProps !== a, u || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a || c !== o) && ka(t, s, r, o), ms = !1;
            var d = t.memoizedState;
            s.state = d, Es(t, r, s, i), Ss(), c = t.memoizedState, a || d !== c || ms ? ("function" === typeof h && (wa(t, n, h, r), c = t.memoizedState), (l = ms || xa(t, n, l, r, d, c, o)) ? (u || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(), "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" === typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = c), s.props = r, s.state = c, s.context = o, r = l) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), r = !1)
          } else {
            s = t.stateNode, vs(e, t), u = Sa(n, o = t.memoizedProps), s.props = u, h = t.pendingProps, d = s.context, c = n.contextType, l = Ir, "object" === typeof c && null !== c && (l = Li(c)), (c = "function" === typeof(a = n.getDerivedStateFromProps) || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (o !== h || d !== l) && ka(t, s, r, l), ms = !1, d = t.memoizedState, s.state = d, Es(t, r, s, i), Ss();
            var f = t.memoizedState;
            o !== h || d !== f || ms || null !== e && null !== e.dependencies && Ri(e.dependencies) ? ("function" === typeof a && (wa(t, n, a, r), f = t.memoizedState), (u = ms || xa(t, n, u, r, d, f, l) || null !== e && null !== e.dependencies && Ri(e.dependencies)) ? (c || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, f, l), "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, f, l)), "function" === typeof s.componentDidUpdate && (t.flags |= 4), "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof s.componentDidUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), s.props = r, s.state = f, s.context = l, r = u) : ("function" !== typeof s.componentDidUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1)
          }
          return s = r, Va(e, t), r = 0 !== (128 & t.flags), s || r ? (s = t.stateNode, n = r && "function" !== typeof n.getDerivedStateFromError ? null : s.render(), t.flags |= 1, null !== e && r ? (t.child = ps(t, e.child, null, i), t.child = ps(t, null, n, i)) : Na(e, t, n, i), t.memoizedState = s.state, e = t.child) : e = sl(e, t, i), e
        }

        function Ya(e, t, n, r) {
          return wi(), t.flags |= 256, Na(e, t, n, r), t.child
        }
        var Ja = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        };

        function Ga(e) {
          return {
            baseLanes: e,
            cachePool: Qi()
          }
        }

        function Qa(e, t, n) {
          return e = null !== e ? e.childLanes & ~n : 0, t && (e |= Oc), e
        }

        function Xa(e, t, n) {
          var r, i = t.pendingProps,
            s = !1,
            a = 0 !== (128 & t.flags);
          if ((r = a) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & Bs.current)), r && (s = !0, t.flags &= -129), r = 0 !== (32 & t.flags), t.flags &= -33, null === e) {
            if (di) {
              if (s ? Ns(t) : zs(), (e = hi) ? null !== (e = null !== (e = Rh(e, pi)) && "&" !== e.data ? e : null) && (t.memoizedState = {
                  dehydrated: e,
                  treeContext: null !== ti ? {
                    id: ni,
                    overflow: ri
                  } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, (n = qr(e)).return = t, t.child = n, ui = t, hi = null) : e = null, null === e) throw mi(t);
              return Lh(e) ? t.lanes = 32 : t.lanes = 536870912, null
            }
            var l = i.children;
            return i = i.fallback, s ? (zs(), l = el({
              mode: "hidden",
              children: l
            }, s = t.mode), i = Hr(i, s, n, null), l.return = t, i.return = t, l.sibling = i, t.child = l, (i = t.child).memoizedState = Ga(n), i.childLanes = Qa(e, r, n), t.memoizedState = Ja, Ba(null, i)) : (Ns(t), Za(t, l))
          }
          var c = e.memoizedState;
          if (null !== c && null !== (l = c.dehydrated)) {
            if (a) 256 & t.flags ? (Ns(t), t.flags &= -257, t = tl(e, t, n)) : null !== t.memoizedState ? (zs(), t.child = e.child, t.flags |= 128, t = null) : (zs(), l = i.fallback, s = t.mode, i = el({
              mode: "visible",
              children: i.children
            }, s), (l = Hr(l, s, n, null)).flags |= 2, i.return = t, l.return = t, i.sibling = l, t.child = i, ps(t, e.child, null, n), (i = t.child).memoizedState = Ga(n), i.childLanes = Qa(e, r, n), t.memoizedState = Ja, t = Ba(null, i));
            else if (Ns(t), Lh(l)) {
              if (r = l.nextSibling && l.nextSibling.dataset) var u = r.dgst;
              r = u, (i = Error(o(419))).stack = "", i.digest = r, xi({
                value: i,
                source: null,
                stack: null
              }), t = tl(e, t, n)
            } else if (ja || Ai(e, t, n, !1), r = 0 !== (n & e.childLanes), ja || r) {
              if (null !== (r = gc) && (0 !== (i = Ne(r, n)) && i !== c.retryLane)) throw c.retryLane = i, Lr(e, i), Jc(r, e, i), La;
              Mh(l) || au(), t = tl(e, t, n)
            } else Mh(l) ? (t.flags |= 192, t.child = e.child, t = null) : (e = c.treeContext, hi = jh(l.nextSibling), ui = t, di = !0, fi = null, pi = !1, null !== e && ci(t, e), (t = Za(t, i.children)).flags |= 4096);
            return t
          }
          return s ? (zs(), l = i.fallback, s = t.mode, u = (c = e.child).sibling, (i = Br(c, {
            mode: "hidden",
            children: i.children
          })).subtreeFlags = 65011712 & c.subtreeFlags, null !== u ? l = Br(u, l) : (l = Hr(l, s, n, null)).flags |= 2, l.return = t, i.return = t, i.sibling = l, t.child = i, Ba(null, i), i = t.child, null === (l = e.child.memoizedState) ? l = Ga(n) : (null !== (s = l.cachePool) ? (c = Fi._currentValue, s = s.parent !== c ? {
            parent: c,
            pool: c
          } : s) : s = Qi(), l = {
            baseLanes: l.baseLanes | n,
            cachePool: s
          }), i.memoizedState = l, i.childLanes = Qa(e, r, n), t.memoizedState = Ja, Ba(e.child, i)) : (Ns(t), e = (n = e.child).sibling, (n = Br(n, {
            mode: "visible",
            children: i.children
          })).return = t, n.sibling = null, null !== e && (null === (r = t.deletions) ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n)
        }

        function Za(e, t) {
          return (t = el({
            mode: "visible",
            children: t
          }, e.mode)).return = e, e.child = t
        }

        function el(e, t) {
          return (e = zr(22, e, null, t)).lanes = 0, e
        }

        function tl(e, t, n) {
          return ps(t, e.child, null, n), (e = Za(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
        }

        function nl(e, t, n) {
          e.lanes |= t;
          var r = e.alternate;
          null !== r && (r.lanes |= t), Oi(e.return, t, n)
        }

        function rl(e, t, n, r, i, s) {
          var o = e.memoizedState;
          null === o ? e.memoizedState = {
            isBackwards: t,
            rendering: null,
            renderingStartTime: 0,
            last: r,
            tail: n,
            tailMode: i,
            treeForkCount: s
          } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i, o.treeForkCount = s)
        }

        function il(e, t, n) {
          var r = t.pendingProps,
            i = r.revealOrder,
            s = r.tail;
          r = r.children;
          var o = Bs.current,
            a = 0 !== (2 & o);
          if (a ? (o = 1 & o | 2, t.flags |= 128) : o &= 1, U(Bs, o), Na(e, t, r, n), r = di ? Xr : 0, !a && null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
            if (13 === e.tag) null !== e.memoizedState && nl(e, n, t);
            else if (19 === e.tag) nl(e, n, t);
            else if (null !== e.child) {
              e.child.return = e, e = e.child;
              continue
            }
            if (e === t) break e;
            for (; null === e.sibling;) {
              if (null === e.return || e.return === t) break e;
              e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
          }
          switch (i) {
            case "forwards":
              for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === Us(e) && (i = n), n = n.sibling;
              null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), rl(t, !1, i, n, s, r);
              break;
            case "backwards":
            case "unstable_legacy-backwards":
              for (n = null, i = t.child, t.child = null; null !== i;) {
                if (null !== (e = i.alternate) && null === Us(e)) {
                  t.child = i;
                  break
                }
                e = i.sibling, i.sibling = n, n = i, i = e
              }
              rl(t, !0, n, null, s, r);
              break;
            case "together":
              rl(t, !1, null, null, void 0, r);
              break;
            default:
              t.memoizedState = null
          }
          return t.child
        }

        function sl(e, t, n) {
          if (null !== e && (t.dependencies = e.dependencies), Ec |= t.lanes, 0 === (n & t.childLanes)) {
            if (null === e) return null;
            if (Ai(e, t, n, !1), 0 === (n & t.childLanes)) return null
          }
          if (null !== e && t.child !== e.child) throw Error(o(153));
          if (null !== t.child) {
            for (n = Br(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Br(e, e.pendingProps)).return = t;
            n.sibling = null
          }
          return t.child
        }

        function ol(e, t) {
          return 0 !== (e.lanes & t) || !(null === (e = e.dependencies) || !Ri(e))
        }

        function al(e, t, n) {
          if (null !== e)
            if (e.memoizedProps !== t.pendingProps) ja = !0;
            else {
              if (!ol(e, n) && 0 === (128 & t.flags)) return ja = !1,
                function(e, t, n) {
                  switch (t.tag) {
                    case 3:
                      Y(t, t.stateNode.containerInfo), Ti(0, Fi, e.memoizedState.cache), wi();
                      break;
                    case 27:
                    case 5:
                      G(t);
                      break;
                    case 4:
                      Y(t, t.stateNode.containerInfo);
                      break;
                    case 10:
                      Ti(0, t.type, t.memoizedProps.value);
                      break;
                    case 31:
                      if (null !== t.memoizedState) return t.flags |= 128, Is(t), null;
                      break;
                    case 13:
                      var r = t.memoizedState;
                      if (null !== r) return null !== r.dehydrated ? (Ns(t), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Xa(e, t, n) : (Ns(t), null !== (e = sl(e, t, n)) ? e.sibling : null);
                      Ns(t);
                      break;
                    case 19:
                      var i = 0 !== (128 & e.flags);
                      if ((r = 0 !== (n & t.childLanes)) || (Ai(e, t, n, !1), r = 0 !== (n & t.childLanes)), i) {
                        if (r) return il(e, t, n);
                        t.flags |= 128
                      }
                      if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), U(Bs, Bs.current), r) break;
                      return null;
                    case 22:
                      return t.lanes = 0, Fa(e, t, n, t.pendingProps);
                    case 24:
                      Ti(0, Fi, e.memoizedState.cache)
                  }
                  return sl(e, t, n)
                }(e, t, n);
              ja = 0 !== (131072 & e.flags)
            }
          else ja = !1, di && 0 !== (1048576 & t.flags) && si(t, Xr, t.index);
          switch (t.lanes = 0, t.tag) {
            case 16:
              e: {
                var r = t.pendingProps;
                if (e = is(t.elementType), t.type = e, "function" !== typeof e) {
                  if (void 0 !== e && null !== e) {
                    var i = e.$$typeof;
                    if (i === x) {
                      t.tag = 11, t = Ia(null, t, e, r, n);
                      break e
                    }
                    if (i === E) {
                      t.tag = 14, t = Da(null, t, e, r, n);
                      break e
                    }
                  }
                  throw t = M(e) || e, Error(o(306, t, ""))
                }
                Fr(e) ? (r = Sa(e, r), t.tag = 1, t = $a(null, t, e, r, n)) : (t.tag = 0, t = qa(null, t, e, r, n))
              }
              return t;
            case 0:
              return qa(e, t, t.type, t.pendingProps, n);
            case 1:
              return $a(e, t, r = t.type, i = Sa(r, t.pendingProps), n);
            case 3:
              e: {
                if (Y(t, t.stateNode.containerInfo), null === e) throw Error(o(387));r = t.pendingProps;
                var s = t.memoizedState;i = s.element,
                vs(e, t),
                Es(t, r, null, n);
                var a = t.memoizedState;
                if (r = a.cache, Ti(0, Fi, r), r !== s.cache && Pi(t, [Fi], n, !0), Ss(), r = a.element, s.isDehydrated) {
                  if (s = {
                      element: r,
                      isDehydrated: !1,
                      cache: a.cache
                    }, t.updateQueue.baseState = s, t.memoizedState = s, 256 & t.flags) {
                    t = Ya(e, t, r, n);
                    break e
                  }
                  if (r !== i) {
                    xi(i = Yr(Error(o(424)), t)), t = Ya(e, t, r, n);
                    break e
                  }
                  if (9 === (e = t.stateNode.containerInfo).nodeType) e = e.body;
                  else e = "HTML" === e.nodeName ? e.ownerDocument.body : e;
                  for (hi = jh(e.firstChild), ui = t, di = !0, fi = null, pi = !0, n = gs(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                } else {
                  if (wi(), r === i) {
                    t = sl(e, t, n);
                    break e
                  }
                  Na(e, t, r, n)
                }
                t = t.child
              }
              return t;
            case 26:
              return Va(e, t), null === e ? (n = Kh(t.type, null, t.pendingProps, null)) ? t.memoizedState = n : di || (n = t.type, e = t.pendingProps, (r = yh(K.current).createElement(n))[Ue] = t, r[We] = e, fh(r, n, e), et(r), t.stateNode = r) : t.memoizedState = Kh(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null;
            case 27:
              return G(t), null === e && di && (r = t.stateNode = zh(t.type, t.pendingProps, K.current), ui = t, pi = !0, i = hi, Ch(t.type) ? (Nh = i, hi = jh(r.firstChild)) : hi = i), Na(e, t, t.pendingProps.children, n), Va(e, t), null === e && (t.flags |= 4194304), t.child;
            case 5:
              return null === e && di && ((i = r = hi) && (null !== (r = function(e, t, n, r) {
                for (; 1 === e.nodeType;) {
                  var i = n;
                  if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
                    if (!r && ("INPUT" !== e.nodeName || "hidden" !== e.type)) break
                  } else if (r) {
                    if (!e[Ye]) switch (t) {
                      case "meta":
                        if (!e.hasAttribute("itemprop")) break;
                        return e;
                      case "link":
                        if ("stylesheet" === (s = e.getAttribute("rel")) && e.hasAttribute("data-precedence")) break;
                        if (s !== i.rel || e.getAttribute("href") !== (null == i.href || "" === i.href ? null : i.href) || e.getAttribute("crossorigin") !== (null == i.crossOrigin ? null : i.crossOrigin) || e.getAttribute("title") !== (null == i.title ? null : i.title)) break;
                        return e;
                      case "style":
                        if (e.hasAttribute("data-precedence")) break;
                        return e;
                      case "script":
                        if (((s = e.getAttribute("src")) !== (null == i.src ? null : i.src) || e.getAttribute("type") !== (null == i.type ? null : i.type) || e.getAttribute("crossorigin") !== (null == i.crossOrigin ? null : i.crossOrigin)) && s && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break;
                        return e;
                      default:
                        return e
                    }
                  } else {
                    if ("input" !== t || "hidden" !== e.type) return e;
                    var s = null == i.name ? null : "" + i.name;
                    if ("hidden" === i.type && e.getAttribute("name") === s) return e
                  }
                  if (null === (e = jh(e.nextSibling))) break
                }
                return null
              }(r, t.type, t.pendingProps, pi)) ? (t.stateNode = r, ui = t, hi = jh(r.firstChild), pi = !1, i = !0) : i = !1), i || mi(t)), G(t), i = t.type, s = t.pendingProps, a = null !== e ? e.memoizedProps : null, r = s.children, wh(i, s) ? r = null : null !== a && wh(i, a) && (t.flags |= 32), null !== t.memoizedState && (i = to(e, t, io, null, null, n), hd._currentValue = i), Va(e, t), Na(e, t, r, n), t.child;
            case 6:
              return null === e && di && ((e = n = hi) && (null !== (n = function(e, t, n) {
                if ("" === t) return null;
                for (; 3 !== e.nodeType;) {
                  if ((1 !== e.nodeType || "INPUT" !== e.nodeName || "hidden" !== e.type) && !n) return null;
                  if (null === (e = jh(e.nextSibling))) return null
                }
                return e
              }(n, t.pendingProps, pi)) ? (t.stateNode = n, ui = t, hi = null, e = !0) : e = !1), e || mi(t)), null;
            case 13:
              return Xa(e, t, n);
            case 4:
              return Y(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = ps(t, null, r, n) : Na(e, t, r, n), t.child;
            case 11:
              return Ia(e, t, t.type, t.pendingProps, n);
            case 7:
              return Na(e, t, t.pendingProps, n), t.child;
            case 8:
            case 12:
              return Na(e, t, t.pendingProps.children, n), t.child;
            case 10:
              return r = t.pendingProps, Ti(0, t.type, r.value), Na(e, t, r.children, n), t.child;
            case 9:
              return i = t.type._context, r = t.pendingProps.children, Mi(t), r = r(i = Li(i)), t.flags |= 1, Na(e, t, r, n), t.child;
            case 14:
              return Da(e, t, t.type, t.pendingProps, n);
            case 15:
              return za(e, t, t.type, t.pendingProps, n);
            case 19:
              return il(e, t, n);
            case 31:
              return function(e, t, n) {
                var r = t.pendingProps,
                  i = 0 !== (128 & t.flags);
                if (t.flags &= -129, null === e) {
                  if (di) {
                    if ("hidden" === r.mode) return e = Wa(t, r), t.lanes = 536870912, Ba(null, e);
                    if (Is(t), (e = hi) ? null !== (e = null !== (e = Rh(e, pi)) && "&" === e.data ? e : null) && (t.memoizedState = {
                        dehydrated: e,
                        treeContext: null !== ti ? {
                          id: ni,
                          overflow: ri
                        } : null,
                        retryLane: 536870912,
                        hydrationErrors: null
                      }, (n = qr(e)).return = t, t.child = n, ui = t, hi = null) : e = null, null === e) throw mi(t);
                    return t.lanes = 536870912, null
                  }
                  return Wa(t, r)
                }
                var s = e.memoizedState;
                if (null !== s) {
                  var a = s.dehydrated;
                  if (Is(t), i)
                    if (256 & t.flags) t.flags &= -257, t = Ha(e, t, n);
                    else {
                      if (null === t.memoizedState) throw Error(o(558));
                      t.child = e.child, t.flags |= 128, t = null
                    }
                  else if (ja || Ai(e, t, n, !1), i = 0 !== (n & e.childLanes), ja || i) {
                    if (null !== (r = gc) && 0 !== (a = Ne(r, n)) && a !== s.retryLane) throw s.retryLane = a, Lr(e, a), Jc(r, e, a), La;
                    au(), t = Ha(e, t, n)
                  } else e = s.treeContext, hi = jh(a.nextSibling), ui = t, di = !0, fi = null, pi = !1, null !== e && ci(t, e), (t = Wa(t, r)).flags |= 4096;
                  return t
                }
                return (e = Br(e.child, {
                  mode: r.mode,
                  children: r.children
                })).ref = t.ref, t.child = e, e.return = t, e
              }(e, t, n);
            case 22:
              return Fa(e, t, n, t.pendingProps);
            case 24:
              return Mi(t), r = Li(Fi), null === e ? (null === (i = Ji()) && (i = gc, s = Bi(), i.pooledCache = s, s.refCount++, null !== s && (i.pooledCacheLanes |= n), i = s), t.memoizedState = {
                parent: r,
                cache: i
              }, ys(t), Ti(0, Fi, i)) : (0 !== (e.lanes & n) && (vs(e, t), Es(t, null, null, n), Ss()), i = e.memoizedState, s = t.memoizedState, i.parent !== r ? (i = {
                parent: r,
                cache: r
              }, t.memoizedState = i, 0 === t.lanes && (t.memoizedState = t.updateQueue.baseState = i), Ti(0, Fi, r)) : (r = s.cache, Ti(0, Fi, r), r !== i.cache && Pi(t, [Fi], n, !0))), Na(e, t, t.pendingProps.children, n), t.child;
            case 29:
              throw t.pendingProps
          }
          throw Error(o(156, t.tag))
        }

        function ll(e) {
          e.flags |= 4
        }

        function cl(e, t, n, r, i) {
          if ((t = 0 !== (32 & e.mode)) && (t = !1), t) {
            if (e.flags |= 16777216, (335544128 & i) === i)
              if (e.stateNode.complete) e.flags |= 8192;
              else {
                if (!iu()) throw ss = ts, Zi;
                e.flags |= 8192
              }
          } else e.flags &= -16777217
        }

        function ul(e, t) {
          if ("stylesheet" !== t.type || 0 !== (4 & t.state.loading)) e.flags &= -16777217;
          else if (e.flags |= 16777216, !sd(t)) {
            if (!iu()) throw ss = ts, Zi;
            e.flags |= 8192
          }
        }

        function hl(e, t) {
          null !== t && (e.flags |= 4), 16384 & e.flags && (t = 22 !== e.tag ? Ae() : 536870912, e.lanes |= t, Pc |= t)
        }

        function dl(e, t) {
          if (!di) switch (e.tailMode) {
            case "hidden":
              t = e.tail;
              for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
              null === n ? e.tail = null : n.sibling = null;
              break;
            case "collapsed":
              n = e.tail;
              for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
              null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
          }
        }

        function fl(e) {
          var t = null !== e.alternate && e.alternate.child === e.child,
            n = 0,
            r = 0;
          if (t)
            for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 65011712 & i.subtreeFlags, r |= 65011712 & i.flags, i.return = e, i = i.sibling;
          else
            for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
          return e.subtreeFlags |= r, e.childLanes = n, t
        }

        function pl(e, t, n) {
          var r = t.pendingProps;
          switch (li(t), t.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
            case 1:
              return fl(t), null;
            case 3:
              return n = t.stateNode, r = null, null !== e && (r = e.memoizedState.cache), t.memoizedState.cache !== r && (t.flags |= 2048), Ci(Fi), J(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), null !== e && null !== e.child || (bi(t) ? ll(t) : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, _i())), fl(t), null;
            case 26:
              var i = t.type,
                s = t.memoizedState;
              return null === e ? (ll(t), null !== s ? (fl(t), ul(t, s)) : (fl(t), cl(t, i, 0, 0, n))) : s ? s !== e.memoizedState ? (ll(t), fl(t), ul(t, s)) : (fl(t), t.flags &= -16777217) : ((e = e.memoizedProps) !== r && ll(t), fl(t), cl(t, i, 0, 0, n)), null;
            case 27:
              if (Q(t), n = K.current, i = t.type, null !== e && null != t.stateNode) e.memoizedProps !== r && ll(t);
              else {
                if (!r) {
                  if (null === t.stateNode) throw Error(o(166));
                  return fl(t), null
                }
                e = V.current, bi(t) ? yi(t) : (e = zh(i, r, n), t.stateNode = e, ll(t))
              }
              return fl(t), null;
            case 5:
              if (Q(t), i = t.type, null !== e && null != t.stateNode) e.memoizedProps !== r && ll(t);
              else {
                if (!r) {
                  if (null === t.stateNode) throw Error(o(166));
                  return fl(t), null
                }
                if (s = V.current, bi(t)) yi(t);
                else {
                  var a = yh(K.current);
                  switch (s) {
                    case 1:
                      s = a.createElementNS("http://www.w3.org/2000/svg", i);
                      break;
                    case 2:
                      s = a.createElementNS("http://www.w3.org/1998/Math/MathML", i);
                      break;
                    default:
                      switch (i) {
                        case "svg":
                          s = a.createElementNS("http://www.w3.org/2000/svg", i);
                          break;
                        case "math":
                          s = a.createElementNS("http://www.w3.org/1998/Math/MathML", i);
                          break;
                        case "script":
                          (s = a.createElement("div")).innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
                          break;
                        case "select":
                          s = "string" === typeof r.is ? a.createElement("select", {
                            is: r.is
                          }) : a.createElement("select"), r.multiple ? s.multiple = !0 : r.size && (s.size = r.size);
                          break;
                        default:
                          s = "string" === typeof r.is ? a.createElement(i, {
                            is: r.is
                          }) : a.createElement(i)
                      }
                  }
                  s[Ue] = t, s[We] = r;
                  e: for (a = t.child; null !== a;) {
                    if (5 === a.tag || 6 === a.tag) s.appendChild(a.stateNode);
                    else if (4 !== a.tag && 27 !== a.tag && null !== a.child) {
                      a.child.return = a, a = a.child;
                      continue
                    }
                    if (a === t) break e;
                    for (; null === a.sibling;) {
                      if (null === a.return || a.return === t) break e;
                      a = a.return
                    }
                    a.sibling.return = a.return, a = a.sibling
                  }
                  t.stateNode = s;
                  e: switch (fh(s, i, r), i) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      r = !!r.autoFocus;
                      break e;
                    case "img":
                      r = !0;
                      break e;
                    default:
                      r = !1
                  }
                  r && ll(t)
                }
              }
              return fl(t), cl(t, t.type, null === e || e.memoizedProps, t.pendingProps, n), null;
            case 6:
              if (e && null != t.stateNode) e.memoizedProps !== r && ll(t);
              else {
                if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
                if (e = K.current, bi(t)) {
                  if (e = t.stateNode, n = t.memoizedProps, r = null, null !== (i = ui)) switch (i.tag) {
                    case 27:
                    case 5:
                      r = i.memoizedProps
                  }
                  e[Ue] = t, (e = !!(e.nodeValue === n || null !== r && !0 === r.suppressHydrationWarning || uh(e.nodeValue, n))) || mi(t, !0)
                } else(e = yh(e).createTextNode(r))[Ue] = t, t.stateNode = e
              }
              return fl(t), null;
            case 31:
              if (n = t.memoizedState, null === e || null !== e.memoizedState) {
                if (r = bi(t), null !== n) {
                  if (null === e) {
                    if (!r) throw Error(o(318));
                    if (!(e = null !== (e = t.memoizedState) ? e.dehydrated : null)) throw Error(o(557));
                    e[Ue] = t
                  } else wi(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                  fl(t), e = !1
                } else n = _i(), null !== e && null !== e.memoizedState && (e.memoizedState.hydrationErrors = n), e = !0;
                if (!e) return 256 & t.flags ? (Fs(t), t) : (Fs(t), null);
                if (0 !== (128 & t.flags)) throw Error(o(558))
              }
              return fl(t), null;
            case 13:
              if (r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                if (i = bi(t), null !== r && null !== r.dehydrated) {
                  if (null === e) {
                    if (!i) throw Error(o(318));
                    if (!(i = null !== (i = t.memoizedState) ? i.dehydrated : null)) throw Error(o(317));
                    i[Ue] = t
                  } else wi(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                  fl(t), i = !1
                } else i = _i(), null !== e && null !== e.memoizedState && (e.memoizedState.hydrationErrors = i), i = !0;
                if (!i) return 256 & t.flags ? (Fs(t), t) : (Fs(t), null)
              }
              return Fs(t), 0 !== (128 & t.flags) ? (t.lanes = n, t) : (n = null !== r, e = null !== e && null !== e.memoizedState, n && (i = null, null !== (r = t.child).alternate && null !== r.alternate.memoizedState && null !== r.alternate.memoizedState.cachePool && (i = r.alternate.memoizedState.cachePool.pool), s = null, null !== r.memoizedState && null !== r.memoizedState.cachePool && (s = r.memoizedState.cachePool.pool), s !== i && (r.flags |= 2048)), n !== e && n && (t.child.flags |= 8192), hl(t, t.updateQueue), fl(t), null);
            case 4:
              return J(), null === e && eh(t.stateNode.containerInfo), fl(t), null;
            case 10:
              return Ci(t.type), fl(t), null;
            case 19:
              if (B(Bs), null === (r = t.memoizedState)) return fl(t), null;
              if (i = 0 !== (128 & t.flags), null === (s = r.rendering))
                if (i) dl(r, !1);
                else {
                  if (0 !== Sc || null !== e && 0 !== (128 & e.flags))
                    for (e = t.child; null !== e;) {
                      if (null !== (s = Us(e))) {
                        for (t.flags |= 128, dl(r, !1), e = s.updateQueue, t.updateQueue = e, hl(t, e), t.subtreeFlags = 0, e = n, n = t.child; null !== n;) Ur(n, e), n = n.sibling;
                        return U(Bs, 1 & Bs.current | 2), di && ii(t, r.treeForkCount), t.child
                      }
                      e = e.sibling
                    }
                  null !== r.tail && le() > Nc && (t.flags |= 128, i = !0, dl(r, !1), t.lanes = 4194304)
                }
              else {
                if (!i)
                  if (null !== (e = Us(s))) {
                    if (t.flags |= 128, i = !0, e = e.updateQueue, t.updateQueue = e, hl(t, e), dl(r, !0), null === r.tail && "hidden" === r.tailMode && !s.alternate && !di) return fl(t), null
                  } else 2 * le() - r.renderingStartTime > Nc && 536870912 !== n && (t.flags |= 128, i = !0, dl(r, !1), t.lanes = 4194304);
                r.isBackwards ? (s.sibling = t.child, t.child = s) : (null !== (e = r.last) ? e.sibling = s : t.child = s, r.last = s)
              }
              return null !== r.tail ? (e = r.tail, r.rendering = e, r.tail = e.sibling, r.renderingStartTime = le(), e.sibling = null, n = Bs.current, U(Bs, i ? 1 & n | 2 : 1 & n), di && ii(t, r.treeForkCount), e) : (fl(t), null);
            case 22:
            case 23:
              return Fs(t), Ms(), r = null !== t.memoizedState, null !== e ? null !== e.memoizedState !== r && (t.flags |= 8192) : r && (t.flags |= 8192), r ? 0 !== (536870912 & n) && 0 === (128 & t.flags) && (fl(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : fl(t), null !== (n = t.updateQueue) && hl(t, n.retryQueue), n = null, null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (n = e.memoizedState.cachePool.pool), r = null, null !== t.memoizedState && null !== t.memoizedState.cachePool && (r = t.memoizedState.cachePool.pool), r !== n && (t.flags |= 2048), null !== e && B(Yi), null;
            case 24:
              return n = null, null !== e && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), Ci(Fi), fl(t), null;
            case 25:
            case 30:
              return null
          }
          throw Error(o(156, t.tag))
        }

        function gl(e, t) {
          switch (li(t), t.tag) {
            case 1:
              return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
            case 3:
              return Ci(Fi), J(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
            case 26:
            case 27:
            case 5:
              return Q(t), null;
            case 31:
              if (null !== t.memoizedState) {
                if (Fs(t), null === t.alternate) throw Error(o(340));
                wi()
              }
              return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
            case 13:
              if (Fs(t), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                if (null === t.alternate) throw Error(o(340));
                wi()
              }
              return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
            case 19:
              return B(Bs), null;
            case 4:
              return J(), null;
            case 10:
              return Ci(t.type), null;
            case 22:
            case 23:
              return Fs(t), Ms(), null !== e && B(Yi), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
            case 24:
              return Ci(Fi), null;
            default:
              return null
          }
        }

        function ml(e, t) {
          switch (li(t), t.tag) {
            case 3:
              Ci(Fi), J();
              break;
            case 26:
            case 27:
            case 5:
              Q(t);
              break;
            case 4:
              J();
              break;
            case 31:
              null !== t.memoizedState && Fs(t);
              break;
            case 13:
              Fs(t);
              break;
            case 19:
              B(Bs);
              break;
            case 10:
              Ci(t.type);
              break;
            case 22:
            case 23:
              Fs(t), Ms(), null !== e && B(Yi);
              break;
            case 24:
              Ci(Fi)
          }
        }

        function yl(e, t) {
          try {
            var n = t.updateQueue,
              r = null !== n ? n.lastEffect : null;
            if (null !== r) {
              var i = r.next;
              n = i;
              do {
                if ((n.tag & e) === e) {
                  r = void 0;
                  var s = n.create,
                    o = n.inst;
                  r = s(), o.destroy = r
                }
                n = n.next
              } while (n !== i)
            }
          } catch (a) {
            Su(t, t.return, a)
          }
        }

        function vl(e, t, n) {
          try {
            var r = t.updateQueue,
              i = null !== r ? r.lastEffect : null;
            if (null !== i) {
              var s = i.next;
              r = s;
              do {
                if ((r.tag & e) === e) {
                  var o = r.inst,
                    a = o.destroy;
                  if (void 0 !== a) {
                    o.destroy = void 0, i = t;
                    var l = n,
                      c = a;
                    try {
                      c()
                    } catch (u) {
                      Su(i, l, u)
                    }
                  }
                }
                r = r.next
              } while (r !== s)
            }
          } catch (u) {
            Su(t, t.return, u)
          }
        }

        function bl(e) {
          var t = e.updateQueue;
          if (null !== t) {
            var n = e.stateNode;
            try {
              Cs(t, n)
            } catch (r) {
              Su(e, e.return, r)
            }
          }
        }

        function wl(e, t, n) {
          n.props = Sa(e.type, e.memoizedProps), n.state = e.memoizedState;
          try {
            n.componentWillUnmount()
          } catch (r) {
            Su(e, t, r)
          }
        }

        function _l(e, t) {
          try {
            var n = e.ref;
            if (null !== n) {
              switch (e.tag) {
                case 26:
                case 27:
                case 5:
                  var r = e.stateNode;
                  break;
                default:
                  r = e.stateNode
              }
              "function" === typeof n ? e.refCleanup = n(r) : n.current = r
            }
          } catch (i) {
            Su(e, t, i)
          }
        }

        function xl(e, t) {
          var n = e.ref,
            r = e.refCleanup;
          if (null !== n)
            if ("function" === typeof r) try {
              r()
            } catch (i) {
              Su(e, t, i)
            } finally {
              e.refCleanup = null, null != (e = e.alternate) && (e.refCleanup = null)
            } else if ("function" === typeof n) try {
              n(null)
            } catch (s) {
              Su(e, t, s)
            } else n.current = null
        }

        function kl(e) {
          var t = e.type,
            n = e.memoizedProps,
            r = e.stateNode;
          try {
            e: switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n.autoFocus && r.focus();
                break e;
              case "img":
                n.src ? r.src = n.src : n.srcSet && (r.srcset = n.srcSet)
            }
          }
          catch (i) {
            Su(e, e.return, i)
          }
        }

        function Sl(e, t, n) {
          try {
            var r = e.stateNode;
            ! function(e, t, n, r) {
              switch (t) {
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                  break;
                case "input":
                  var i = null,
                    s = null,
                    a = null,
                    l = null,
                    c = null,
                    u = null,
                    h = null;
                  for (p in n) {
                    var d = n[p];
                    if (n.hasOwnProperty(p) && null != d) switch (p) {
                      case "checked":
                      case "value":
                        break;
                      case "defaultValue":
                        c = d;
                      default:
                        r.hasOwnProperty(p) || hh(e, t, p, null, r, d)
                    }
                  }
                  for (var f in r) {
                    var p = r[f];
                    if (d = n[f], r.hasOwnProperty(f) && (null != p || null != d)) switch (f) {
                      case "type":
                        s = p;
                        break;
                      case "name":
                        i = p;
                        break;
                      case "checked":
                        u = p;
                        break;
                      case "defaultChecked":
                        h = p;
                        break;
                      case "value":
                        a = p;
                        break;
                      case "defaultValue":
                        l = p;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != p) throw Error(o(137, t));
                        break;
                      default:
                        p !== d && hh(e, t, f, p, r, d)
                    }
                  }
                  return void vt(e, a, l, c, u, h, s, i);
                case "select":
                  for (s in p = a = l = f = null, n)
                    if (c = n[s], n.hasOwnProperty(s) && null != c) switch (s) {
                      case "value":
                        break;
                      case "multiple":
                        p = c;
                      default:
                        r.hasOwnProperty(s) || hh(e, t, s, null, r, c)
                    }
                  for (i in r)
                    if (s = r[i], c = n[i], r.hasOwnProperty(i) && (null != s || null != c)) switch (i) {
                      case "value":
                        f = s;
                        break;
                      case "defaultValue":
                        l = s;
                        break;
                      case "multiple":
                        a = s;
                      default:
                        s !== c && hh(e, t, i, s, r, c)
                    }
                  return t = l, n = a, r = p, void(null != f ? _t(e, !!n, f, !1) : !!r !== !!n && (null != t ? _t(e, !!n, t, !0) : _t(e, !!n, n ? [] : "", !1)));
                case "textarea":
                  for (l in p = f = null, n)
                    if (i = n[l], n.hasOwnProperty(l) && null != i && !r.hasOwnProperty(l)) switch (l) {
                      case "value":
                      case "children":
                        break;
                      default:
                        hh(e, t, l, null, r, i)
                    }
                  for (a in r)
                    if (i = r[a], s = n[a], r.hasOwnProperty(a) && (null != i || null != s)) switch (a) {
                      case "value":
                        f = i;
                        break;
                      case "defaultValue":
                        p = i;
                        break;
                      case "children":
                        break;
                      case "dangerouslySetInnerHTML":
                        if (null != i) throw Error(o(91));
                        break;
                      default:
                        i !== s && hh(e, t, a, i, r, s)
                    }
                  return void xt(e, f, p);
                case "option":
                  for (var g in n)
                    if (f = n[g], n.hasOwnProperty(g) && null != f && !r.hasOwnProperty(g))
                      if ("selected" === g) e.selected = !1;
                      else hh(e, t, g, null, r, f);
                  for (c in r)
                    if (f = r[c], p = n[c], r.hasOwnProperty(c) && f !== p && (null != f || null != p))
                      if ("selected" === c) e.selected = f && "function" !== typeof f && "symbol" !== typeof f;
                      else hh(e, t, c, f, r, p);
                  return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                  for (var m in n) f = n[m], n.hasOwnProperty(m) && null != f && !r.hasOwnProperty(m) && hh(e, t, m, null, r, f);
                  for (u in r)
                    if (f = r[u], p = n[u], r.hasOwnProperty(u) && f !== p && (null != f || null != p)) switch (u) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != f) throw Error(o(137, t));
                        break;
                      default:
                        hh(e, t, u, f, r, p)
                    }
                  return;
                default:
                  if (Ot(t)) {
                    for (var y in n) f = n[y], n.hasOwnProperty(y) && void 0 !== f && !r.hasOwnProperty(y) && dh(e, t, y, void 0, r, f);
                    for (h in r) f = r[h], p = n[h], !r.hasOwnProperty(h) || f === p || void 0 === f && void 0 === p || dh(e, t, h, f, r, p);
                    return
                  }
              }
              for (var v in n) f = n[v], n.hasOwnProperty(v) && null != f && !r.hasOwnProperty(v) && hh(e, t, v, null, r, f);
              for (d in r) f = r[d], p = n[d], !r.hasOwnProperty(d) || f === p || null == f && null == p || hh(e, t, d, f, r, p)
            }(r, e.type, n, t), r[We] = t
          } catch (i) {
            Su(e, e.return, i)
          }
        }

        function El(e) {
          return 5 === e.tag || 3 === e.tag || 26 === e.tag || 27 === e.tag && Ch(e.type) || 4 === e.tag
        }

        function Tl(e) {
          e: for (;;) {
            for (; null === e.sibling;) {
              if (null === e.return || El(e.return)) return null;
              e = e.return
            }
            for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
              if (27 === e.tag && Ch(e.type)) continue e;
              if (2 & e.flags) continue e;
              if (null === e.child || 4 === e.tag) continue e;
              e.child.return = e, e = e.child
            }
            if (!(2 & e.flags)) return e.stateNode
          }
        }

        function Cl(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r) e = e.stateNode, t ? (9 === n.nodeType ? n.body : "HTML" === n.nodeName ? n.ownerDocument.body : n).insertBefore(e, t) : ((t = 9 === n.nodeType ? n.body : "HTML" === n.nodeName ? n.ownerDocument.body : n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Mt));
          else if (4 !== r && (27 === r && Ch(e.type) && (n = e.stateNode, t = null), null !== (e = e.child)))
            for (Cl(e, t, n), e = e.sibling; null !== e;) Cl(e, t, n), e = e.sibling
        }

        function Ol(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
          else if (4 !== r && (27 === r && Ch(e.type) && (n = e.stateNode), null !== (e = e.child)))
            for (Ol(e, t, n), e = e.sibling; null !== e;) Ol(e, t, n), e = e.sibling
        }

        function Pl(e) {
          var t = e.stateNode,
            n = e.memoizedProps;
          try {
            for (var r = e.type, i = t.attributes; i.length;) t.removeAttributeNode(i[0]);
            fh(t, r, n), t[Ue] = e, t[We] = n
          } catch (s) {
            Su(e, e.return, s)
          }
        }
        var Al = !1,
          Rl = !1,
          Ml = !1,
          Ll = "function" === typeof WeakSet ? WeakSet : Set,
          jl = null;

        function Nl(e, t, n) {
          var r = n.flags;
          switch (n.tag) {
            case 0:
            case 11:
            case 15:
              Jl(e, n), 4 & r && yl(5, n);
              break;
            case 1:
              if (Jl(e, n), 4 & r)
                if (e = n.stateNode, null === t) try {
                  e.componentDidMount()
                } catch (o) {
                  Su(n, n.return, o)
                } else {
                  var i = Sa(n.type, t.memoizedProps);
                  t = t.memoizedState;
                  try {
                    e.componentDidUpdate(i, t, e.__reactInternalSnapshotBeforeUpdate)
                  } catch (a) {
                    Su(n, n.return, a)
                  }
                }
              64 & r && bl(n), 512 & r && _l(n, n.return);
              break;
            case 3:
              if (Jl(e, n), 64 & r && null !== (e = n.updateQueue)) {
                if (t = null, null !== n.child) switch (n.child.tag) {
                  case 27:
                  case 5:
                  case 1:
                    t = n.child.stateNode
                }
                try {
                  Cs(e, t)
                } catch (o) {
                  Su(n, n.return, o)
                }
              }
              break;
            case 27:
              null === t && 4 & r && Pl(n);
            case 26:
            case 5:
              Jl(e, n), null === t && 4 & r && kl(n), 512 & r && _l(n, n.return);
              break;
            case 12:
              Jl(e, n);
              break;
            case 31:
              Jl(e, n), 4 & r && Ul(e, n);
              break;
            case 13:
              Jl(e, n), 4 & r && Wl(e, n), 64 & r && (null !== (e = n.memoizedState) && (null !== (e = e.dehydrated) && function(e, t) {
                var n = e.ownerDocument;
                if ("$~" === e.data) e._reactRetry = t;
                else if ("$?" !== e.data || "loading" !== n.readyState) t();
                else {
                  var r = function() {
                    t(), n.removeEventListener("DOMContentLoaded", r)
                  };
                  n.addEventListener("DOMContentLoaded", r), e._reactRetry = r
                }
              }(e, n = Ou.bind(null, n))));
              break;
            case 22:
              if (!(r = null !== n.memoizedState || Al)) {
                t = null !== t && null !== t.memoizedState || Rl, i = Al;
                var s = Rl;
                Al = r, (Rl = t) && !s ? Ql(e, n, 0 !== (8772 & n.subtreeFlags)) : Jl(e, n), Al = i, Rl = s
              }
              break;
            case 30:
              break;
            default:
              Jl(e, n)
          }
        }

        function Il(e) {
          var t = e.alternate;
          null !== t && (e.alternate = null, Il(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && Je(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
        }
        var Dl = null,
          zl = !1;

        function Fl(e, t, n) {
          for (n = n.child; null !== n;) Bl(e, t, n), n = n.sibling
        }

        function Bl(e, t, n) {
          if (ve && "function" === typeof ve.onCommitFiberUnmount) try {
            ve.onCommitFiberUnmount(ye, n)
          } catch (s) {}
          switch (n.tag) {
            case 26:
              Rl || xl(n, t), Fl(e, t, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode).parentNode.removeChild(n);
              break;
            case 27:
              Rl || xl(n, t);
              var r = Dl,
                i = zl;
              Ch(n.type) && (Dl = n.stateNode, zl = !1), Fl(e, t, n), Fh(n.stateNode), Dl = r, zl = i;
              break;
            case 5:
              Rl || xl(n, t);
            case 6:
              if (r = Dl, i = zl, Dl = null, Fl(e, t, n), zl = i, null !== (Dl = r))
                if (zl) try {
                  (9 === Dl.nodeType ? Dl.body : "HTML" === Dl.nodeName ? Dl.ownerDocument.body : Dl).removeChild(n.stateNode)
                } catch (o) {
                  Su(n, t, o)
                } else try {
                  Dl.removeChild(n.stateNode)
                } catch (o) {
                  Su(n, t, o)
                }
              break;
            case 18:
              null !== Dl && (zl ? (Oh(9 === (e = Dl).nodeType ? e.body : "HTML" === e.nodeName ? e.ownerDocument.body : e, n.stateNode), qd(e)) : Oh(Dl, n.stateNode));
              break;
            case 4:
              r = Dl, i = zl, Dl = n.stateNode.containerInfo, zl = !0, Fl(e, t, n), Dl = r, zl = i;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              vl(2, n, t), Rl || vl(4, n, t), Fl(e, t, n);
              break;
            case 1:
              Rl || (xl(n, t), "function" === typeof(r = n.stateNode).componentWillUnmount && wl(n, t, r)), Fl(e, t, n);
              break;
            case 21:
              Fl(e, t, n);
              break;
            case 22:
              Rl = (r = Rl) || null !== n.memoizedState, Fl(e, t, n), Rl = r;
              break;
            default:
              Fl(e, t, n)
          }
        }

        function Ul(e, t) {
          if (null === t.memoizedState && (null !== (e = t.alternate) && null !== (e = e.memoizedState))) {
            e = e.dehydrated;
            try {
              qd(e)
            } catch (n) {
              Su(t, t.return, n)
            }
          }
        }

        function Wl(e, t) {
          if (null === t.memoizedState && (null !== (e = t.alternate) && (null !== (e = e.memoizedState) && null !== (e = e.dehydrated)))) try {
            qd(e)
          } catch (n) {
            Su(t, t.return, n)
          }
        }

        function Hl(e, t) {
          var n = function(e) {
            switch (e.tag) {
              case 31:
              case 13:
              case 19:
                var t = e.stateNode;
                return null === t && (t = e.stateNode = new Ll), t;
              case 22:
                return null === (t = (e = e.stateNode)._retryCache) && (t = e._retryCache = new Ll), t;
              default:
                throw Error(o(435, e.tag))
            }
          }(e);
          t.forEach(function(t) {
            if (!n.has(t)) {
              n.add(t);
              var r = Pu.bind(null, e, t);
              t.then(r, r)
            }
          })
        }

        function Vl(e, t) {
          var n = t.deletions;
          if (null !== n)
            for (var r = 0; r < n.length; r++) {
              var i = n[r],
                s = e,
                a = t,
                l = a;
              e: for (; null !== l;) {
                switch (l.tag) {
                  case 27:
                    if (Ch(l.type)) {
                      Dl = l.stateNode, zl = !1;
                      break e
                    }
                    break;
                  case 5:
                    Dl = l.stateNode, zl = !1;
                    break e;
                  case 3:
                  case 4:
                    Dl = l.stateNode.containerInfo, zl = !0;
                    break e
                }
                l = l.return
              }
              if (null === Dl) throw Error(o(160));
              Bl(s, a, i), Dl = null, zl = !1, null !== (s = i.alternate) && (s.return = null), i.return = null
            }
          if (13886 & t.subtreeFlags)
            for (t = t.child; null !== t;) Kl(t, e), t = t.sibling
        }
        var ql = null;

        function Kl(e, t) {
          var n = e.alternate,
            r = e.flags;
          switch (e.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Vl(t, e), $l(e), 4 & r && (vl(3, e, e.return), yl(3, e), vl(5, e, e.return));
              break;
            case 1:
              Vl(t, e), $l(e), 512 & r && (Rl || null === n || xl(n, n.return)), 64 & r && Al && (null !== (e = e.updateQueue) && (null !== (r = e.callbacks) && (n = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = null === n ? r : n.concat(r))));
              break;
            case 26:
              var i = ql;
              if (Vl(t, e), $l(e), 512 & r && (Rl || null === n || xl(n, n.return)), 4 & r) {
                var s = null !== n ? n.memoizedState : null;
                if (r = e.memoizedState, null === n)
                  if (null === r)
                    if (null === e.stateNode) {
                      e: {
                        r = e.type,
                        n = e.memoizedProps,
                        i = i.ownerDocument || i;t: switch (r) {
                          case "title":
                            (!(s = i.getElementsByTagName("title")[0]) || s[Ye] || s[Ue] || "http://www.w3.org/2000/svg" === s.namespaceURI || s.hasAttribute("itemprop")) && (s = i.createElement(r), i.head.insertBefore(s, i.querySelector("head > title"))), fh(s, r, n), s[Ue] = e, et(s), r = s;
                            break e;
                          case "link":
                            var a = rd("link", "href", i).get(r + (n.href || ""));
                            if (a)
                              for (var l = 0; l < a.length; l++)
                                if ((s = a[l]).getAttribute("href") === (null == n.href || "" === n.href ? null : n.href) && s.getAttribute("rel") === (null == n.rel ? null : n.rel) && s.getAttribute("title") === (null == n.title ? null : n.title) && s.getAttribute("crossorigin") === (null == n.crossOrigin ? null : n.crossOrigin)) {
                                  a.splice(l, 1);
                                  break t
                                } fh(s = i.createElement(r), r, n), i.head.appendChild(s);
                            break;
                          case "meta":
                            if (a = rd("meta", "content", i).get(r + (n.content || "")))
                              for (l = 0; l < a.length; l++)
                                if ((s = a[l]).getAttribute("content") === (null == n.content ? null : "" + n.content) && s.getAttribute("name") === (null == n.name ? null : n.name) && s.getAttribute("property") === (null == n.property ? null : n.property) && s.getAttribute("http-equiv") === (null == n.httpEquiv ? null : n.httpEquiv) && s.getAttribute("charset") === (null == n.charSet ? null : n.charSet)) {
                                  a.splice(l, 1);
                                  break t
                                } fh(s = i.createElement(r), r, n), i.head.appendChild(s);
                            break;
                          default:
                            throw Error(o(468, r))
                        }
                        s[Ue] = e,
                        et(s),
                        r = s
                      }
                      e.stateNode = r
                    }
                else id(i, e.type, e.stateNode);
                else e.stateNode = Xh(i, r, e.memoizedProps);
                else s !== r ? (null === s ? null !== n.stateNode && (n = n.stateNode).parentNode.removeChild(n) : s.count--, null === r ? id(i, e.type, e.stateNode) : Xh(i, r, e.memoizedProps)) : null === r && null !== e.stateNode && Sl(e, e.memoizedProps, n.memoizedProps)
              }
              break;
            case 27:
              Vl(t, e), $l(e), 512 & r && (Rl || null === n || xl(n, n.return)), null !== n && 4 & r && Sl(e, e.memoizedProps, n.memoizedProps);
              break;
            case 5:
              if (Vl(t, e), $l(e), 512 & r && (Rl || null === n || xl(n, n.return)), 32 & e.flags) {
                i = e.stateNode;
                try {
                  St(i, "")
                } catch (g) {
                  Su(e, e.return, g)
                }
              }
              4 & r && null != e.stateNode && Sl(e, i = e.memoizedProps, null !== n ? n.memoizedProps : i), 1024 & r && (Ml = !0);
              break;
            case 6:
              if (Vl(t, e), $l(e), 4 & r) {
                if (null === e.stateNode) throw Error(o(162));
                r = e.memoizedProps, n = e.stateNode;
                try {
                  n.nodeValue = r
                } catch (g) {
                  Su(e, e.return, g)
                }
              }
              break;
            case 3:
              if (nd = null, i = ql, ql = Wh(t.containerInfo), Vl(t, e), ql = i, $l(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                qd(t.containerInfo)
              } catch (g) {
                Su(e, e.return, g)
              }
              Ml && (Ml = !1, Yl(e));
              break;
            case 4:
              r = ql, ql = Wh(e.stateNode.containerInfo), Vl(t, e), $l(e), ql = r;
              break;
            case 12:
            default:
              Vl(t, e), $l(e);
              break;
            case 31:
            case 19:
              Vl(t, e), $l(e), 4 & r && (null !== (r = e.updateQueue) && (e.updateQueue = null, Hl(e, r)));
              break;
            case 13:
              Vl(t, e), $l(e), 8192 & e.child.flags && null !== e.memoizedState !== (null !== n && null !== n.memoizedState) && (Lc = le()), 4 & r && (null !== (r = e.updateQueue) && (e.updateQueue = null, Hl(e, r)));
              break;
            case 22:
              i = null !== e.memoizedState;
              var c = null !== n && null !== n.memoizedState,
                u = Al,
                h = Rl;
              if (Al = u || i, Rl = h || c, Vl(t, e), Rl = h, Al = u, $l(e), 8192 & r) e: for (t = e.stateNode, t._visibility = i ? -2 & t._visibility : 1 | t._visibility, i && (null === n || c || Al || Rl || Gl(e)), n = null, t = e;;) {
                if (5 === t.tag || 26 === t.tag) {
                  if (null === n) {
                    c = n = t;
                    try {
                      if (s = c.stateNode, i) "function" === typeof(a = s.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none";
                      else {
                        l = c.stateNode;
                        var d = c.memoizedProps.style,
                          f = void 0 !== d && null !== d && d.hasOwnProperty("display") ? d.display : null;
                        l.style.display = null == f || "boolean" === typeof f ? "" : ("" + f).trim()
                      }
                    } catch (g) {
                      Su(c, c.return, g)
                    }
                  }
                } else if (6 === t.tag) {
                  if (null === n) {
                    c = t;
                    try {
                      c.stateNode.nodeValue = i ? "" : c.memoizedProps
                    } catch (g) {
                      Su(c, c.return, g)
                    }
                  }
                } else if (18 === t.tag) {
                  if (null === n) {
                    c = t;
                    try {
                      var p = c.stateNode;
                      i ? Ph(p, !0) : Ph(c.stateNode, !1)
                    } catch (g) {
                      Su(c, c.return, g)
                    }
                  }
                } else if ((22 !== t.tag && 23 !== t.tag || null === t.memoizedState || t === e) && null !== t.child) {
                  t.child.return = t, t = t.child;
                  continue
                }
                if (t === e) break e;
                for (; null === t.sibling;) {
                  if (null === t.return || t.return === e) break e;
                  n === t && (n = null), t = t.return
                }
                n === t && (n = null), t.sibling.return = t.return, t = t.sibling
              }
              4 & r && (null !== (r = e.updateQueue) && (null !== (n = r.retryQueue) && (r.retryQueue = null, Hl(e, n))));
            case 30:
            case 21:
          }
        }

        function $l(e) {
          var t = e.flags;
          if (2 & t) {
            try {
              for (var n, r = e.return; null !== r;) {
                if (El(r)) {
                  n = r;
                  break
                }
                r = r.return
              }
              if (null == n) throw Error(o(160));
              switch (n.tag) {
                case 27:
                  var i = n.stateNode;
                  Ol(e, Tl(e), i);
                  break;
                case 5:
                  var s = n.stateNode;
                  32 & n.flags && (St(s, ""), n.flags &= -33), Ol(e, Tl(e), s);
                  break;
                case 3:
                case 4:
                  var a = n.stateNode.containerInfo;
                  Cl(e, Tl(e), a);
                  break;
                default:
                  throw Error(o(161))
              }
            } catch (l) {
              Su(e, e.return, l)
            }
            e.flags &= -3
          }
          4096 & t && (e.flags &= -4097)
        }

        function Yl(e) {
          if (1024 & e.subtreeFlags)
            for (e = e.child; null !== e;) {
              var t = e;
              Yl(t), 5 === t.tag && 1024 & t.flags && t.stateNode.reset(), e = e.sibling
            }
        }

        function Jl(e, t) {
          if (8772 & t.subtreeFlags)
            for (t = t.child; null !== t;) Nl(e, t.alternate, t), t = t.sibling
        }

        function Gl(e) {
          for (e = e.child; null !== e;) {
            var t = e;
            switch (t.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                vl(4, t, t.return), Gl(t);
                break;
              case 1:
                xl(t, t.return);
                var n = t.stateNode;
                "function" === typeof n.componentWillUnmount && wl(t, t.return, n), Gl(t);
                break;
              case 27:
                Fh(t.stateNode);
              case 26:
              case 5:
                xl(t, t.return), Gl(t);
                break;
              case 22:
                null === t.memoizedState && Gl(t);
                break;
              default:
                Gl(t)
            }
            e = e.sibling
          }
        }

        function Ql(e, t, n) {
          for (n = n && 0 !== (8772 & t.subtreeFlags), t = t.child; null !== t;) {
            var r = t.alternate,
              i = e,
              s = t,
              o = s.flags;
            switch (s.tag) {
              case 0:
              case 11:
              case 15:
                Ql(i, s, n), yl(4, s);
                break;
              case 1:
                if (Ql(i, s, n), "function" === typeof(i = (r = s).stateNode).componentDidMount) try {
                  i.componentDidMount()
                } catch (c) {
                  Su(r, r.return, c)
                }
                if (null !== (i = (r = s).updateQueue)) {
                  var a = r.stateNode;
                  try {
                    var l = i.shared.hiddenCallbacks;
                    if (null !== l)
                      for (i.shared.hiddenCallbacks = null, i = 0; i < l.length; i++) Ts(l[i], a)
                  } catch (c) {
                    Su(r, r.return, c)
                  }
                }
                n && 64 & o && bl(s), _l(s, s.return);
                break;
              case 27:
                Pl(s);
              case 26:
              case 5:
                Ql(i, s, n), n && null === r && 4 & o && kl(s), _l(s, s.return);
                break;
              case 12:
                Ql(i, s, n);
                break;
              case 31:
                Ql(i, s, n), n && 4 & o && Ul(i, s);
                break;
              case 13:
                Ql(i, s, n), n && 4 & o && Wl(i, s);
                break;
              case 22:
                null === s.memoizedState && Ql(i, s, n), _l(s, s.return);
                break;
              case 30:
                break;
              default:
                Ql(i, s, n)
            }
            t = t.sibling
          }
        }

        function Xl(e, t) {
          var n = null;
          null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (n = e.memoizedState.cachePool.pool), e = null, null !== t.memoizedState && null !== t.memoizedState.cachePool && (e = t.memoizedState.cachePool.pool), e !== n && (null != e && e.refCount++, null != n && Ui(n))
        }

        function Zl(e, t) {
          e = null, null !== t.alternate && (e = t.alternate.memoizedState.cache), (t = t.memoizedState.cache) !== e && (t.refCount++, null != e && Ui(e))
        }

        function ec(e, t, n, r) {
          if (10256 & t.subtreeFlags)
            for (t = t.child; null !== t;) tc(e, t, n, r), t = t.sibling
        }

        function tc(e, t, n, r) {
          var i = t.flags;
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              ec(e, t, n, r), 2048 & i && yl(9, t);
              break;
            case 1:
            case 31:
            case 13:
            default:
              ec(e, t, n, r);
              break;
            case 3:
              ec(e, t, n, r), 2048 & i && (e = null, null !== t.alternate && (e = t.alternate.memoizedState.cache), (t = t.memoizedState.cache) !== e && (t.refCount++, null != e && Ui(e)));
              break;
            case 12:
              if (2048 & i) {
                ec(e, t, n, r), e = t.stateNode;
                try {
                  var s = t.memoizedProps,
                    o = s.id,
                    a = s.onPostCommit;
                  "function" === typeof a && a(o, null === t.alternate ? "mount" : "update", e.passiveEffectDuration, -0)
                } catch (l) {
                  Su(t, t.return, l)
                }
              } else ec(e, t, n, r);
              break;
            case 23:
              break;
            case 22:
              s = t.stateNode, o = t.alternate, null !== t.memoizedState ? 2 & s._visibility ? ec(e, t, n, r) : rc(e, t) : 2 & s._visibility ? ec(e, t, n, r) : (s._visibility |= 2, nc(e, t, n, r, 0 !== (10256 & t.subtreeFlags) || !1)), 2048 & i && Xl(o, t);
              break;
            case 24:
              ec(e, t, n, r), 2048 & i && Zl(t.alternate, t)
          }
        }

        function nc(e, t, n, r, i) {
          for (i = i && (0 !== (10256 & t.subtreeFlags) || !1), t = t.child; null !== t;) {
            var s = e,
              o = t,
              a = n,
              l = r,
              c = o.flags;
            switch (o.tag) {
              case 0:
              case 11:
              case 15:
                nc(s, o, a, l, i), yl(8, o);
                break;
              case 23:
                break;
              case 22:
                var u = o.stateNode;
                null !== o.memoizedState ? 2 & u._visibility ? nc(s, o, a, l, i) : rc(s, o) : (u._visibility |= 2, nc(s, o, a, l, i)), i && 2048 & c && Xl(o.alternate, o);
                break;
              case 24:
                nc(s, o, a, l, i), i && 2048 & c && Zl(o.alternate, o);
                break;
              default:
                nc(s, o, a, l, i)
            }
            t = t.sibling
          }
        }

        function rc(e, t) {
          if (10256 & t.subtreeFlags)
            for (t = t.child; null !== t;) {
              var n = e,
                r = t,
                i = r.flags;
              switch (r.tag) {
                case 22:
                  rc(n, r), 2048 & i && Xl(r.alternate, r);
                  break;
                case 24:
                  rc(n, r), 2048 & i && Zl(r.alternate, r);
                  break;
                default:
                  rc(n, r)
              }
              t = t.sibling
            }
        }
        var ic = 8192;

        function sc(e, t, n) {
          if (e.subtreeFlags & ic)
            for (e = e.child; null !== e;) oc(e, t, n), e = e.sibling
        }

        function oc(e, t, n) {
          switch (e.tag) {
            case 26:
              sc(e, t, n), e.flags & ic && null !== e.memoizedState && function(e, t, n, r) {
                if ("stylesheet" === n.type && ("string" !== typeof r.media || !1 !== matchMedia(r.media).matches) && 0 === (4 & n.state.loading)) {
                  if (null === n.instance) {
                    var i = $h(r.href),
                      s = t.querySelector(Yh(i));
                    if (s) return null !== (t = s._p) && "object" === typeof t && "function" === typeof t.then && (e.count++, e = ad.bind(e), t.then(e, e)), n.state.loading |= 4, n.instance = s, void et(s);
                    s = t.ownerDocument || t, r = Jh(r), (i = Bh.get(i)) && ed(r, i), et(s = s.createElement("link"));
                    var o = s;
                    o._p = new Promise(function(e, t) {
                      o.onload = e, o.onerror = t
                    }), fh(s, "link", r), n.instance = s
                  }
                  null === e.stylesheets && (e.stylesheets = new Map), e.stylesheets.set(n, t), (t = n.state.preload) && 0 === (3 & n.state.loading) && (e.count++, n = ad.bind(e), t.addEventListener("load", n), t.addEventListener("error", n))
                }
              }(n, ql, e.memoizedState, e.memoizedProps);
              break;
            case 5:
            default:
              sc(e, t, n);
              break;
            case 3:
            case 4:
              var r = ql;
              ql = Wh(e.stateNode.containerInfo), sc(e, t, n), ql = r;
              break;
            case 22:
              null === e.memoizedState && (null !== (r = e.alternate) && null !== r.memoizedState ? (r = ic, ic = 16777216, sc(e, t, n), ic = r) : sc(e, t, n))
          }
        }

        function ac(e) {
          var t = e.alternate;
          if (null !== t && null !== (e = t.child)) {
            t.child = null;
            do {
              t = e.sibling, e.sibling = null, e = t
            } while (null !== e)
          }
        }

        function lc(e) {
          var t = e.deletions;
          if (0 !== (16 & e.flags)) {
            if (null !== t)
              for (var n = 0; n < t.length; n++) {
                var r = t[n];
                jl = r, hc(r, e)
              }
            ac(e)
          }
          if (10256 & e.subtreeFlags)
            for (e = e.child; null !== e;) cc(e), e = e.sibling
        }

        function cc(e) {
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              lc(e), 2048 & e.flags && vl(9, e, e.return);
              break;
            case 3:
            case 12:
            default:
              lc(e);
              break;
            case 22:
              var t = e.stateNode;
              null !== e.memoizedState && 2 & t._visibility && (null === e.return || 13 !== e.return.tag) ? (t._visibility &= -3, uc(e)) : lc(e)
          }
        }

        function uc(e) {
          var t = e.deletions;
          if (0 !== (16 & e.flags)) {
            if (null !== t)
              for (var n = 0; n < t.length; n++) {
                var r = t[n];
                jl = r, hc(r, e)
              }
            ac(e)
          }
          for (e = e.child; null !== e;) {
            switch ((t = e).tag) {
              case 0:
              case 11:
              case 15:
                vl(8, t, t.return), uc(t);
                break;
              case 22:
                2 & (n = t.stateNode)._visibility && (n._visibility &= -3, uc(t));
                break;
              default:
                uc(t)
            }
            e = e.sibling
          }
        }

        function hc(e, t) {
          for (; null !== jl;) {
            var n = jl;
            switch (n.tag) {
              case 0:
              case 11:
              case 15:
                vl(8, n, t);
                break;
              case 23:
              case 22:
                if (null !== n.memoizedState && null !== n.memoizedState.cachePool) {
                  var r = n.memoizedState.cachePool.pool;
                  null != r && r.refCount++
                }
                break;
              case 24:
                Ui(n.memoizedState.cache)
            }
            if (null !== (r = n.child)) r.return = n, jl = r;
            else e: for (n = e; null !== jl;) {
              var i = (r = jl).sibling,
                s = r.return;
              if (Il(r), r === n) {
                jl = null;
                break e
              }
              if (null !== i) {
                i.return = s, jl = i;
                break e
              }
              jl = s
            }
          }
        }
        var dc = {
            getCacheForType: function(e) {
              var t = Li(Fi),
                n = t.data.get(e);
              return void 0 === n && (n = e(), t.data.set(e, n)), n
            },
            cacheSignal: function() {
              return Li(Fi).controller.signal
            }
          },
          fc = "function" === typeof WeakMap ? WeakMap : Map,
          pc = 0,
          gc = null,
          mc = null,
          yc = 0,
          vc = 0,
          bc = null,
          wc = !1,
          _c = !1,
          xc = !1,
          kc = 0,
          Sc = 0,
          Ec = 0,
          Tc = 0,
          Cc = 0,
          Oc = 0,
          Pc = 0,
          Ac = null,
          Rc = null,
          Mc = !1,
          Lc = 0,
          jc = 0,
          Nc = 1 / 0,
          Ic = null,
          Dc = null,
          zc = 0,
          Fc = null,
          Bc = null,
          Uc = 0,
          Wc = 0,
          Hc = null,
          Vc = null,
          qc = 0,
          Kc = null;

        function $c() {
          return 0 !== (2 & pc) && 0 !== yc ? yc & -yc : null !== j.T ? Hu() : ze()
        }

        function Yc() {
          if (0 === Oc)
            if (0 === (536870912 & yc) || di) {
              var e = Se;
              0 === (3932160 & (Se <<= 1)) && (Se = 262144), Oc = e
            } else Oc = 536870912;
          return null !== (e = Ls.current) && (e.flags |= 32), Oc
        }

        function Jc(e, t, n) {
          (e !== gc || 2 !== vc && 9 !== vc) && null === e.cancelPendingCommit || (nu(e, 0), Zc(e, yc, Oc, !1)), Me(e, n), 0 !== (2 & pc) && e === gc || (e === gc && (0 === (2 & pc) && (Tc |= n), 4 === Sc && Zc(e, yc, Oc, !1)), Iu(e))
        }

        function Gc(e, t, n) {
          if (0 !== (6 & pc)) throw Error(o(327));
          for (var r = !n && 0 === (127 & t) && 0 === (t & e.expiredLanes) || Oe(e, t), i = r ? function(e, t) {
              var n = pc;
              pc |= 2;
              var r = su(),
                i = ou();
              gc !== e || yc !== t ? (Ic = null, Nc = le() + 500, nu(e, t)) : _c = Oe(e, t);
              e: for (;;) try {
                if (0 !== vc && null !== mc) {
                  t = mc;
                  var s = bc;
                  t: switch (vc) {
                    case 1:
                      vc = 0, bc = null, fu(e, t, s, 1);
                      break;
                    case 2:
                    case 9:
                      if (ns(s)) {
                        vc = 0, bc = null, du(t);
                        break
                      }
                      t = function() {
                        2 !== vc && 9 !== vc || gc !== e || (vc = 7), Iu(e)
                      }, s.then(t, t);
                      break e;
                    case 3:
                      vc = 7;
                      break e;
                    case 4:
                      vc = 5;
                      break e;
                    case 7:
                      ns(s) ? (vc = 0, bc = null, du(t)) : (vc = 0, bc = null, fu(e, t, s, 7));
                      break;
                    case 5:
                      var a = null;
                      switch (mc.tag) {
                        case 26:
                          a = mc.memoizedState;
                        case 5:
                        case 27:
                          var l = mc;
                          if (a ? sd(a) : l.stateNode.complete) {
                            vc = 0, bc = null;
                            var c = l.sibling;
                            if (null !== c) mc = c;
                            else {
                              var u = l.return;
                              null !== u ? (mc = u, pu(u)) : mc = null
                            }
                            break t
                          }
                      }
                      vc = 0, bc = null, fu(e, t, s, 5);
                      break;
                    case 6:
                      vc = 0, bc = null, fu(e, t, s, 6);
                      break;
                    case 8:
                      tu(), Sc = 6;
                      break e;
                    default:
                      throw Error(o(462))
                  }
                }
                uu();
                break
              } catch (h) {
                ru(e, h)
              }
              return Ei = Si = null, j.H = r, j.A = i, pc = n, null !== mc ? 0 : (gc = null, yc = 0, Ar(), Sc)
            }(e, t) : lu(e, t, !0), s = r;;) {
            if (0 === i) {
              _c && !r && Zc(e, t, 0, !1);
              break
            }
            if (n = e.current.alternate, !s || Xc(n)) {
              if (2 === i) {
                if (s = t, e.errorRecoveryDisabledLanes & s) var a = 0;
                else a = 0 !== (a = -536870913 & e.pendingLanes) ? a : 536870912 & a ? 536870912 : 0;
                if (0 !== a) {
                  t = a;
                  e: {
                    var l = e;i = Ac;
                    var c = l.current.memoizedState.isDehydrated;
                    if (c && (nu(l, a).flags |= 256), 2 !== (a = lu(l, a, !1))) {
                      if (xc && !c) {
                        l.errorRecoveryDisabledLanes |= s, Tc |= s, i = 4;
                        break e
                      }
                      s = Rc, Rc = i, null !== s && (null === Rc ? Rc = s : Rc.push.apply(Rc, s))
                    }
                    i = a
                  }
                  if (s = !1, 2 !== i) continue
                }
              }
              if (1 === i) {
                nu(e, 0), Zc(e, t, 0, !0);
                break
              }
              e: {
                switch (r = e, s = i) {
                  case 0:
                  case 1:
                    throw Error(o(345));
                  case 4:
                    if ((4194048 & t) !== t) break;
                  case 6:
                    Zc(r, t, Oc, !wc);
                    break e;
                  case 2:
                    Rc = null;
                    break;
                  case 3:
                  case 5:
                    break;
                  default:
                    throw Error(o(329))
                }
                if ((62914560 & t) === t && 10 < (i = Lc + 300 - le())) {
                  if (Zc(r, t, Oc, !wc), 0 !== Ce(r, 0, !0)) break e;
                  Uc = t, r.timeoutHandle = xh(Qc.bind(null, r, n, Rc, Ic, Mc, t, Oc, Tc, Pc, wc, s, "Throttled", -0, 0), i)
                } else Qc(r, n, Rc, Ic, Mc, t, Oc, Tc, Pc, wc, s, null, -0, 0)
              }
              break
            }
            i = lu(e, t, !1), s = !1
          }
          Iu(e)
        }

        function Qc(e, t, n, r, i, s, o, a, l, c, u, h, d, f) {
          if (e.timeoutHandle = -1, 8192 & (h = t.subtreeFlags) || 16785408 === (16785408 & h)) {
            oc(t, s, h = {
              stylesheets: null,
              count: 0,
              imgCount: 0,
              imgBytes: 0,
              suspenseyImages: [],
              waitingForImages: !0,
              waitingForViewTransition: !1,
              unsuspend: Mt
            });
            var p = (62914560 & s) === s ? Lc - le() : (4194048 & s) === s ? jc - le() : 0;
            if (null !== (p = function(e, t) {
                return e.stylesheets && 0 === e.count && cd(e, e.stylesheets), 0 < e.count || 0 < e.imgCount ? function(n) {
                  var r = setTimeout(function() {
                    if (e.stylesheets && cd(e, e.stylesheets), e.unsuspend) {
                      var t = e.unsuspend;
                      e.unsuspend = null, t()
                    }
                  }, 6e4 + t);
                  0 < e.imgBytes && 0 === od && (od = 62500 * function() {
                    if ("function" === typeof performance.getEntriesByType) {
                      for (var e = 0, t = 0, n = performance.getEntriesByType("resource"), r = 0; r < n.length; r++) {
                        var i = n[r],
                          s = i.transferSize,
                          o = i.initiatorType,
                          a = i.duration;
                        if (s && a && ph(o)) {
                          for (o = 0, a = i.responseEnd, r += 1; r < n.length; r++) {
                            var l = n[r],
                              c = l.startTime;
                            if (c > a) break;
                            var u = l.transferSize,
                              h = l.initiatorType;
                            u && ph(h) && (o += u * ((l = l.responseEnd) < a ? 1 : (a - c) / (l - c)))
                          }
                          if (--r, t += 8 * (s + o) / (i.duration / 1e3), 10 < ++e) break
                        }
                      }
                      if (0 < e) return t / e / 1e6
                    }
                    return navigator.connection && "number" === typeof(e = navigator.connection.downlink) ? e : 5
                  }());
                  var i = setTimeout(function() {
                    if (e.waitingForImages = !1, 0 === e.count && (e.stylesheets && cd(e, e.stylesheets), e.unsuspend)) {
                      var t = e.unsuspend;
                      e.unsuspend = null, t()
                    }
                  }, (e.imgBytes > od ? 50 : 800) + t);
                  return e.unsuspend = n,
                    function() {
                      e.unsuspend = null, clearTimeout(r), clearTimeout(i)
                    }
                } : null
              }(h, p))) return Uc = s, e.cancelPendingCommit = p(mu.bind(null, e, t, s, n, r, i, o, a, l, u, h, null, d, f)), void Zc(e, s, o, !c)
          }
          mu(e, t, s, n, r, i, o, a, l)
        }

        function Xc(e) {
          for (var t = e;;) {
            var n = t.tag;
            if ((0 === n || 11 === n || 15 === n) && 16384 & t.flags && (null !== (n = t.updateQueue) && null !== (n = n.stores)))
              for (var r = 0; r < n.length; r++) {
                var i = n[r],
                  s = i.getSnapshot;
                i = i.value;
                try {
                  if (!Xn(s(), i)) return !1
                } catch (o) {
                  return !1
                }
              }
            if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
            else {
              if (t === e) break;
              for (; null === t.sibling;) {
                if (null === t.return || t.return === e) return !0;
                t = t.return
              }
              t.sibling.return = t.return, t = t.sibling
            }
          }
          return !0
        }

        function Zc(e, t, n, r) {
          t &= ~Cc, t &= ~Tc, e.suspendedLanes |= t, e.pingedLanes &= ~t, r && (e.warmLanes |= t), r = e.expirationTimes;
          for (var i = t; 0 < i;) {
            var s = 31 - we(i),
              o = 1 << s;
            r[s] = -1, i &= ~o
          }
          0 !== n && Le(e, n, t)
        }

        function eu() {
          return 0 !== (6 & pc) || (Du(0, !1), !1)
        }

        function tu() {
          if (null !== mc) {
            if (0 === vc) var e = mc.return;
            else Ei = Si = null, ao(e = mc), ls = null, cs = 0, e = mc;
            for (; null !== e;) ml(e.alternate, e), e = e.return;
            mc = null
          }
        }

        function nu(e, t) {
          var n = e.timeoutHandle; - 1 !== n && (e.timeoutHandle = -1, kh(n)), null !== (n = e.cancelPendingCommit) && (e.cancelPendingCommit = null, n()), Uc = 0, tu(), gc = e, mc = n = Br(e.current, null), yc = t, vc = 0, bc = null, wc = !1, _c = Oe(e, t), xc = !1, Pc = Oc = Cc = Tc = Ec = Sc = 0, Rc = Ac = null, Mc = !1, 0 !== (8 & t) && (t |= 32 & t);
          var r = e.entangledLanes;
          if (0 !== r)
            for (e = e.entanglements, r &= t; 0 < r;) {
              var i = 31 - we(r),
                s = 1 << i;
              t |= e[i], r &= ~s
            }
          return kc = t, Ar(), n
        }

        function ru(e, t) {
          Hs = null, j.H = ma, t === Xi || t === es ? (t = os(), vc = 3) : t === Zi ? (t = os(), vc = 4) : vc = t === La ? 8 : null !== t && "object" === typeof t && "function" === typeof t.then ? 6 : 1, bc = t, null === mc && (Sc = 1, Oa(e, Yr(t, e.current)))
        }

        function iu() {
          var e = Ls.current;
          return null === e || ((4194048 & yc) === yc ? null === js : ((62914560 & yc) === yc || 0 !== (536870912 & yc)) && e === js)
        }

        function su() {
          var e = j.H;
          return j.H = ma, null === e ? ma : e
        }

        function ou() {
          var e = j.A;
          return j.A = dc, e
        }

        function au() {
          Sc = 4, wc || (4194048 & yc) !== yc && null !== Ls.current || (_c = !0), 0 === (134217727 & Ec) && 0 === (134217727 & Tc) || null === gc || Zc(gc, yc, Oc, !1)
        }

        function lu(e, t, n) {
          var r = pc;
          pc |= 2;
          var i = su(),
            s = ou();
          gc === e && yc === t || (Ic = null, nu(e, t)), t = !1;
          var o = Sc;
          e: for (;;) try {
            if (0 !== vc && null !== mc) {
              var a = mc,
                l = bc;
              switch (vc) {
                case 8:
                  tu(), o = 6;
                  break e;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === Ls.current && (t = !0);
                  var c = vc;
                  if (vc = 0, bc = null, fu(e, a, l, c), n && _c) {
                    o = 0;
                    break e
                  }
                  break;
                default:
                  c = vc, vc = 0, bc = null, fu(e, a, l, c)
              }
            }
            cu(), o = Sc;
            break
          } catch (u) {
            ru(e, u)
          }
          return t && e.shellSuspendCounter++, Ei = Si = null, pc = r, j.H = i, j.A = s, null === mc && (gc = null, yc = 0, Ar()), o
        }

        function cu() {
          for (; null !== mc;) hu(mc)
        }

        function uu() {
          for (; null !== mc && !oe();) hu(mc)
        }

        function hu(e) {
          var t = al(e.alternate, e, kc);
          e.memoizedProps = e.pendingProps, null === t ? pu(e) : mc = t
        }

        function du(e) {
          var t = e,
            n = t.alternate;
          switch (t.tag) {
            case 15:
            case 0:
              t = Ka(n, t, t.pendingProps, t.type, void 0, yc);
              break;
            case 11:
              t = Ka(n, t, t.pendingProps, t.type.render, t.ref, yc);
              break;
            case 5:
              ao(t);
            default:
              ml(n, t), t = al(n, t = mc = Ur(t, kc), kc)
          }
          e.memoizedProps = e.pendingProps, null === t ? pu(e) : mc = t
        }

        function fu(e, t, n, r) {
          Ei = Si = null, ao(t), ls = null, cs = 0;
          var i = t.return;
          try {
            if (function(e, t, n, r, i) {
                if (n.flags |= 32768, null !== r && "object" === typeof r && "function" === typeof r.then) {
                  if (null !== (t = n.alternate) && Ai(t, n, i, !0), null !== (n = Ls.current)) {
                    switch (n.tag) {
                      case 31:
                      case 13:
                        return null === js ? au() : null === n.alternate && 0 === Sc && (Sc = 3), n.flags &= -257, n.flags |= 65536, n.lanes = i, r === ts ? n.flags |= 16384 : (null === (t = n.updateQueue) ? n.updateQueue = new Set([r]) : t.add(r), Eu(e, r, i)), !1;
                      case 22:
                        return n.flags |= 65536, r === ts ? n.flags |= 16384 : (null === (t = n.updateQueue) ? (t = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([r])
                        }, n.updateQueue = t) : null === (n = t.retryQueue) ? t.retryQueue = new Set([r]) : n.add(r), Eu(e, r, i)), !1
                    }
                    throw Error(o(435, n.tag))
                  }
                  return Eu(e, r, i), au(), !1
                }
                if (di) return null !== (t = Ls.current) ? (0 === (65536 & t.flags) && (t.flags |= 256), t.flags |= 65536, t.lanes = i, r !== gi && xi(Yr(e = Error(o(422), {
                  cause: r
                }), n))) : (r !== gi && xi(Yr(t = Error(o(423), {
                  cause: r
                }), n)), (e = e.current.alternate).flags |= 65536, i &= -i, e.lanes |= i, r = Yr(r, n), xs(e, i = Aa(e.stateNode, r, i)), 4 !== Sc && (Sc = 2)), !1;
                var s = Error(o(520), {
                  cause: r
                });
                if (s = Yr(s, n), null === Ac ? Ac = [s] : Ac.push(s), 4 !== Sc && (Sc = 2), null === t) return !0;
                r = Yr(r, n), n = t;
                do {
                  switch (n.tag) {
                    case 3:
                      return n.flags |= 65536, e = i & -i, n.lanes |= e, xs(n, e = Aa(n.stateNode, r, e)), !1;
                    case 1:
                      if (t = n.type, s = n.stateNode, 0 === (128 & n.flags) && ("function" === typeof t.getDerivedStateFromError || null !== s && "function" === typeof s.componentDidCatch && (null === Dc || !Dc.has(s)))) return n.flags |= 65536, i &= -i, n.lanes |= i, Ma(i = Ra(i), e, n, r), xs(n, i), !1
                  }
                  n = n.return
                } while (null !== n);
                return !1
              }(e, i, t, n, yc)) return Sc = 1, Oa(e, Yr(n, e.current)), void(mc = null)
          } catch (s) {
            if (null !== i) throw mc = i, s;
            return Sc = 1, Oa(e, Yr(n, e.current)), void(mc = null)
          }
          32768 & t.flags ? (di || 1 === r ? e = !0 : _c || 0 !== (536870912 & yc) ? e = !1 : (wc = e = !0, (2 === r || 9 === r || 3 === r || 6 === r) && (null !== (r = Ls.current) && 13 === r.tag && (r.flags |= 16384))), gu(t, e)) : pu(t)
        }

        function pu(e) {
          var t = e;
          do {
            if (0 !== (32768 & t.flags)) return void gu(t, wc);
            e = t.return;
            var n = pl(t.alternate, t, kc);
            if (null !== n) return void(mc = n);
            if (null !== (t = t.sibling)) return void(mc = t);
            mc = t = e
          } while (null !== t);
          0 === Sc && (Sc = 5)
        }

        function gu(e, t) {
          do {
            var n = gl(e.alternate, e);
            if (null !== n) return n.flags &= 32767, void(mc = n);
            if (null !== (n = e.return) && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && null !== (e = e.sibling)) return void(mc = e);
            mc = e = n
          } while (null !== e);
          Sc = 6, mc = null
        }

        function mu(e, t, n, r, i, s, a, l, c) {
          e.cancelPendingCommit = null;
          do {
            _u()
          } while (0 !== zc);
          if (0 !== (6 & pc)) throw Error(o(327));
          if (null !== t) {
            if (t === e.current) throw Error(o(177));
            if (s = t.lanes | t.childLanes, function(e, t, n, r, i, s) {
                var o = e.pendingLanes;
                e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0;
                var a = e.entanglements,
                  l = e.expirationTimes,
                  c = e.hiddenUpdates;
                for (n = o & ~n; 0 < n;) {
                  var u = 31 - we(n),
                    h = 1 << u;
                  a[u] = 0, l[u] = -1;
                  var d = c[u];
                  if (null !== d)
                    for (c[u] = null, u = 0; u < d.length; u++) {
                      var f = d[u];
                      null !== f && (f.lane &= -536870913)
                    }
                  n &= ~h
                }
                0 !== r && Le(e, r, 0), 0 !== s && 0 === i && 0 !== e.tag && (e.suspendedLanes |= s & ~(o & ~t))
              }(e, n, s |= Pr, a, l, c), e === gc && (mc = gc = null, yc = 0), Bc = t, Fc = e, Uc = n, Wc = s, Hc = i, Vc = r, 0 !== (10256 & t.subtreeFlags) || 0 !== (10256 & t.flags) ? (e.callbackNode = null, e.callbackPriority = 0, function(e, t) {
                ie(e, t)
              }(de, function() {
                return xu(), null
              })) : (e.callbackNode = null, e.callbackPriority = 0), r = 0 !== (13878 & t.flags), 0 !== (13878 & t.subtreeFlags) || r) {
              r = j.T, j.T = null, i = N.p, N.p = 2, a = pc, pc |= 4;
              try {
                ! function(e, t) {
                  if (e = e.containerInfo, gh = wd, ir(e = rr(e))) {
                    if ("selectionStart" in e) var n = {
                      start: e.selectionStart,
                      end: e.selectionEnd
                    };
                    else e: {
                      var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                      if (r && 0 !== r.rangeCount) {
                        n = r.anchorNode;
                        var i = r.anchorOffset,
                          s = r.focusNode;
                        r = r.focusOffset;
                        try {
                          n.nodeType, s.nodeType
                        } catch (m) {
                          n = null;
                          break e
                        }
                        var a = 0,
                          l = -1,
                          c = -1,
                          u = 0,
                          h = 0,
                          d = e,
                          f = null;
                        t: for (;;) {
                          for (var p; d !== n || 0 !== i && 3 !== d.nodeType || (l = a + i), d !== s || 0 !== r && 3 !== d.nodeType || (c = a + r), 3 === d.nodeType && (a += d.nodeValue.length), null !== (p = d.firstChild);) f = d, d = p;
                          for (;;) {
                            if (d === e) break t;
                            if (f === n && ++u === i && (l = a), f === s && ++h === r && (c = a), null !== (p = d.nextSibling)) break;
                            f = (d = f).parentNode
                          }
                          d = p
                        }
                        n = -1 === l || -1 === c ? null : {
                          start: l,
                          end: c
                        }
                      } else n = null
                    }
                    n = n || {
                      start: 0,
                      end: 0
                    }
                  } else n = null;
                  for (mh = {
                      focusedElem: e,
                      selectionRange: n
                    }, wd = !1, jl = t; null !== jl;)
                    if (e = (t = jl).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, jl = e;
                    else
                      for (; null !== jl;) {
                        switch (s = (t = jl).alternate, e = t.flags, t.tag) {
                          case 0:
                            if (0 !== (4 & e) && null !== (e = null !== (e = t.updateQueue) ? e.events : null))
                              for (n = 0; n < e.length; n++)(i = e[n]).ref.impl = i.nextImpl;
                            break;
                          case 11:
                          case 15:
                          case 5:
                          case 26:
                          case 27:
                          case 6:
                          case 4:
                          case 17:
                            break;
                          case 1:
                            if (0 !== (1024 & e) && null !== s) {
                              e = void 0, n = t, i = s.memoizedProps, s = s.memoizedState, r = n.stateNode;
                              try {
                                var g = Sa(n.type, i);
                                e = r.getSnapshotBeforeUpdate(g, s), r.__reactInternalSnapshotBeforeUpdate = e
                              } catch (y) {
                                Su(n, n.return, y)
                              }
                            }
                            break;
                          case 3:
                            if (0 !== (1024 & e))
                              if (9 === (n = (e = t.stateNode.containerInfo).nodeType)) Ah(e);
                              else if (1 === n) switch (e.nodeName) {
                              case "HEAD":
                              case "HTML":
                              case "BODY":
                                Ah(e);
                                break;
                              default:
                                e.textContent = ""
                            }
                            break;
                          default:
                            if (0 !== (1024 & e)) throw Error(o(163))
                        }
                        if (null !== (e = t.sibling)) {
                          e.return = t.return, jl = e;
                          break
                        }
                        jl = t.return
                      }
                }(e, t)
              } finally {
                pc = a, N.p = i, j.T = r
              }
            }
            zc = 1, yu(), vu(), bu()
          }
        }

        function yu() {
          if (1 === zc) {
            zc = 0;
            var e = Fc,
              t = Bc,
              n = 0 !== (13878 & t.flags);
            if (0 !== (13878 & t.subtreeFlags) || n) {
              n = j.T, j.T = null;
              var r = N.p;
              N.p = 2;
              var i = pc;
              pc |= 4;
              try {
                Kl(t, e);
                var s = mh,
                  o = rr(e.containerInfo),
                  a = s.focusedElem,
                  l = s.selectionRange;
                if (o !== a && a && a.ownerDocument && nr(a.ownerDocument.documentElement, a)) {
                  if (null !== l && ir(a)) {
                    var c = l.start,
                      u = l.end;
                    if (void 0 === u && (u = c), "selectionStart" in a) a.selectionStart = c, a.selectionEnd = Math.min(u, a.value.length);
                    else {
                      var h = a.ownerDocument || document,
                        d = h && h.defaultView || window;
                      if (d.getSelection) {
                        var f = d.getSelection(),
                          p = a.textContent.length,
                          g = Math.min(l.start, p),
                          m = void 0 === l.end ? g : Math.min(l.end, p);
                        !f.extend && g > m && (o = m, m = g, g = o);
                        var y = tr(a, g),
                          v = tr(a, m);
                        if (y && v && (1 !== f.rangeCount || f.anchorNode !== y.node || f.anchorOffset !== y.offset || f.focusNode !== v.node || f.focusOffset !== v.offset)) {
                          var b = h.createRange();
                          b.setStart(y.node, y.offset), f.removeAllRanges(), g > m ? (f.addRange(b), f.extend(v.node, v.offset)) : (b.setEnd(v.node, v.offset), f.addRange(b))
                        }
                      }
                    }
                  }
                  for (h = [], f = a; f = f.parentNode;) 1 === f.nodeType && h.push({
                    element: f,
                    left: f.scrollLeft,
                    top: f.scrollTop
                  });
                  for ("function" === typeof a.focus && a.focus(), a = 0; a < h.length; a++) {
                    var w = h[a];
                    w.element.scrollLeft = w.left, w.element.scrollTop = w.top
                  }
                }
                wd = !!gh, mh = gh = null
              } finally {
                pc = i, N.p = r, j.T = n
              }
            }
            e.current = t, zc = 2
          }
        }

        function vu() {
          if (2 === zc) {
            zc = 0;
            var e = Fc,
              t = Bc,
              n = 0 !== (8772 & t.flags);
            if (0 !== (8772 & t.subtreeFlags) || n) {
              n = j.T, j.T = null;
              var r = N.p;
              N.p = 2;
              var i = pc;
              pc |= 4;
              try {
                Nl(e, t.alternate, t)
              } finally {
                pc = i, N.p = r, j.T = n
              }
            }
            zc = 3
          }
        }

        function bu() {
          if (4 === zc || 3 === zc) {
            zc = 0, ae();
            var e = Fc,
              t = Bc,
              n = Uc,
              r = Vc;
            0 !== (10256 & t.subtreeFlags) || 0 !== (10256 & t.flags) ? zc = 5 : (zc = 0, Bc = Fc = null, wu(e, e.pendingLanes));
            var i = e.pendingLanes;
            if (0 === i && (Dc = null), De(n), t = t.stateNode, ve && "function" === typeof ve.onCommitFiberRoot) try {
              ve.onCommitFiberRoot(ye, t, void 0, 128 === (128 & t.current.flags))
            } catch (l) {}
            if (null !== r) {
              t = j.T, i = N.p, N.p = 2, j.T = null;
              try {
                for (var s = e.onRecoverableError, o = 0; o < r.length; o++) {
                  var a = r[o];
                  s(a.value, {
                    componentStack: a.stack
                  })
                }
              } finally {
                j.T = t, N.p = i
              }
            }
            0 !== (3 & Uc) && _u(), Iu(e), i = e.pendingLanes, 0 !== (261930 & n) && 0 !== (42 & i) ? e === Kc ? qc++ : (qc = 0, Kc = e) : qc = 0, Du(0, !1)
          }
        }

        function wu(e, t) {
          0 === (e.pooledCacheLanes &= t) && (null != (t = e.pooledCache) && (e.pooledCache = null, Ui(t)))
        }

        function _u() {
          return yu(), vu(), bu(), xu()
        }

        function xu() {
          if (5 !== zc) return !1;
          var e = Fc,
            t = Wc;
          Wc = 0;
          var n = De(Uc),
            r = j.T,
            i = N.p;
          try {
            N.p = 32 > n ? 32 : n, j.T = null, n = Hc, Hc = null;
            var s = Fc,
              a = Uc;
            if (zc = 0, Bc = Fc = null, Uc = 0, 0 !== (6 & pc)) throw Error(o(331));
            var l = pc;
            if (pc |= 4, cc(s.current), tc(s, s.current, a, n), pc = l, Du(0, !1), ve && "function" === typeof ve.onPostCommitFiberRoot) try {
              ve.onPostCommitFiberRoot(ye, s)
            } catch (c) {}
            return !0
          } finally {
            N.p = i, j.T = r, wu(e, t)
          }
        }

        function ku(e, t, n) {
          t = Yr(n, t), null !== (e = ws(e, t = Aa(e.stateNode, t, 2), 2)) && (Me(e, 2), Iu(e))
        }

        function Su(e, t, n) {
          if (3 === e.tag) ku(e, e, n);
          else
            for (; null !== t;) {
              if (3 === t.tag) {
                ku(t, e, n);
                break
              }
              if (1 === t.tag) {
                var r = t.stateNode;
                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Dc || !Dc.has(r))) {
                  e = Yr(n, e), null !== (r = ws(t, n = Ra(2), 2)) && (Ma(n, r, t, e), Me(r, 2), Iu(r));
                  break
                }
              }
              t = t.return
            }
        }

        function Eu(e, t, n) {
          var r = e.pingCache;
          if (null === r) {
            r = e.pingCache = new fc;
            var i = new Set;
            r.set(t, i)
          } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
          i.has(n) || (xc = !0, i.add(n), e = Tu.bind(null, e, t, n), t.then(e, e))
        }

        function Tu(e, t, n) {
          var r = e.pingCache;
          null !== r && r.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, gc === e && (yc & n) === n && (4 === Sc || 3 === Sc && (62914560 & yc) === yc && 300 > le() - Lc ? 0 === (2 & pc) && nu(e, 0) : Cc |= n, Pc === yc && (Pc = 0)), Iu(e)
        }

        function Cu(e, t) {
          0 === t && (t = Ae()), null !== (e = Lr(e, t)) && (Me(e, t), Iu(e))
        }

        function Ou(e) {
          var t = e.memoizedState,
            n = 0;
          null !== t && (n = t.retryLane), Cu(e, n)
        }

        function Pu(e, t) {
          var n = 0;
          switch (e.tag) {
            case 31:
            case 13:
              var r = e.stateNode,
                i = e.memoizedState;
              null !== i && (n = i.retryLane);
              break;
            case 19:
              r = e.stateNode;
              break;
            case 22:
              r = e.stateNode._retryCache;
              break;
            default:
              throw Error(o(314))
          }
          null !== r && r.delete(t), Cu(e, n)
        }
        var Au = null,
          Ru = null,
          Mu = !1,
          Lu = !1,
          ju = !1,
          Nu = 0;

        function Iu(e) {
          e !== Ru && null === e.next && (null === Ru ? Au = Ru = e : Ru = Ru.next = e), Lu = !0, Mu || (Mu = !0, Eh(function() {
            0 !== (6 & pc) ? ie(ue, zu) : Fu()
          }))
        }

        function Du(e, t) {
          if (!ju && Lu) {
            ju = !0;
            do {
              for (var n = !1, r = Au; null !== r;) {
                if (!t)
                  if (0 !== e) {
                    var i = r.pendingLanes;
                    if (0 === i) var s = 0;
                    else {
                      var o = r.suspendedLanes,
                        a = r.pingedLanes;
                      s = (1 << 31 - we(42 | e) + 1) - 1, s = 201326741 & (s &= i & ~(o & ~a)) ? 201326741 & s | 1 : s ? 2 | s : 0
                    }
                    0 !== s && (n = !0, Wu(r, s))
                  } else s = yc, 0 === (3 & (s = Ce(r, r === gc ? s : 0, null !== r.cancelPendingCommit || -1 !== r.timeoutHandle))) || Oe(r, s) || (n = !0, Wu(r, s));
                r = r.next
              }
            } while (n);
            ju = !1
          }
        }

        function zu() {
          Fu()
        }

        function Fu() {
          Lu = Mu = !1;
          var e = 0;
          0 !== Nu && function() {
            var e = window.event;
            if (e && "popstate" === e.type) return e !== _h && (_h = e, !0);
            return _h = null, !1
          }() && (e = Nu);
          for (var t = le(), n = null, r = Au; null !== r;) {
            var i = r.next,
              s = Bu(r, t);
            0 === s ? (r.next = null, null === n ? Au = i : n.next = i, null === i && (Ru = n)) : (n = r, (0 !== e || 0 !== (3 & s)) && (Lu = !0)), r = i
          }
          0 !== zc && 5 !== zc || Du(e, !1), 0 !== Nu && (Nu = 0)
        }

        function Bu(e, t) {
          for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = -62914561 & e.pendingLanes; 0 < s;) {
            var o = 31 - we(s),
              a = 1 << o,
              l = i[o]; - 1 === l ? 0 !== (a & n) && 0 === (a & r) || (i[o] = Pe(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a
          }
          if (n = yc, n = Ce(e, e === (t = gc) ? n : 0, null !== e.cancelPendingCommit || -1 !== e.timeoutHandle), r = e.callbackNode, 0 === n || e === t && (2 === vc || 9 === vc) || null !== e.cancelPendingCommit) return null !== r && null !== r && se(r), e.callbackNode = null, e.callbackPriority = 0;
          if (0 === (3 & n) || Oe(e, n)) {
            if ((t = n & -n) === e.callbackPriority) return t;
            switch (null !== r && se(r), De(n)) {
              case 2:
              case 8:
                n = he;
                break;
              case 32:
              default:
                n = de;
                break;
              case 268435456:
                n = pe
            }
            return r = Uu.bind(null, e), n = ie(n, r), e.callbackPriority = t, e.callbackNode = n, t
          }
          return null !== r && null !== r && se(r), e.callbackPriority = 2, e.callbackNode = null, 2
        }

        function Uu(e, t) {
          if (0 !== zc && 5 !== zc) return e.callbackNode = null, e.callbackPriority = 0, null;
          var n = e.callbackNode;
          if (_u() && e.callbackNode !== n) return null;
          var r = yc;
          return 0 === (r = Ce(e, e === gc ? r : 0, null !== e.cancelPendingCommit || -1 !== e.timeoutHandle)) ? null : (Gc(e, r, t), Bu(e, le()), null != e.callbackNode && e.callbackNode === n ? Uu.bind(null, e) : null)
        }

        function Wu(e, t) {
          if (_u()) return null;
          Gc(e, t, !0)
        }

        function Hu() {
          if (0 === Nu) {
            var e = Vi;
            0 === e && (e = ke, 0 === (261888 & (ke <<= 1)) && (ke = 256)), Nu = e
          }
          return Nu
        }

        function Vu(e) {
          return null == e || "symbol" === typeof e || "boolean" === typeof e ? null : "function" === typeof e ? e : Rt("" + e)
        }

        function qu(e, t) {
          var n = t.ownerDocument.createElement("input");
          return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e
        }
        for (var Ku = 0; Ku < Sr.length; Ku++) {
          var $u = Sr[Ku];
          Er($u.toLowerCase(), "on" + ($u[0].toUpperCase() + $u.slice(1)))
        }
        Er(mr, "onAnimationEnd"), Er(yr, "onAnimationIteration"), Er(vr, "onAnimationStart"), Er("dblclick", "onDoubleClick"), Er("focusin", "onFocus"), Er("focusout", "onBlur"), Er(br, "onTransitionRun"), Er(wr, "onTransitionStart"), Er(_r, "onTransitionCancel"), Er(xr, "onTransitionEnd"), it("onMouseEnter", ["mouseout", "mouseover"]), it("onMouseLeave", ["mouseout", "mouseover"]), it("onPointerEnter", ["pointerout", "pointerover"]), it("onPointerLeave", ["pointerout", "pointerover"]), rt("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), rt("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), rt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), rt("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), rt("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), rt("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var Yu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
          Ju = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Yu));

        function Gu(e, t) {
          t = 0 !== (4 & t);
          for (var n = 0; n < e.length; n++) {
            var r = e[n],
              i = r.event;
            r = r.listeners;
            e: {
              var s = void 0;
              if (t)
                for (var o = r.length - 1; 0 <= o; o--) {
                  var a = r[o],
                    l = a.instance,
                    c = a.currentTarget;
                  if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
                  s = a, i.currentTarget = c;
                  try {
                    s(i)
                  } catch (u) {
                    Tr(u)
                  }
                  i.currentTarget = null, s = l
                } else
                  for (o = 0; o < r.length; o++) {
                    if (l = (a = r[o]).instance, c = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
                    s = a, i.currentTarget = c;
                    try {
                      s(i)
                    } catch (u) {
                      Tr(u)
                    }
                    i.currentTarget = null, s = l
                  }
            }
          }
        }

        function Qu(e, t) {
          var n = t[Ve];
          void 0 === n && (n = t[Ve] = new Set);
          var r = e + "__bubble";
          n.has(r) || (th(t, e, 2, !1), n.add(r))
        }

        function Xu(e, t, n) {
          var r = 0;
          t && (r |= 4), th(n, e, r, t)
        }
        var Zu = "_reactListening" + Math.random().toString(36).slice(2);

        function eh(e) {
          if (!e[Zu]) {
            e[Zu] = !0, tt.forEach(function(t) {
              "selectionchange" !== t && (Ju.has(t) || Xu(t, !1, e), Xu(t, !0, e))
            });
            var t = 9 === e.nodeType ? e : e.ownerDocument;
            null === t || t[Zu] || (t[Zu] = !0, Xu("selectionchange", !1, t))
          }
        }

        function th(e, t, n, r) {
          switch (Cd(t)) {
            case 2:
              var i = _d;
              break;
            case 8:
              i = xd;
              break;
            default:
              i = kd
          }
          n = i.bind(null, t, n, e), i = void 0, !Wt || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
            capture: !0,
            passive: i
          }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
            passive: i
          }) : e.addEventListener(t, n, !1)
        }

        function nh(e, t, n, r, i) {
          var s = r;
          if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (;;) {
            if (null === r) return;
            var o = r.tag;
            if (3 === o || 4 === o) {
              var a = r.stateNode.containerInfo;
              if (a === i) break;
              if (4 === o)
                for (o = r.return; null !== o;) {
                  var c = o.tag;
                  if ((3 === c || 4 === c) && o.stateNode.containerInfo === i) return;
                  o = o.return
                }
              for (; null !== a;) {
                if (null === (o = Ge(a))) return;
                if (5 === (c = o.tag) || 6 === c || 26 === c || 27 === c) {
                  r = s = o;
                  continue e
                }
                a = a.parentNode
              }
            }
            r = r.return
          }
          Ft(function() {
            var r = s,
              i = jt(n),
              o = [];
            e: {
              var a = kr.get(e);
              if (void 0 !== a) {
                var c = nn,
                  u = e;
                switch (e) {
                  case "keypress":
                    if (0 === Yt(n)) break e;
                  case "keydown":
                  case "keyup":
                    c = vn;
                    break;
                  case "focusin":
                    u = "focus", c = cn;
                    break;
                  case "focusout":
                    u = "blur", c = cn;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    c = cn;
                    break;
                  case "click":
                    if (2 === n.button) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    c = an;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    c = ln;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    c = wn;
                    break;
                  case mr:
                  case yr:
                  case vr:
                    c = un;
                    break;
                  case xr:
                    c = _n;
                    break;
                  case "scroll":
                  case "scrollend":
                    c = sn;
                    break;
                  case "wheel":
                    c = xn;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    c = hn;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    c = bn;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    c = kn
                }
                var h = 0 !== (4 & t),
                  d = !h && ("scroll" === e || "scrollend" === e),
                  f = h ? null !== a ? a + "Capture" : null : a;
                h = [];
                for (var p, g = r; null !== g;) {
                  var m = g;
                  if (p = m.stateNode, 5 !== (m = m.tag) && 26 !== m && 27 !== m || null === p || null === f || null != (m = Bt(g, f)) && h.push(rh(g, m, p)), d) break;
                  g = g.return
                }
                0 < h.length && (a = new c(a, u, null, n, i), o.push({
                  event: a,
                  listeners: h
                }))
              }
            }
            if (0 === (7 & t)) {
              if (c = "mouseout" === e || "pointerout" === e, (!(a = "mouseover" === e || "pointerover" === e) || n === Lt || !(u = n.relatedTarget || n.fromElement) || !Ge(u) && !u[He]) && (c || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, c ? (c = r, null !== (u = (u = n.relatedTarget || n.toElement) ? Ge(u) : null) && (d = l(u), h = u.tag, u !== d || 5 !== h && 27 !== h && 6 !== h) && (u = null)) : (c = null, u = r), c !== u)) {
                if (h = an, m = "onMouseLeave", f = "onMouseEnter", g = "mouse", "pointerout" !== e && "pointerover" !== e || (h = bn, m = "onPointerLeave", f = "onPointerEnter", g = "pointer"), d = null == c ? a : Xe(c), p = null == u ? a : Xe(u), (a = new h(m, g + "leave", c, n, i)).target = d, a.relatedTarget = p, m = null, Ge(i) === r && ((h = new h(f, g + "enter", u, n, i)).target = p, h.relatedTarget = d, m = h), d = m, c && u) e: {
                  for (h = sh, g = u, p = 0, m = f = c; m; m = h(m)) p++;m = 0;
                  for (var y = g; y; y = h(y)) m++;
                  for (; 0 < p - m;) f = h(f),
                  p--;
                  for (; 0 < m - p;) g = h(g),
                  m--;
                  for (; p--;) {
                    if (f === g || null !== g && f === g.alternate) {
                      h = f;
                      break e
                    }
                    f = h(f), g = h(g)
                  }
                  h = null
                }
                else h = null;
                null !== c && oh(o, a, c, h, !1), null !== u && null !== d && oh(o, d, u, h, !0)
              }
              if ("select" === (c = (a = r ? Xe(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === c && "file" === a.type) var v = Un;
              else if (Nn(a))
                if (Wn) v = Qn;
                else {
                  v = Jn;
                  var b = Yn
                }
              else !(c = a.nodeName) || "input" !== c.toLowerCase() || "checkbox" !== a.type && "radio" !== a.type ? r && Ot(r.elementType) && (v = Un) : v = Gn;
              switch (v && (v = v(e, r)) ? In(o, v, n, i) : (b && b(e, a, r), "focusout" === e && r && "number" === a.type && null != r.memoizedProps.value && wt(a, "number", a.value)), b = r ? Xe(r) : window, e) {
                case "focusin":
                  (Nn(b) || "true" === b.contentEditable) && (or = b, ar = r, lr = null);
                  break;
                case "focusout":
                  lr = ar = or = null;
                  break;
                case "mousedown":
                  cr = !0;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  cr = !1, ur(o, n, i);
                  break;
                case "selectionchange":
                  if (sr) break;
                case "keydown":
                case "keyup":
                  ur(o, n, i)
              }
              var w;
              if (En) e: {
                switch (e) {
                  case "compositionstart":
                    var _ = "onCompositionStart";
                    break e;
                  case "compositionend":
                    _ = "onCompositionEnd";
                    break e;
                  case "compositionupdate":
                    _ = "onCompositionUpdate";
                    break e
                }
                _ = void 0
              }
              else Ln ? Rn(e, n) && (_ = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (_ = "onCompositionStart");
              _ && (On && "ko" !== n.locale && (Ln || "onCompositionStart" !== _ ? "onCompositionEnd" === _ && Ln && (w = $t()) : (qt = "value" in (Vt = i) ? Vt.value : Vt.textContent, Ln = !0)), 0 < (b = ih(r, _)).length && (_ = new dn(_, e, null, n, i), o.push({
                  event: _,
                  listeners: b
                }), w ? _.data = w : null !== (w = Mn(n)) && (_.data = w))), (w = Cn ? function(e, t) {
                  switch (e) {
                    case "compositionend":
                      return Mn(t);
                    case "keypress":
                      return 32 !== t.which ? null : (An = !0, Pn);
                    case "textInput":
                      return (e = t.data) === Pn && An ? null : e;
                    default:
                      return null
                  }
                }(e, n) : function(e, t) {
                  if (Ln) return "compositionend" === e || !En && Rn(e, t) ? (e = $t(), Kt = qt = Vt = null, Ln = !1, e) : null;
                  switch (e) {
                    case "paste":
                    default:
                      return null;
                    case "keypress":
                      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                        if (t.char && 1 < t.char.length) return t.char;
                        if (t.which) return String.fromCharCode(t.which)
                      }
                      return null;
                    case "compositionend":
                      return On && "ko" !== t.locale ? null : t.data
                  }
                }(e, n)) && (0 < (_ = ih(r, "onBeforeInput")).length && (b = new dn("onBeforeInput", "beforeinput", null, n, i), o.push({
                  event: b,
                  listeners: _
                }), b.data = w)),
                function(e, t, n, r, i) {
                  if ("submit" === t && n && n.stateNode === i) {
                    var s = Vu((i[We] || null).action),
                      o = r.submitter;
                    o && null !== (t = (t = o[We] || null) ? Vu(t.formAction) : o.getAttribute("formAction")) && (s = t, o = null);
                    var a = new nn("action", "action", null, r, i);
                    e.push({
                      event: a,
                      listeners: [{
                        instance: null,
                        listener: function() {
                          if (r.defaultPrevented) {
                            if (0 !== Nu) {
                              var e = o ? qu(i, o) : new FormData(i);
                              na(n, {
                                pending: !0,
                                data: e,
                                method: i.method,
                                action: s
                              }, null, e)
                            }
                          } else "function" === typeof s && (a.preventDefault(), e = o ? qu(i, o) : new FormData(i), na(n, {
                            pending: !0,
                            data: e,
                            method: i.method,
                            action: s
                          }, s, e))
                        },
                        currentTarget: i
                      }]
                    })
                  }
                }(o, e, r, n, i)
            }
            Gu(o, t)
          })
        }

        function rh(e, t, n) {
          return {
            instance: e,
            listener: t,
            currentTarget: n
          }
        }

        function ih(e, t) {
          for (var n = t + "Capture", r = []; null !== e;) {
            var i = e,
              s = i.stateNode;
            if (5 !== (i = i.tag) && 26 !== i && 27 !== i || null === s || (null != (i = Bt(e, n)) && r.unshift(rh(e, i, s)), null != (i = Bt(e, t)) && r.push(rh(e, i, s))), 3 === e.tag) return r;
            e = e.return
          }
          return []
        }

        function sh(e) {
          if (null === e) return null;
          do {
            e = e.return
          } while (e && 5 !== e.tag && 27 !== e.tag);
          return e || null
        }

        function oh(e, t, n, r, i) {
          for (var s = t._reactName, o = []; null !== n && n !== r;) {
            var a = n,
              l = a.alternate,
              c = a.stateNode;
            if (a = a.tag, null !== l && l === r) break;
            5 !== a && 26 !== a && 27 !== a || null === c || (l = c, i ? null != (c = Bt(n, s)) && o.unshift(rh(n, c, l)) : i || null != (c = Bt(n, s)) && o.push(rh(n, c, l))), n = n.return
          }
          0 !== o.length && e.push({
            event: t,
            listeners: o
          })
        }
        var ah = /\r\n?/g,
          lh = /\u0000|\uFFFD/g;

        function ch(e) {
          return ("string" === typeof e ? e : "" + e).replace(ah, "\n").replace(lh, "")
        }

        function uh(e, t) {
          return t = ch(t), ch(e) === t
        }

        function hh(e, t, n, r, i, s) {
          switch (n) {
            case "children":
              "string" === typeof r ? "body" === t || "textarea" === t && "" === r || St(e, r) : ("number" === typeof r || "bigint" === typeof r) && "body" !== t && St(e, "" + r);
              break;
            case "className":
              ct(e, "class", r);
              break;
            case "tabIndex":
              ct(e, "tabindex", r);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              ct(e, n, r);
              break;
            case "style":
              Ct(e, r, s);
              break;
            case "data":
              if ("object" !== t) {
                ct(e, "data", r);
                break
              }
            case "src":
            case "href":
              if ("" === r && ("a" !== t || "href" !== n)) {
                e.removeAttribute(n);
                break
              }
              if (null == r || "function" === typeof r || "symbol" === typeof r || "boolean" === typeof r) {
                e.removeAttribute(n);
                break
              }
              r = Rt("" + r), e.setAttribute(n, r);
              break;
            case "action":
            case "formAction":
              if ("function" === typeof r) {
                e.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
              }
              if ("function" === typeof s && ("formAction" === n ? ("input" !== t && hh(e, t, "name", i.name, i, null), hh(e, t, "formEncType", i.formEncType, i, null), hh(e, t, "formMethod", i.formMethod, i, null), hh(e, t, "formTarget", i.formTarget, i, null)) : (hh(e, t, "encType", i.encType, i, null), hh(e, t, "method", i.method, i, null), hh(e, t, "target", i.target, i, null))), null == r || "symbol" === typeof r || "boolean" === typeof r) {
                e.removeAttribute(n);
                break
              }
              r = Rt("" + r), e.setAttribute(n, r);
              break;
            case "onClick":
              null != r && (e.onclick = Mt);
              break;
            case "onScroll":
              null != r && Qu("scroll", e);
              break;
            case "onScrollEnd":
              null != r && Qu("scrollend", e);
              break;
            case "dangerouslySetInnerHTML":
              if (null != r) {
                if ("object" !== typeof r || !("__html" in r)) throw Error(o(61));
                if (null != (n = r.__html)) {
                  if (null != i.children) throw Error(o(60));
                  e.innerHTML = n
                }
              }
              break;
            case "multiple":
              e.multiple = r && "function" !== typeof r && "symbol" !== typeof r;
              break;
            case "muted":
              e.muted = r && "function" !== typeof r && "symbol" !== typeof r;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == r || "function" === typeof r || "boolean" === typeof r || "symbol" === typeof r) {
                e.removeAttribute("xlink:href");
                break
              }
              n = Rt("" + r), e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != r && "function" !== typeof r && "symbol" !== typeof r ? e.setAttribute(n, "" + r) : e.removeAttribute(n);
              break;
            case "inert":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              r && "function" !== typeof r && "symbol" !== typeof r ? e.setAttribute(n, "") : e.removeAttribute(n);
              break;
            case "capture":
            case "download":
              !0 === r ? e.setAttribute(n, "") : !1 !== r && null != r && "function" !== typeof r && "symbol" !== typeof r ? e.setAttribute(n, r) : e.removeAttribute(n);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != r && "function" !== typeof r && "symbol" !== typeof r && !isNaN(r) && 1 <= r ? e.setAttribute(n, r) : e.removeAttribute(n);
              break;
            case "rowSpan":
            case "start":
              null == r || "function" === typeof r || "symbol" === typeof r || isNaN(r) ? e.removeAttribute(n) : e.setAttribute(n, r);
              break;
            case "popover":
              Qu("beforetoggle", e), Qu("toggle", e), lt(e, "popover", r);
              break;
            case "xlinkActuate":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:actuate", r);
              break;
            case "xlinkArcrole":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", r);
              break;
            case "xlinkRole":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:role", r);
              break;
            case "xlinkShow":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:show", r);
              break;
            case "xlinkTitle":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:title", r);
              break;
            case "xlinkType":
              ut(e, "http://www.w3.org/1999/xlink", "xlink:type", r);
              break;
            case "xmlBase":
              ut(e, "http://www.w3.org/XML/1998/namespace", "xml:base", r);
              break;
            case "xmlLang":
              ut(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", r);
              break;
            case "xmlSpace":
              ut(e, "http://www.w3.org/XML/1998/namespace", "xml:space", r);
              break;
            case "is":
              lt(e, "is", r);
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              (!(2 < n.length) || "o" !== n[0] && "O" !== n[0] || "n" !== n[1] && "N" !== n[1]) && lt(e, n = Pt.get(n) || n, r)
          }
        }

        function dh(e, t, n, r, i, s) {
          switch (n) {
            case "style":
              Ct(e, r, s);
              break;
            case "dangerouslySetInnerHTML":
              if (null != r) {
                if ("object" !== typeof r || !("__html" in r)) throw Error(o(61));
                if (null != (n = r.__html)) {
                  if (null != i.children) throw Error(o(60));
                  e.innerHTML = n
                }
              }
              break;
            case "children":
              "string" === typeof r ? St(e, r) : ("number" === typeof r || "bigint" === typeof r) && St(e, "" + r);
              break;
            case "onScroll":
              null != r && Qu("scroll", e);
              break;
            case "onScrollEnd":
              null != r && Qu("scrollend", e);
              break;
            case "onClick":
              null != r && (e.onclick = Mt);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
            case "innerText":
            case "textContent":
              break;
            default:
              nt.hasOwnProperty(n) || ("o" !== n[0] || "n" !== n[1] || (i = n.endsWith("Capture"), t = n.slice(2, i ? n.length - 7 : void 0), "function" === typeof(s = null != (s = e[We] || null) ? s[n] : null) && e.removeEventListener(t, s, i), "function" !== typeof r) ? n in e ? e[n] = r : !0 === r ? e.setAttribute(n, "") : lt(e, n, r) : ("function" !== typeof s && null !== s && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, r, i)))
          }
        }

        function fh(e, t, n) {
          switch (t) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              Qu("error", e), Qu("load", e);
              var r, i = !1,
                s = !1;
              for (r in n)
                if (n.hasOwnProperty(r)) {
                  var a = n[r];
                  if (null != a) switch (r) {
                    case "src":
                      i = !0;
                      break;
                    case "srcSet":
                      s = !0;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(o(137, t));
                    default:
                      hh(e, t, r, a, n, null)
                  }
                } return s && hh(e, t, "srcSet", n.srcSet, n, null), void(i && hh(e, t, "src", n.src, n, null));
            case "input":
              Qu("invalid", e);
              var l = r = a = s = null,
                c = null,
                u = null;
              for (i in n)
                if (n.hasOwnProperty(i)) {
                  var h = n[i];
                  if (null != h) switch (i) {
                    case "name":
                      s = h;
                      break;
                    case "type":
                      a = h;
                      break;
                    case "checked":
                      c = h;
                      break;
                    case "defaultChecked":
                      u = h;
                      break;
                    case "value":
                      r = h;
                      break;
                    case "defaultValue":
                      l = h;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != h) throw Error(o(137, t));
                      break;
                    default:
                      hh(e, t, i, h, n, null)
                  }
                } return void bt(e, r, l, c, u, a, s, !1);
            case "select":
              for (s in Qu("invalid", e), i = a = r = null, n)
                if (n.hasOwnProperty(s) && null != (l = n[s])) switch (s) {
                  case "value":
                    r = l;
                    break;
                  case "defaultValue":
                    a = l;
                    break;
                  case "multiple":
                    i = l;
                  default:
                    hh(e, t, s, l, n, null)
                }
              return t = r, n = a, e.multiple = !!i, void(null != t ? _t(e, !!i, t, !1) : null != n && _t(e, !!i, n, !0));
            case "textarea":
              for (a in Qu("invalid", e), r = s = i = null, n)
                if (n.hasOwnProperty(a) && null != (l = n[a])) switch (a) {
                  case "value":
                    i = l;
                    break;
                  case "defaultValue":
                    s = l;
                    break;
                  case "children":
                    r = l;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != l) throw Error(o(91));
                    break;
                  default:
                    hh(e, t, a, l, n, null)
                }
              return void kt(e, i, s, r);
            case "option":
              for (c in n)
                if (n.hasOwnProperty(c) && null != (i = n[c]))
                  if ("selected" === c) e.selected = i && "function" !== typeof i && "symbol" !== typeof i;
                  else hh(e, t, c, i, n, null);
              return;
            case "dialog":
              Qu("beforetoggle", e), Qu("toggle", e), Qu("cancel", e), Qu("close", e);
              break;
            case "iframe":
            case "object":
              Qu("load", e);
              break;
            case "video":
            case "audio":
              for (i = 0; i < Yu.length; i++) Qu(Yu[i], e);
              break;
            case "image":
              Qu("error", e), Qu("load", e);
              break;
            case "details":
              Qu("toggle", e);
              break;
            case "embed":
            case "source":
            case "link":
              Qu("error", e), Qu("load", e);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (u in n)
                if (n.hasOwnProperty(u) && null != (i = n[u])) switch (u) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(o(137, t));
                  default:
                    hh(e, t, u, i, n, null)
                }
              return;
            default:
              if (Ot(t)) {
                for (h in n) n.hasOwnProperty(h) && (void 0 !== (i = n[h]) && dh(e, t, h, i, n, void 0));
                return
              }
          }
          for (l in n) n.hasOwnProperty(l) && (null != (i = n[l]) && hh(e, t, l, i, n, null))
        }

        function ph(e) {
          switch (e) {
            case "css":
            case "script":
            case "font":
            case "img":
            case "image":
            case "input":
            case "link":
              return !0;
            default:
              return !1
          }
        }
        var gh = null,
          mh = null;

        function yh(e) {
          return 9 === e.nodeType ? e : e.ownerDocument
        }

        function vh(e) {
          switch (e) {
            case "http://www.w3.org/2000/svg":
              return 1;
            case "http://www.w3.org/1998/Math/MathML":
              return 2;
            default:
              return 0
          }
        }

        function bh(e, t) {
          if (0 === e) switch (t) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0
          }
          return 1 === e && "foreignObject" === t ? 0 : e
        }

        function wh(e, t) {
          return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "bigint" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
        }
        var _h = null;
        var xh = "function" === typeof setTimeout ? setTimeout : void 0,
          kh = "function" === typeof clearTimeout ? clearTimeout : void 0,
          Sh = "function" === typeof Promise ? Promise : void 0,
          Eh = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Sh ? function(e) {
            return Sh.resolve(null).then(e).catch(Th)
          } : xh;

        function Th(e) {
          setTimeout(function() {
            throw e
          })
        }

        function Ch(e) {
          return "head" === e
        }

        function Oh(e, t) {
          var n = t,
            r = 0;
          do {
            var i = n.nextSibling;
            if (e.removeChild(n), i && 8 === i.nodeType)
              if ("/$" === (n = i.data) || "/&" === n) {
                if (0 === r) return e.removeChild(i), void qd(t);
                r--
              } else if ("$" === n || "$?" === n || "$~" === n || "$!" === n || "&" === n) r++;
            else if ("html" === n) Fh(e.ownerDocument.documentElement);
            else if ("head" === n) {
              Fh(n = e.ownerDocument.head);
              for (var s = n.firstChild; s;) {
                var o = s.nextSibling,
                  a = s.nodeName;
                s[Ye] || "SCRIPT" === a || "STYLE" === a || "LINK" === a && "stylesheet" === s.rel.toLowerCase() || n.removeChild(s), s = o
              }
            } else "body" === n && Fh(e.ownerDocument.body);
            n = i
          } while (n);
          qd(t)
        }

        function Ph(e, t) {
          var n = e;
          e = 0;
          do {
            var r = n.nextSibling;
            if (1 === n.nodeType ? t ? (n._stashedDisplay = n.style.display, n.style.display = "none") : (n.style.display = n._stashedDisplay || "", "" === n.getAttribute("style") && n.removeAttribute("style")) : 3 === n.nodeType && (t ? (n._stashedText = n.nodeValue, n.nodeValue = "") : n.nodeValue = n._stashedText || ""), r && 8 === r.nodeType)
              if ("/$" === (n = r.data)) {
                if (0 === e) break;
                e--
              } else "$" !== n && "$?" !== n && "$~" !== n && "$!" !== n || e++;
            n = r
          } while (n)
        }

        function Ah(e) {
          var t = e.firstChild;
          for (t && 10 === t.nodeType && (t = t.nextSibling); t;) {
            var n = t;
            switch (t = t.nextSibling, n.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                Ah(n), Je(n);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === n.rel.toLowerCase()) continue
            }
            e.removeChild(n)
          }
        }

        function Rh(e, t) {
          for (; 8 !== e.nodeType;) {
            if ((1 !== e.nodeType || "INPUT" !== e.nodeName || "hidden" !== e.type) && !t) return null;
            if (null === (e = jh(e.nextSibling))) return null
          }
          return e
        }

        function Mh(e) {
          return "$?" === e.data || "$~" === e.data
        }

        function Lh(e) {
          return "$!" === e.data || "$?" === e.data && "loading" !== e.ownerDocument.readyState
        }

        function jh(e) {
          for (; null != e; e = e.nextSibling) {
            var t = e.nodeType;
            if (1 === t || 3 === t) break;
            if (8 === t) {
              if ("$" === (t = e.data) || "$!" === t || "$?" === t || "$~" === t || "&" === t || "F!" === t || "F" === t) break;
              if ("/$" === t || "/&" === t) return null
            }
          }
          return e
        }
        var Nh = null;

        function Ih(e) {
          e = e.nextSibling;
          for (var t = 0; e;) {
            if (8 === e.nodeType) {
              var n = e.data;
              if ("/$" === n || "/&" === n) {
                if (0 === t) return jh(e.nextSibling);
                t--
              } else "$" !== n && "$!" !== n && "$?" !== n && "$~" !== n && "&" !== n || t++
            }
            e = e.nextSibling
          }
          return null
        }

        function Dh(e) {
          e = e.previousSibling;
          for (var t = 0; e;) {
            if (8 === e.nodeType) {
              var n = e.data;
              if ("$" === n || "$!" === n || "$?" === n || "$~" === n || "&" === n) {
                if (0 === t) return e;
                t--
              } else "/$" !== n && "/&" !== n || t++
            }
            e = e.previousSibling
          }
          return null
        }

        function zh(e, t, n) {
          switch (t = yh(n), e) {
            case "html":
              if (!(e = t.documentElement)) throw Error(o(452));
              return e;
            case "head":
              if (!(e = t.head)) throw Error(o(453));
              return e;
            case "body":
              if (!(e = t.body)) throw Error(o(454));
              return e;
            default:
              throw Error(o(451))
          }
        }

        function Fh(e) {
          for (var t = e.attributes; t.length;) e.removeAttributeNode(t[0]);
          Je(e)
        }
        var Bh = new Map,
          Uh = new Set;

        function Wh(e) {
          return "function" === typeof e.getRootNode ? e.getRootNode() : 9 === e.nodeType ? e : e.ownerDocument
        }
        var Hh = N.d;
        N.d = {
          f: function() {
            var e = Hh.f(),
              t = eu();
            return e || t
          },
          r: function(e) {
            var t = Qe(e);
            null !== t && 5 === t.tag && "form" === t.type ? ia(t) : Hh.r(e)
          },
          D: function(e) {
            Hh.D(e), qh("dns-prefetch", e, null)
          },
          C: function(e, t) {
            Hh.C(e, t), qh("preconnect", e, t)
          },
          L: function(e, t, n) {
            Hh.L(e, t, n);
            var r = Vh;
            if (r && e && t) {
              var i = 'link[rel="preload"][as="' + yt(t) + '"]';
              "image" === t && n && n.imageSrcSet ? (i += '[imagesrcset="' + yt(n.imageSrcSet) + '"]', "string" === typeof n.imageSizes && (i += '[imagesizes="' + yt(n.imageSizes) + '"]')) : i += '[href="' + yt(e) + '"]';
              var s = i;
              switch (t) {
                case "style":
                  s = $h(e);
                  break;
                case "script":
                  s = Gh(e)
              }
              Bh.has(s) || (e = f({
                rel: "preload",
                href: "image" === t && n && n.imageSrcSet ? void 0 : e,
                as: t
              }, n), Bh.set(s, e), null !== r.querySelector(i) || "style" === t && r.querySelector(Yh(s)) || "script" === t && r.querySelector(Qh(s)) || (fh(t = r.createElement("link"), "link", e), et(t), r.head.appendChild(t)))
            }
          },
          m: function(e, t) {
            Hh.m(e, t);
            var n = Vh;
            if (n && e) {
              var r = t && "string" === typeof t.as ? t.as : "script",
                i = 'link[rel="modulepreload"][as="' + yt(r) + '"][href="' + yt(e) + '"]',
                s = i;
              switch (r) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  s = Gh(e)
              }
              if (!Bh.has(s) && (e = f({
                  rel: "modulepreload",
                  href: e
                }, t), Bh.set(s, e), null === n.querySelector(i))) {
                switch (r) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (n.querySelector(Qh(s))) return
                }
                fh(r = n.createElement("link"), "link", e), et(r), n.head.appendChild(r)
              }
            }
          },
          X: function(e, t) {
            Hh.X(e, t);
            var n = Vh;
            if (n && e) {
              var r = Ze(n).hoistableScripts,
                i = Gh(e),
                s = r.get(i);
              s || ((s = n.querySelector(Qh(i))) || (e = f({
                src: e,
                async: !0
              }, t), (t = Bh.get(i)) && td(e, t), et(s = n.createElement("script")), fh(s, "link", e), n.head.appendChild(s)), s = {
                type: "script",
                instance: s,
                count: 1,
                state: null
              }, r.set(i, s))
            }
          },
          S: function(e, t, n) {
            Hh.S(e, t, n);
            var r = Vh;
            if (r && e) {
              var i = Ze(r).hoistableStyles,
                s = $h(e);
              t = t || "default";
              var o = i.get(s);
              if (!o) {
                var a = {
                  loading: 0,
                  preload: null
                };
                if (o = r.querySelector(Yh(s))) a.loading = 5;
                else {
                  e = f({
                    rel: "stylesheet",
                    href: e,
                    "data-precedence": t
                  }, n), (n = Bh.get(s)) && ed(e, n);
                  var l = o = r.createElement("link");
                  et(l), fh(l, "link", e), l._p = new Promise(function(e, t) {
                    l.onload = e, l.onerror = t
                  }), l.addEventListener("load", function() {
                    a.loading |= 1
                  }), l.addEventListener("error", function() {
                    a.loading |= 2
                  }), a.loading |= 4, Zh(o, t, r)
                }
                o = {
                  type: "stylesheet",
                  instance: o,
                  count: 1,
                  state: a
                }, i.set(s, o)
              }
            }
          },
          M: function(e, t) {
            Hh.M(e, t);
            var n = Vh;
            if (n && e) {
              var r = Ze(n).hoistableScripts,
                i = Gh(e),
                s = r.get(i);
              s || ((s = n.querySelector(Qh(i))) || (e = f({
                src: e,
                async: !0,
                type: "module"
              }, t), (t = Bh.get(i)) && td(e, t), et(s = n.createElement("script")), fh(s, "link", e), n.head.appendChild(s)), s = {
                type: "script",
                instance: s,
                count: 1,
                state: null
              }, r.set(i, s))
            }
          }
        };
        var Vh = "undefined" === typeof document ? null : document;

        function qh(e, t, n) {
          var r = Vh;
          if (r && "string" === typeof t && t) {
            var i = yt(t);
            i = 'link[rel="' + e + '"][href="' + i + '"]', "string" === typeof n && (i += '[crossorigin="' + n + '"]'), Uh.has(i) || (Uh.add(i), e = {
              rel: e,
              crossOrigin: n,
              href: t
            }, null === r.querySelector(i) && (fh(t = r.createElement("link"), "link", e), et(t), r.head.appendChild(t)))
          }
        }

        function Kh(e, t, n, r) {
          var i, s, a, l, c = (c = K.current) ? Wh(c) : null;
          if (!c) throw Error(o(446));
          switch (e) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof n.precedence && "string" === typeof n.href ? (t = $h(n.href), (r = (n = Ze(c).hoistableStyles).get(t)) || (r = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, n.set(t, r)), r) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
              };
            case "link":
              if ("stylesheet" === n.rel && "string" === typeof n.href && "string" === typeof n.precedence) {
                e = $h(n.href);
                var u = Ze(c).hoistableStyles,
                  h = u.get(e);
                if (h || (c = c.ownerDocument || c, h = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                      loading: 0,
                      preload: null
                    }
                  }, u.set(e, h), (u = c.querySelector(Yh(e))) && !u._p && (h.instance = u, h.state.loading = 5), Bh.has(e) || (n = {
                    rel: "preload",
                    as: "style",
                    href: n.href,
                    crossOrigin: n.crossOrigin,
                    integrity: n.integrity,
                    media: n.media,
                    hrefLang: n.hrefLang,
                    referrerPolicy: n.referrerPolicy
                  }, Bh.set(e, n), u || (i = c, s = e, a = n, l = h.state, i.querySelector('link[rel="preload"][as="style"][' + s + "]") ? l.loading = 1 : (s = i.createElement("link"), l.preload = s, s.addEventListener("load", function() {
                    return l.loading |= 1
                  }), s.addEventListener("error", function() {
                    return l.loading |= 2
                  }), fh(s, "link", a), et(s), i.head.appendChild(s))))), t && null === r) throw Error(o(528, ""));
                return h
              }
              if (t && null !== r) throw Error(o(529, ""));
              return null;
            case "script":
              return t = n.async, "string" === typeof(n = n.src) && t && "function" !== typeof t && "symbol" !== typeof t ? (t = Gh(n), (r = (n = Ze(c).hoistableScripts).get(t)) || (r = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, n.set(t, r)), r) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
              };
            default:
              throw Error(o(444, e))
          }
        }

        function $h(e) {
          return 'href="' + yt(e) + '"'
        }

        function Yh(e) {
          return 'link[rel="stylesheet"][' + e + "]"
        }

        function Jh(e) {
          return f({}, e, {
            "data-precedence": e.precedence,
            precedence: null
          })
        }

        function Gh(e) {
          return '[src="' + yt(e) + '"]'
        }

        function Qh(e) {
          return "script[async]" + e
        }

        function Xh(e, t, n) {
          if (t.count++, null === t.instance) switch (t.type) {
            case "style":
              var r = e.querySelector('style[data-href~="' + yt(n.href) + '"]');
              if (r) return t.instance = r, et(r), r;
              var i = f({}, n, {
                "data-href": n.href,
                "data-precedence": n.precedence,
                href: null,
                precedence: null
              });
              return et(r = (e.ownerDocument || e).createElement("style")), fh(r, "style", i), Zh(r, n.precedence, e), t.instance = r;
            case "stylesheet":
              i = $h(n.href);
              var s = e.querySelector(Yh(i));
              if (s) return t.state.loading |= 4, t.instance = s, et(s), s;
              r = Jh(n), (i = Bh.get(i)) && ed(r, i), et(s = (e.ownerDocument || e).createElement("link"));
              var a = s;
              return a._p = new Promise(function(e, t) {
                a.onload = e, a.onerror = t
              }), fh(s, "link", r), t.state.loading |= 4, Zh(s, n.precedence, e), t.instance = s;
            case "script":
              return s = Gh(n.src), (i = e.querySelector(Qh(s))) ? (t.instance = i, et(i), i) : (r = n, (i = Bh.get(s)) && td(r = f({}, n), i), et(i = (e = e.ownerDocument || e).createElement("script")), fh(i, "link", r), e.head.appendChild(i), t.instance = i);
            case "void":
              return null;
            default:
              throw Error(o(443, t.type))
          } else "stylesheet" === t.type && 0 === (4 & t.state.loading) && (r = t.instance, t.state.loading |= 4, Zh(r, n.precedence, e));
          return t.instance
        }

        function Zh(e, t, n) {
          for (var r = n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), i = r.length ? r[r.length - 1] : null, s = i, o = 0; o < r.length; o++) {
            var a = r[o];
            if (a.dataset.precedence === t) s = a;
            else if (s !== i) break
          }
          s ? s.parentNode.insertBefore(e, s.nextSibling) : (t = 9 === n.nodeType ? n.head : n).insertBefore(e, t.firstChild)
        }

        function ed(e, t) {
          null == e.crossOrigin && (e.crossOrigin = t.crossOrigin), null == e.referrerPolicy && (e.referrerPolicy = t.referrerPolicy), null == e.title && (e.title = t.title)
        }

        function td(e, t) {
          null == e.crossOrigin && (e.crossOrigin = t.crossOrigin), null == e.referrerPolicy && (e.referrerPolicy = t.referrerPolicy), null == e.integrity && (e.integrity = t.integrity)
        }
        var nd = null;

        function rd(e, t, n) {
          if (null === nd) {
            var r = new Map,
              i = nd = new Map;
            i.set(n, r)
          } else(r = (i = nd).get(n)) || (r = new Map, i.set(n, r));
          if (r.has(e)) return r;
          for (r.set(e, null), n = n.getElementsByTagName(e), i = 0; i < n.length; i++) {
            var s = n[i];
            if (!(s[Ye] || s[Ue] || "link" === e && "stylesheet" === s.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== s.namespaceURI) {
              var o = s.getAttribute(t) || "";
              o = e + o;
              var a = r.get(o);
              a ? a.push(s) : r.set(o, [s])
            }
          }
          return r
        }

        function id(e, t, n) {
          (e = e.ownerDocument || e).head.insertBefore(n, "title" === t ? e.querySelector("head > title") : null)
        }

        function sd(e) {
          return "stylesheet" !== e.type || 0 !== (3 & e.state.loading)
        }
        var od = 0;

        function ad() {
          if (this.count--, 0 === this.count && (0 === this.imgCount || !this.waitingForImages))
            if (this.stylesheets) cd(this, this.stylesheets);
            else if (this.unsuspend) {
            var e = this.unsuspend;
            this.unsuspend = null, e()
          }
        }
        var ld = null;

        function cd(e, t) {
          e.stylesheets = null, null !== e.unsuspend && (e.count++, ld = new Map, t.forEach(ud, e), ld = null, ad.call(e))
        }

        function ud(e, t) {
          if (!(4 & t.state.loading)) {
            var n = ld.get(e);
            if (n) var r = n.get(null);
            else {
              n = new Map, ld.set(e, n);
              for (var i = e.querySelectorAll("link[data-precedence],style[data-precedence]"), s = 0; s < i.length; s++) {
                var o = i[s];
                "LINK" !== o.nodeName && "not all" === o.getAttribute("media") || (n.set(o.dataset.precedence, o), r = o)
              }
              r && n.set(null, r)
            }
            o = (i = t.instance).getAttribute("data-precedence"), (s = n.get(o) || r) === r && n.set(null, i), n.set(o, i), this.count++, r = ad.bind(this), i.addEventListener("load", r), i.addEventListener("error", r), s ? s.parentNode.insertBefore(i, s.nextSibling) : (e = 9 === e.nodeType ? e.head : e).insertBefore(i, e.firstChild), t.state.loading |= 4
          }
        }
        var hd = {
          $$typeof: _,
          Provider: null,
          Consumer: null,
          _currentValue: I,
          _currentValue2: I,
          _threadCount: 0
        };

        function dd(e, t, n, r, i, s, o, a, l) {
          this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Re(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Re(0), this.hiddenUpdates = Re(null), this.identifierPrefix = r, this.onUncaughtError = i, this.onCaughtError = s, this.onRecoverableError = o, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = l, this.incompleteTransitions = new Map
        }

        function fd(e, t, n, r, i, s, o, a, l, c, u, h) {
          return e = new dd(e, t, n, o, l, c, u, h, a), t = 1, !0 === s && (t |= 24), s = zr(3, null, null, t), e.current = s, s.stateNode = e, (t = Bi()).refCount++, e.pooledCache = t, t.refCount++, s.memoizedState = {
            element: r,
            isDehydrated: n,
            cache: t
          }, ys(s), e
        }

        function pd(e) {
          return e ? e = Ir : Ir
        }

        function gd(e, t, n, r, i, s) {
          i = pd(i), null === r.context ? r.context = i : r.pendingContext = i, (r = bs(t)).payload = {
            element: n
          }, null !== (s = void 0 === s ? null : s) && (r.callback = s), null !== (n = ws(e, r, t)) && (Jc(n, 0, t), _s(n, e, t))
        }

        function md(e, t) {
          if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
            var n = e.retryLane;
            e.retryLane = 0 !== n && n < t ? n : t
          }
        }

        function yd(e, t) {
          md(e, t), (e = e.alternate) && md(e, t)
        }

        function vd(e) {
          if (13 === e.tag || 31 === e.tag) {
            var t = Lr(e, 67108864);
            null !== t && Jc(t, 0, 67108864), yd(e, 67108864)
          }
        }

        function bd(e) {
          if (13 === e.tag || 31 === e.tag) {
            var t = $c(),
              n = Lr(e, t = Ie(t));
            null !== n && Jc(n, 0, t), yd(e, t)
          }
        }
        var wd = !0;

        function _d(e, t, n, r) {
          var i = j.T;
          j.T = null;
          var s = N.p;
          try {
            N.p = 2, kd(e, t, n, r)
          } finally {
            N.p = s, j.T = i
          }
        }

        function xd(e, t, n, r) {
          var i = j.T;
          j.T = null;
          var s = N.p;
          try {
            N.p = 8, kd(e, t, n, r)
          } finally {
            N.p = s, j.T = i
          }
        }

        function kd(e, t, n, r) {
          if (wd) {
            var i = Sd(r);
            if (null === i) nh(e, t, r, Ed, n), Id(e, r);
            else if (function(e, t, n, r, i) {
                switch (t) {
                  case "focusin":
                    return Pd = Dd(Pd, e, t, n, r, i), !0;
                  case "dragenter":
                    return Ad = Dd(Ad, e, t, n, r, i), !0;
                  case "mouseover":
                    return Rd = Dd(Rd, e, t, n, r, i), !0;
                  case "pointerover":
                    var s = i.pointerId;
                    return Md.set(s, Dd(Md.get(s) || null, e, t, n, r, i)), !0;
                  case "gotpointercapture":
                    return s = i.pointerId, Ld.set(s, Dd(Ld.get(s) || null, e, t, n, r, i)), !0
                }
                return !1
              }(i, e, t, n, r)) r.stopPropagation();
            else if (Id(e, r), 4 & t && -1 < Nd.indexOf(e)) {
              for (; null !== i;) {
                var s = Qe(i);
                if (null !== s) switch (s.tag) {
                  case 3:
                    if ((s = s.stateNode).current.memoizedState.isDehydrated) {
                      var o = Te(s.pendingLanes);
                      if (0 !== o) {
                        var a = s;
                        for (a.pendingLanes |= 2, a.entangledLanes |= 2; o;) {
                          var l = 1 << 31 - we(o);
                          a.entanglements[1] |= l, o &= ~l
                        }
                        Iu(s), 0 === (6 & pc) && (Nc = le() + 500, Du(0, !1))
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    null !== (a = Lr(s, 2)) && Jc(a, 0, 2), eu(), yd(s, 2)
                }
                if (null === (s = Sd(r)) && nh(e, t, r, Ed, n), s === i) break;
                i = s
              }
              null !== i && r.stopPropagation()
            } else nh(e, t, r, null, n)
          }
        }

        function Sd(e) {
          return Td(e = jt(e))
        }
        var Ed = null;

        function Td(e) {
          if (Ed = null, null !== (e = Ge(e))) {
            var t = l(e);
            if (null === t) e = null;
            else {
              var n = t.tag;
              if (13 === n) {
                if (null !== (e = c(t))) return e;
                e = null
              } else if (31 === n) {
                if (null !== (e = u(t))) return e;
                e = null
              } else if (3 === n) {
                if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                e = null
              } else t !== e && (e = null)
            }
          }
          return Ed = e, null
        }

        function Cd(e) {
          switch (e) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 2;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 8;
            case "message":
              switch (ce()) {
                case ue:
                  return 2;
                case he:
                  return 8;
                case de:
                case fe:
                  return 32;
                case pe:
                  return 268435456;
                default:
                  return 32
              }
            default:
              return 32
          }
        }
        var Od = !1,
          Pd = null,
          Ad = null,
          Rd = null,
          Md = new Map,
          Ld = new Map,
          jd = [],
          Nd = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");

        function Id(e, t) {
          switch (e) {
            case "focusin":
            case "focusout":
              Pd = null;
              break;
            case "dragenter":
            case "dragleave":
              Ad = null;
              break;
            case "mouseover":
            case "mouseout":
              Rd = null;
              break;
            case "pointerover":
            case "pointerout":
              Md.delete(t.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              Ld.delete(t.pointerId)
          }
        }

        function Dd(e, t, n, r, i, s) {
          return null === e || e.nativeEvent !== s ? (e = {
            blockedOn: t,
            domEventName: n,
            eventSystemFlags: r,
            nativeEvent: s,
            targetContainers: [i]
          }, null !== t && (null !== (t = Qe(t)) && vd(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
        }

        function zd(e) {
          var t = Ge(e.target);
          if (null !== t) {
            var n = l(t);
            if (null !== n)
              if (13 === (t = n.tag)) {
                if (null !== (t = c(n))) return e.blockedOn = t, void Fe(e.priority, function() {
                  bd(n)
                })
              } else if (31 === t) {
              if (null !== (t = u(n))) return e.blockedOn = t, void Fe(e.priority, function() {
                bd(n)
              })
            } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void(e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
          }
          e.blockedOn = null
        }

        function Fd(e) {
          if (null !== e.blockedOn) return !1;
          for (var t = e.targetContainers; 0 < t.length;) {
            var n = Sd(e.nativeEvent);
            if (null !== n) return null !== (t = Qe(n)) && vd(t), e.blockedOn = n, !1;
            var r = new(n = e.nativeEvent).constructor(n.type, n);
            Lt = r, n.target.dispatchEvent(r), Lt = null, t.shift()
          }
          return !0
        }

        function Bd(e, t, n) {
          Fd(e) && n.delete(t)
        }

        function Ud() {
          Od = !1, null !== Pd && Fd(Pd) && (Pd = null), null !== Ad && Fd(Ad) && (Ad = null), null !== Rd && Fd(Rd) && (Rd = null), Md.forEach(Bd), Ld.forEach(Bd)
        }

        function Wd(e, t) {
          e.blockedOn === t && (e.blockedOn = null, Od || (Od = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ud)))
        }
        var Hd = null;

        function Vd(e) {
          Hd !== e && (Hd = e, r.unstable_scheduleCallback(r.unstable_NormalPriority, function() {
            Hd === e && (Hd = null);
            for (var t = 0; t < e.length; t += 3) {
              var n = e[t],
                r = e[t + 1],
                i = e[t + 2];
              if ("function" !== typeof r) {
                if (null === Td(r || n)) continue;
                break
              }
              var s = Qe(n);
              null !== s && (e.splice(t, 3), t -= 3, na(s, {
                pending: !0,
                data: i,
                method: n.method,
                action: r
              }, r, i))
            }
          }))
        }

        function qd(e) {
          function t(t) {
            return Wd(t, e)
          }
          null !== Pd && Wd(Pd, e), null !== Ad && Wd(Ad, e), null !== Rd && Wd(Rd, e), Md.forEach(t), Ld.forEach(t);
          for (var n = 0; n < jd.length; n++) {
            var r = jd[n];
            r.blockedOn === e && (r.blockedOn = null)
          }
          for (; 0 < jd.length && null === (n = jd[0]).blockedOn;) zd(n), null === n.blockedOn && jd.shift();
          if (null != (n = (e.ownerDocument || e).$$reactFormReplay))
            for (r = 0; r < n.length; r += 3) {
              var i = n[r],
                s = n[r + 1],
                o = i[We] || null;
              if ("function" === typeof s) o || Vd(n);
              else if (o) {
                var a = null;
                if (s && s.hasAttribute("formAction")) {
                  if (i = s, o = s[We] || null) a = o.formAction;
                  else if (null !== Td(i)) continue
                } else a = o.action;
                "function" === typeof a ? n[r + 1] = a : (n.splice(r, 3), r -= 3), Vd(n)
              }
            }
        }

        function Kd() {
          function e(e) {
            e.canIntercept && "react-transition" === e.info && e.intercept({
              handler: function() {
                return new Promise(function(e) {
                  return i = e
                })
              },
              focusReset: "manual",
              scroll: "manual"
            })
          }

          function t() {
            null !== i && (i(), i = null), r || setTimeout(n, 20)
          }

          function n() {
            if (!r && !navigation.transition) {
              var e = navigation.currentEntry;
              e && null != e.url && navigation.navigate(e.url, {
                state: e.getState(),
                info: "react-transition",
                history: "replace"
              })
            }
          }
          if ("object" === typeof navigation) {
            var r = !1,
              i = null;
            return navigation.addEventListener("navigate", e), navigation.addEventListener("navigatesuccess", t), navigation.addEventListener("navigateerror", t), setTimeout(n, 100),
              function() {
                r = !0, navigation.removeEventListener("navigate", e), navigation.removeEventListener("navigatesuccess", t), navigation.removeEventListener("navigateerror", t), null !== i && (i(), i = null)
              }
          }
        }

        function $d(e) {
          this._internalRoot = e
        }

        function Yd(e) {
          this._internalRoot = e
        }
        Yd.prototype.render = $d.prototype.render = function(e) {
          var t = this._internalRoot;
          if (null === t) throw Error(o(409));
          gd(t.current, $c(), e, t, null, null)
        }, Yd.prototype.unmount = $d.prototype.unmount = function() {
          var e = this._internalRoot;
          if (null !== e) {
            this._internalRoot = null;
            var t = e.containerInfo;
            gd(e.current, 2, null, e, null, null), eu(), t[He] = null
          }
        }, Yd.prototype.unstable_scheduleHydration = function(e) {
          if (e) {
            var t = ze();
            e = {
              blockedOn: null,
              target: e,
              priority: t
            };
            for (var n = 0; n < jd.length && 0 !== t && t < jd[n].priority; n++);
            jd.splice(n, 0, e), 0 === n && zd(e)
          }
        };
        var Jd = i.version;
        if ("19.2.0" !== Jd) throw Error(o(527, Jd, "19.2.0"));
        N.findDOMNode = function(e) {
          var t = e._reactInternals;
          if (void 0 === t) {
            if ("function" === typeof e.render) throw Error(o(188));
            throw e = Object.keys(e).join(","), Error(o(268, e))
          }
          return e = function(e) {
            var t = e.alternate;
            if (!t) {
              if (null === (t = l(e))) throw Error(o(188));
              return t !== e ? null : e
            }
            for (var n = e, r = t;;) {
              var i = n.return;
              if (null === i) break;
              var s = i.alternate;
              if (null === s) {
                if (null !== (r = i.return)) {
                  n = r;
                  continue
                }
                break
              }
              if (i.child === s.child) {
                for (s = i.child; s;) {
                  if (s === n) return h(i), e;
                  if (s === r) return h(i), t;
                  s = s.sibling
                }
                throw Error(o(188))
              }
              if (n.return !== r.return) n = i, r = s;
              else {
                for (var a = !1, c = i.child; c;) {
                  if (c === n) {
                    a = !0, n = i, r = s;
                    break
                  }
                  if (c === r) {
                    a = !0, r = i, n = s;
                    break
                  }
                  c = c.sibling
                }
                if (!a) {
                  for (c = s.child; c;) {
                    if (c === n) {
                      a = !0, n = s, r = i;
                      break
                    }
                    if (c === r) {
                      a = !0, r = s, n = i;
                      break
                    }
                    c = c.sibling
                  }
                  if (!a) throw Error(o(189))
                }
              }
              if (n.alternate !== r) throw Error(o(190))
            }
            if (3 !== n.tag) throw Error(o(188));
            return n.stateNode.current === n ? e : t
          }(t), e = null === (e = null !== e ? d(e) : null) ? null : e.stateNode
        };
        var Gd = {
          bundleType: 0,
          version: "19.2.0",
          rendererPackageName: "react-dom",
          currentDispatcherRef: j,
          reconcilerVersion: "19.2.0"
        };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var Qd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!Qd.isDisabled && Qd.supportsFiber) try {
            ye = Qd.inject(Gd), ve = Qd
          } catch (Zd) {}
        }
        t.createRoot = function(e, t) {
          if (!a(e)) throw Error(o(299));
          var n = !1,
            r = "",
            i = Ea,
            s = Ta,
            l = Ca;
          return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onUncaughtError && (i = t.onUncaughtError), void 0 !== t.onCaughtError && (s = t.onCaughtError), void 0 !== t.onRecoverableError && (l = t.onRecoverableError)), t = fd(e, 1, !1, null, 0, n, r, null, i, s, l, Kd), e[He] = t.current, eh(e), new $d(t)
        }, t.hydrateRoot = function(e, t, n) {
          if (!a(e)) throw Error(o(299));
          var r = !1,
            i = "",
            s = Ea,
            l = Ta,
            c = Ca,
            u = null;
          return null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (r = !0), void 0 !== n.identifierPrefix && (i = n.identifierPrefix), void 0 !== n.onUncaughtError && (s = n.onUncaughtError), void 0 !== n.onCaughtError && (l = n.onCaughtError), void 0 !== n.onRecoverableError && (c = n.onRecoverableError), void 0 !== n.formState && (u = n.formState)), (t = fd(e, 1, !0, t, 0, r, i, u, s, l, c, Kd)).context = pd(null), n = t.current, (i = bs(r = Ie(r = $c()))).callback = null, ws(n, i, r), n = r, t.current.lanes = n, Me(t, n), Iu(t), e[He] = t.current, eh(e), new Yd(t)
        }, t.version = "19.2.0"
      },
      43: (e, t, n) => {
        e.exports = n(288)
      },
      210: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        const i = r(n(829)),
          s = r(n(736));
        class o {
          constructor(e) {
            let {
              headers: t = {},
              schema: n,
              fetch: r
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            this.url = e, this.headers = new Headers(t), this.schemaName = n, this.fetch = r
          }
          from(e) {
            const t = new URL("".concat(this.url, "/").concat(e));
            return new i.default(t, {
              headers: new Headers(this.headers),
              schema: this.schemaName,
              fetch: this.fetch
            })
          }
          schema(e) {
            return new o(this.url, {
              headers: this.headers,
              schema: e,
              fetch: this.fetch
            })
          }
          rpc(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
              {
                head: n = !1,
                get: r = !1,
                count: i
              } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            var o;
            let a;
            const l = new URL("".concat(this.url, "/rpc/").concat(e));
            let c;
            n || r ? (a = n ? "HEAD" : "GET", Object.entries(t).filter(e => {
              let [t, n] = e;
              return void 0 !== n
            }).map(e => {
              let [t, n] = e;
              return [t, Array.isArray(n) ? "{".concat(n.join(","), "}") : "".concat(n)]
            }).forEach(e => {
              let [t, n] = e;
              l.searchParams.append(t, n)
            })) : (a = "POST", c = t);
            const u = new Headers(this.headers);
            return i && u.set("Prefer", "count=".concat(i)), new s.default({
              method: a,
              url: l,
              headers: u,
              schema: this.schemaName,
              body: c,
              fetch: null !== (o = this.fetch) && void 0 !== o ? o : fetch
            })
          }
        }
        t.default = o
      },
      286: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        const i = r(n(630)),
          s = r(n(611));
        t.default = class {
          constructor(e) {
            var t, n;
            this.shouldThrowOnError = !1, this.method = e.method, this.url = e.url, this.headers = new Headers(e.headers), this.schema = e.schema, this.body = e.body, this.shouldThrowOnError = null !== (t = e.shouldThrowOnError) && void 0 !== t && t, this.signal = e.signal, this.isMaybeSingle = null !== (n = e.isMaybeSingle) && void 0 !== n && n, e.fetch ? this.fetch = e.fetch : "undefined" === typeof fetch ? this.fetch = i.default : this.fetch = fetch
          }
          throwOnError() {
            return this.shouldThrowOnError = !0, this
          }
          setHeader(e, t) {
            return this.headers = new Headers(this.headers), this.headers.set(e, t), this
          }
          then(e, t) {
            void 0 === this.schema || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)), "GET" !== this.method && "HEAD" !== this.method && this.headers.set("Content-Type", "application/json");
            let n = (0, this.fetch)(this.url.toString(), {
              method: this.method,
              headers: this.headers,
              body: JSON.stringify(this.body),
              signal: this.signal
            }).then(async e => {
              var t, n, r, i;
              let o = null,
                a = null,
                l = null,
                c = e.status,
                u = e.statusText;
              if (e.ok) {
                if ("HEAD" !== this.method) {
                  const n = await e.text();
                  "" === n || (a = "text/csv" === this.headers.get("Accept") || this.headers.get("Accept") && (null === (t = this.headers.get("Accept")) || void 0 === t ? void 0 : t.includes("application/vnd.pgrst.plan+text")) ? n : JSON.parse(n))
                }
                const i = null === (n = this.headers.get("Prefer")) || void 0 === n ? void 0 : n.match(/count=(exact|planned|estimated)/),
                  s = null === (r = e.headers.get("content-range")) || void 0 === r ? void 0 : r.split("/");
                i && s && s.length > 1 && (l = parseInt(s[1])), this.isMaybeSingle && "GET" === this.method && Array.isArray(a) && (a.length > 1 ? (o = {
                  code: "PGRST116",
                  details: "Results contain ".concat(a.length, " rows, application/vnd.pgrst.object+json requires 1 row"),
                  hint: null,
                  message: "JSON object requested, multiple (or no) rows returned"
                }, a = null, l = null, c = 406, u = "Not Acceptable") : a = 1 === a.length ? a[0] : null)
              } else {
                const t = await e.text();
                try {
                  o = JSON.parse(t), Array.isArray(o) && 404 === e.status && (a = [], o = null, c = 200, u = "OK")
                } catch (h) {
                  404 === e.status && "" === t ? (c = 204, u = "No Content") : o = {
                    message: t
                  }
                }
                if (o && this.isMaybeSingle && (null === (i = null === o || void 0 === o ? void 0 : o.details) || void 0 === i ? void 0 : i.includes("0 rows")) && (o = null, c = 200, u = "OK"), o && this.shouldThrowOnError) throw new s.default(o)
              }
              return {
                error: o,
                data: a,
                count: l,
                status: c,
                statusText: u
              }
            });
            return this.shouldThrowOnError || (n = n.catch(e => {
              var t, n, r;
              return {
                error: {
                  message: "".concat(null !== (t = null === e || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "FetchError", ": ").concat(null === e || void 0 === e ? void 0 : e.message),
                  details: "".concat(null !== (n = null === e || void 0 === e ? void 0 : e.stack) && void 0 !== n ? n : ""),
                  hint: "",
                  code: "".concat(null !== (r = null === e || void 0 === e ? void 0 : e.code) && void 0 !== r ? r : "")
                },
                data: null,
                count: null,
                status: 0,
                statusText: ""
              }
            })), n.then(e, t)
          }
          returns() {
            return this
          }
          overrideTypes() {
            return this
          }
        }
      },
      288: (e, t) => {
        var n = Symbol.for("react.transitional.element"),
          r = Symbol.for("react.portal"),
          i = Symbol.for("react.fragment"),
          s = Symbol.for("react.strict_mode"),
          o = Symbol.for("react.profiler"),
          a = Symbol.for("react.consumer"),
          l = Symbol.for("react.context"),
          c = Symbol.for("react.forward_ref"),
          u = Symbol.for("react.suspense"),
          h = Symbol.for("react.memo"),
          d = Symbol.for("react.lazy"),
          f = Symbol.for("react.activity"),
          p = Symbol.iterator;
        var g = {
            isMounted: function() {
              return !1
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
          },
          m = Object.assign,
          y = {};

        function v(e, t, n) {
          this.props = e, this.context = t, this.refs = y, this.updater = n || g
        }

        function b() {}

        function w(e, t, n) {
          this.props = e, this.context = t, this.refs = y, this.updater = n || g
        }
        v.prototype.isReactComponent = {}, v.prototype.setState = function(e, t) {
          if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
          this.updater.enqueueSetState(this, e, t, "setState")
        }, v.prototype.forceUpdate = function(e) {
          this.updater.enqueueForceUpdate(this, e, "forceUpdate")
        }, b.prototype = v.prototype;
        var _ = w.prototype = new b;
        _.constructor = w, m(_, v.prototype), _.isPureReactComponent = !0;
        var x = Array.isArray;

        function k() {}
        var S = {
            H: null,
            A: null,
            T: null,
            S: null
          },
          E = Object.prototype.hasOwnProperty;

        function T(e, t, r) {
          var i = r.ref;
          return {
            $$typeof: n,
            type: e,
            key: t,
            ref: void 0 !== i ? i : null,
            props: r
          }
        }

        function C(e) {
          return "object" === typeof e && null !== e && e.$$typeof === n
        }
        var O = /\/+/g;

        function P(e, t) {
          return "object" === typeof e && null !== e && null != e.key ? function(e) {
            var t = {
              "=": "=0",
              ":": "=2"
            };
            return "$" + e.replace(/[=:]/g, function(e) {
              return t[e]
            })
          }("" + e.key) : t.toString(36)
        }

        function A(e, t, i, s, o) {
          var a = typeof e;
          "undefined" !== a && "boolean" !== a || (e = null);
          var l, c, u = !1;
          if (null === e) u = !0;
          else switch (a) {
            case "bigint":
            case "string":
            case "number":
              u = !0;
              break;
            case "object":
              switch (e.$$typeof) {
                case n:
                case r:
                  u = !0;
                  break;
                case d:
                  return A((u = e._init)(e._payload), t, i, s, o)
              }
          }
          if (u) return o = o(e), u = "" === s ? "." + P(e, 0) : s, x(o) ? (i = "", null != u && (i = u.replace(O, "$&/") + "/"), A(o, t, i, "", function(e) {
            return e
          })) : null != o && (C(o) && (l = o, c = i + (null == o.key || e && e.key === o.key ? "" : ("" + o.key).replace(O, "$&/") + "/") + u, o = T(l.type, c, l.props)), t.push(o)), 1;
          u = 0;
          var h, f = "" === s ? "." : s + ":";
          if (x(e))
            for (var g = 0; g < e.length; g++) u += A(s = e[g], t, i, a = f + P(s, g), o);
          else if ("function" === typeof(g = null === (h = e) || "object" !== typeof h ? null : "function" === typeof(h = p && h[p] || h["@@iterator"]) ? h : null))
            for (e = g.call(e), g = 0; !(s = e.next()).done;) u += A(s = s.value, t, i, a = f + P(s, g++), o);
          else if ("object" === a) {
            if ("function" === typeof e.then) return A(function(e) {
              switch (e.status) {
                case "fulfilled":
                  return e.value;
                case "rejected":
                  throw e.reason;
                default:
                  switch ("string" === typeof e.status ? e.then(k, k) : (e.status = "pending", e.then(function(t) {
                      "pending" === e.status && (e.status = "fulfilled", e.value = t)
                    }, function(t) {
                      "pending" === e.status && (e.status = "rejected", e.reason = t)
                    })), e.status) {
                    case "fulfilled":
                      return e.value;
                    case "rejected":
                      throw e.reason
                  }
              }
              throw e
            }(e), t, i, s, o);
            throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.")
          }
          return u
        }

        function R(e, t, n) {
          if (null == e) return e;
          var r = [],
            i = 0;
          return A(e, r, "", "", function(e) {
            return t.call(n, e, i++)
          }), r
        }

        function M(e) {
          if (-1 === e._status) {
            var t = e._result;
            (t = t()).then(function(t) {
              0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
            }, function(t) {
              0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
            }), -1 === e._status && (e._status = 0, e._result = t)
          }
          if (1 === e._status) return e._result.default;
          throw e._result
        }
        var L = "function" === typeof reportError ? reportError : function(e) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
              var t = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message: "object" === typeof e && null !== e && "string" === typeof e.message ? String(e.message) : String(e),
                error: e
              });
              if (!window.dispatchEvent(t)) return
            } else if ("object" === typeof process && "function" === typeof process.emit) return void process.emit("uncaughtException", e);
            console.error(e)
          },
          j = {
            map: R,
            forEach: function(e, t, n) {
              R(e, function() {
                t.apply(this, arguments)
              }, n)
            },
            count: function(e) {
              var t = 0;
              return R(e, function() {
                t++
              }), t
            },
            toArray: function(e) {
              return R(e, function(e) {
                return e
              }) || []
            },
            only: function(e) {
              if (!C(e)) throw Error("React.Children.only expected to receive a single React element child.");
              return e
            }
          };
        t.Activity = f, t.Children = j, t.Component = v, t.Fragment = i, t.Profiler = o, t.PureComponent = w, t.StrictMode = s, t.Suspense = u, t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = S, t.__COMPILER_RUNTIME = {
          __proto__: null,
          c: function(e) {
            return S.H.useMemoCache(e)
          }
        }, t.cache = function(e) {
          return function() {
            return e.apply(null, arguments)
          }
        }, t.cacheSignal = function() {
          return null
        }, t.cloneElement = function(e, t, n) {
          if (null === e || void 0 === e) throw Error("The argument must be a React element, but you passed " + e + ".");
          var r = m({}, e.props),
            i = e.key;
          if (null != t)
            for (s in void 0 !== t.key && (i = "" + t.key), t) !E.call(t, s) || "key" === s || "__self" === s || "__source" === s || "ref" === s && void 0 === t.ref || (r[s] = t[s]);
          var s = arguments.length - 2;
          if (1 === s) r.children = n;
          else if (1 < s) {
            for (var o = Array(s), a = 0; a < s; a++) o[a] = arguments[a + 2];
            r.children = o
          }
          return T(e.type, i, r)
        }, t.createContext = function(e) {
          return (e = {
            $$typeof: l,
            _currentValue: e,
            _currentValue2: e,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          }).Provider = e, e.Consumer = {
            $$typeof: a,
            _context: e
          }, e
        }, t.createElement = function(e, t, n) {
          var r, i = {},
            s = null;
          if (null != t)
            for (r in void 0 !== t.key && (s = "" + t.key), t) E.call(t, r) && "key" !== r && "__self" !== r && "__source" !== r && (i[r] = t[r]);
          var o = arguments.length - 2;
          if (1 === o) i.children = n;
          else if (1 < o) {
            for (var a = Array(o), l = 0; l < o; l++) a[l] = arguments[l + 2];
            i.children = a
          }
          if (e && e.defaultProps)
            for (r in o = e.defaultProps) void 0 === i[r] && (i[r] = o[r]);
          return T(e, s, i)
        }, t.createRef = function() {
          return {
            current: null
          }
        }, t.forwardRef = function(e) {
          return {
            $$typeof: c,
            render: e
          }
        }, t.isValidElement = C, t.lazy = function(e) {
          return {
            $$typeof: d,
            _payload: {
              _status: -1,
              _result: e
            },
            _init: M
          }
        }, t.memo = function(e, t) {
          return {
            $$typeof: h,
            type: e,
            compare: void 0 === t ? null : t
          }
        }, t.startTransition = function(e) {
          var t = S.T,
            n = {};
          S.T = n;
          try {
            var r = e(),
              i = S.S;
            null !== i && i(n, r), "object" === typeof r && null !== r && "function" === typeof r.then && r.then(k, L)
          } catch (s) {
            L(s)
          } finally {
            null !== t && null !== n.types && (t.types = n.types), S.T = t
          }
        }, t.unstable_useCacheRefresh = function() {
          return S.H.useCacheRefresh()
        }, t.use = function(e) {
          return S.H.use(e)
        }, t.useActionState = function(e, t, n) {
          return S.H.useActionState(e, t, n)
        }, t.useCallback = function(e, t) {
          return S.H.useCallback(e, t)
        }, t.useContext = function(e) {
          return S.H.useContext(e)
        }, t.useDebugValue = function() {}, t.useDeferredValue = function(e, t) {
          return S.H.useDeferredValue(e, t)
        }, t.useEffect = function(e, t) {
          return S.H.useEffect(e, t)
        }, t.useEffectEvent = function(e) {
          return S.H.useEffectEvent(e)
        }, t.useId = function() {
          return S.H.useId()
        }, t.useImperativeHandle = function(e, t, n) {
          return S.H.useImperativeHandle(e, t, n)
        }, t.useInsertionEffect = function(e, t) {
          return S.H.useInsertionEffect(e, t)
        }, t.useLayoutEffect = function(e, t) {
          return S.H.useLayoutEffect(e, t)
        }, t.useMemo = function(e, t) {
          return S.H.useMemo(e, t)
        }, t.useOptimistic = function(e, t) {
          return S.H.useOptimistic(e, t)
        }, t.useReducer = function(e, t, n) {
          return S.H.useReducer(e, t, n)
        }, t.useRef = function(e) {
          return S.H.useRef(e)
        }, t.useState = function(e) {
          return S.H.useState(e)
        }, t.useSyncExternalStore = function(e, t, n) {
          return S.H.useSyncExternalStore(e, t, n)
        }, t.useTransition = function() {
          return S.H.useTransition()
        }, t.version = "19.2.0"
      },
      374: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        const i = r(n(286));
        class s extends i.default {
          select(e) {
            let t = !1;
            const n = (null !== e && void 0 !== e ? e : "*").split("").map(e => /\s/.test(e) && !t ? "" : ('"' === e && (t = !t), e)).join("");
            return this.url.searchParams.set("select", n), this.headers.append("Prefer", "return=representation"), this
          }
          order(e) {
            let {
              ascending: t = !0,
              nullsFirst: n,
              foreignTable: r,
              referencedTable: i = r
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const s = i ? "".concat(i, ".order") : "order",
              o = this.url.searchParams.get(s);
            return this.url.searchParams.set(s, "".concat(o ? "".concat(o, ",") : "").concat(e, ".").concat(t ? "asc" : "desc").concat(void 0 === n ? "" : n ? ".nullsfirst" : ".nullslast")), this
          }
          limit(e) {
            let {
              foreignTable: t,
              referencedTable: n = t
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const r = "undefined" === typeof n ? "limit" : "".concat(n, ".limit");
            return this.url.searchParams.set(r, "".concat(e)), this
          }
          range(e, t) {
            let {
              foreignTable: n,
              referencedTable: r = n
            } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const i = "undefined" === typeof r ? "offset" : "".concat(r, ".offset"),
              s = "undefined" === typeof r ? "limit" : "".concat(r, ".limit");
            return this.url.searchParams.set(i, "".concat(e)), this.url.searchParams.set(s, "".concat(t - e + 1)), this
          }
          abortSignal(e) {
            return this.signal = e, this
          }
          single() {
            return this.headers.set("Accept", "application/vnd.pgrst.object+json"), this
          }
          maybeSingle() {
            return "GET" === this.method ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"), this.isMaybeSingle = !0, this
          }
          csv() {
            return this.headers.set("Accept", "text/csv"), this
          }
          geojson() {
            return this.headers.set("Accept", "application/geo+json"), this
          }
          explain() {
            let {
              analyze: e = !1,
              verbose: t = !1,
              settings: n = !1,
              buffers: r = !1,
              wal: i = !1,
              format: s = "text"
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            var o;
            const a = [e ? "analyze" : null, t ? "verbose" : null, n ? "settings" : null, r ? "buffers" : null, i ? "wal" : null].filter(Boolean).join("|"),
              l = null !== (o = this.headers.get("Accept")) && void 0 !== o ? o : "application/json";
            return this.headers.set("Accept", "application/vnd.pgrst.plan+".concat(s, '; for="').concat(l, '"; options=').concat(a, ";")), this
          }
          rollback() {
            return this.headers.append("Prefer", "tx=rollback"), this
          }
          returns() {
            return this
          }
          maxAffected(e) {
            return this.headers.append("Prefer", "handling=strict"), this.headers.append("Prefer", "max-affected=".concat(e)), this
          }
        }
        t.default = s
      },
      391: (e, t, n) => {
        ! function e() {
          if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
          } catch (t) {
            console.error(t)
          }
        }(), e.exports = n(4)
      },
      579: (e, t, n) => {
        e.exports = n(799)
      },
      611: (e, t) => {
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        class n extends Error {
          constructor(e) {
            super(e.message), this.name = "PostgrestError", this.details = e.details, this.hint = e.hint, this.code = e.code
          }
        }
        t.default = n
      },
      630: (e, t, n) => {
        n.r(t), n.d(t, {
          Headers: () => o,
          Request: () => a,
          Response: () => l,
          default: () => s,
          fetch: () => i
        });
        var r = function() {
          if ("undefined" !== typeof self) return self;
          if ("undefined" !== typeof window) return window;
          if ("undefined" !== typeof n.g) return n.g;
          throw new Error("unable to locate global object")
        }();
        const i = r.fetch,
          s = r.fetch.bind(r),
          o = r.Headers,
          a = r.Request,
          l = r.Response
      },
      672: (e, t, n) => {
        var r = n(43);

        function i(e) {
          var t = "https://react.dev/errors/" + e;
          if (1 < arguments.length) {
            t += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n])
          }
          return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
        }

        function s() {}
        var o = {
            d: {
              f: s,
              r: function() {
                throw Error(i(522))
              },
              D: s,
              C: s,
              L: s,
              m: s,
              X: s,
              S: s,
              M: s
            },
            p: 0,
            findDOMNode: null
          },
          a = Symbol.for("react.portal");
        var l = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;

        function c(e, t) {
          return "font" === e ? "" : "string" === typeof t ? "use-credentials" === t ? t : "" : void 0
        }
        t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o, t.createPortal = function(e, t) {
          var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!t || 1 !== t.nodeType && 9 !== t.nodeType && 11 !== t.nodeType) throw Error(i(299));
          return function(e, t, n) {
            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
              $$typeof: a,
              key: null == r ? null : "" + r,
              children: e,
              containerInfo: t,
              implementation: n
            }
          }(e, t, null, n)
        }, t.flushSync = function(e) {
          var t = l.T,
            n = o.p;
          try {
            if (l.T = null, o.p = 2, e) return e()
          } finally {
            l.T = t, o.p = n, o.d.f()
          }
        }, t.preconnect = function(e, t) {
          "string" === typeof e && (t ? t = "string" === typeof(t = t.crossOrigin) ? "use-credentials" === t ? t : "" : void 0 : t = null, o.d.C(e, t))
        }, t.prefetchDNS = function(e) {
          "string" === typeof e && o.d.D(e)
        }, t.preinit = function(e, t) {
          if ("string" === typeof e && t && "string" === typeof t.as) {
            var n = t.as,
              r = c(n, t.crossOrigin),
              i = "string" === typeof t.integrity ? t.integrity : void 0,
              s = "string" === typeof t.fetchPriority ? t.fetchPriority : void 0;
            "style" === n ? o.d.S(e, "string" === typeof t.precedence ? t.precedence : void 0, {
              crossOrigin: r,
              integrity: i,
              fetchPriority: s
            }) : "script" === n && o.d.X(e, {
              crossOrigin: r,
              integrity: i,
              fetchPriority: s,
              nonce: "string" === typeof t.nonce ? t.nonce : void 0
            })
          }
        }, t.preinitModule = function(e, t) {
          if ("string" === typeof e)
            if ("object" === typeof t && null !== t) {
              if (null == t.as || "script" === t.as) {
                var n = c(t.as, t.crossOrigin);
                o.d.M(e, {
                  crossOrigin: n,
                  integrity: "string" === typeof t.integrity ? t.integrity : void 0,
                  nonce: "string" === typeof t.nonce ? t.nonce : void 0
                })
              }
            } else null == t && o.d.M(e)
        }, t.preload = function(e, t) {
          if ("string" === typeof e && "object" === typeof t && null !== t && "string" === typeof t.as) {
            var n = t.as,
              r = c(n, t.crossOrigin);
            o.d.L(e, n, {
              crossOrigin: r,
              integrity: "string" === typeof t.integrity ? t.integrity : void 0,
              nonce: "string" === typeof t.nonce ? t.nonce : void 0,
              type: "string" === typeof t.type ? t.type : void 0,
              fetchPriority: "string" === typeof t.fetchPriority ? t.fetchPriority : void 0,
              referrerPolicy: "string" === typeof t.referrerPolicy ? t.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof t.imageSrcSet ? t.imageSrcSet : void 0,
              imageSizes: "string" === typeof t.imageSizes ? t.imageSizes : void 0,
              media: "string" === typeof t.media ? t.media : void 0
            })
          }
        }, t.preloadModule = function(e, t) {
          if ("string" === typeof e)
            if (t) {
              var n = c(t.as, t.crossOrigin);
              o.d.m(e, {
                as: "string" === typeof t.as && "script" !== t.as ? t.as : void 0,
                crossOrigin: n,
                integrity: "string" === typeof t.integrity ? t.integrity : void 0
              })
            } else o.d.m(e)
        }, t.requestFormReset = function(e) {
          o.d.r(e)
        }, t.unstable_batchedUpdates = function(e, t) {
          return e(t)
        }, t.useFormState = function(e, t, n) {
          return l.H.useFormState(e, t, n)
        }, t.useFormStatus = function() {
          return l.H.useHostTransitionStatus()
        }, t.version = "19.2.0"
      },
      736: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        const i = r(n(374));
        class s extends i.default {
          eq(e, t) {
            return this.url.searchParams.append(e, "eq.".concat(t)), this
          }
          neq(e, t) {
            return this.url.searchParams.append(e, "neq.".concat(t)), this
          }
          gt(e, t) {
            return this.url.searchParams.append(e, "gt.".concat(t)), this
          }
          gte(e, t) {
            return this.url.searchParams.append(e, "gte.".concat(t)), this
          }
          lt(e, t) {
            return this.url.searchParams.append(e, "lt.".concat(t)), this
          }
          lte(e, t) {
            return this.url.searchParams.append(e, "lte.".concat(t)), this
          }
          like(e, t) {
            return this.url.searchParams.append(e, "like.".concat(t)), this
          }
          likeAllOf(e, t) {
            return this.url.searchParams.append(e, "like(all).{".concat(t.join(","), "}")), this
          }
          likeAnyOf(e, t) {
            return this.url.searchParams.append(e, "like(any).{".concat(t.join(","), "}")), this
          }
          ilike(e, t) {
            return this.url.searchParams.append(e, "ilike.".concat(t)), this
          }
          ilikeAllOf(e, t) {
            return this.url.searchParams.append(e, "ilike(all).{".concat(t.join(","), "}")), this
          }
          ilikeAnyOf(e, t) {
            return this.url.searchParams.append(e, "ilike(any).{".concat(t.join(","), "}")), this
          }
          is(e, t) {
            return this.url.searchParams.append(e, "is.".concat(t)), this
          }
          in(e, t) {
            const n = Array.from(new Set(t)).map(e => "string" === typeof e && new RegExp("[,()]").test(e) ? '"'.concat(e, '"') : "".concat(e)).join(",");
            return this.url.searchParams.append(e, "in.(".concat(n, ")")), this
          }
          contains(e, t) {
            return "string" === typeof t ? this.url.searchParams.append(e, "cs.".concat(t)) : Array.isArray(t) ? this.url.searchParams.append(e, "cs.{".concat(t.join(","), "}")) : this.url.searchParams.append(e, "cs.".concat(JSON.stringify(t))), this
          }
          containedBy(e, t) {
            return "string" === typeof t ? this.url.searchParams.append(e, "cd.".concat(t)) : Array.isArray(t) ? this.url.searchParams.append(e, "cd.{".concat(t.join(","), "}")) : this.url.searchParams.append(e, "cd.".concat(JSON.stringify(t))), this
          }
          rangeGt(e, t) {
            return this.url.searchParams.append(e, "sr.".concat(t)), this
          }
          rangeGte(e, t) {
            return this.url.searchParams.append(e, "nxl.".concat(t)), this
          }
          rangeLt(e, t) {
            return this.url.searchParams.append(e, "sl.".concat(t)), this
          }
          rangeLte(e, t) {
            return this.url.searchParams.append(e, "nxr.".concat(t)), this
          }
          rangeAdjacent(e, t) {
            return this.url.searchParams.append(e, "adj.".concat(t)), this
          }
          overlaps(e, t) {
            return "string" === typeof t ? this.url.searchParams.append(e, "ov.".concat(t)) : this.url.searchParams.append(e, "ov.{".concat(t.join(","), "}")), this
          }
          textSearch(e, t) {
            let {
              config: n,
              type: r
            } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = "";
            "plain" === r ? i = "pl" : "phrase" === r ? i = "ph" : "websearch" === r && (i = "w");
            const s = void 0 === n ? "" : "(".concat(n, ")");
            return this.url.searchParams.append(e, "".concat(i, "fts").concat(s, ".").concat(t)), this
          }
          match(e) {
            return Object.entries(e).forEach(e => {
              let [t, n] = e;
              this.url.searchParams.append(t, "eq.".concat(n))
            }), this
          }
          not(e, t, n) {
            return this.url.searchParams.append(e, "not.".concat(t, ".").concat(n)), this
          }
          or(e) {
            let {
              foreignTable: t,
              referencedTable: n = t
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const r = n ? "".concat(n, ".or") : "or";
            return this.url.searchParams.append(r, "(".concat(e, ")")), this
          }
          filter(e, t, n) {
            return this.url.searchParams.append(e, "".concat(t, ".").concat(n)), this
          }
        }
        t.default = s
      },
      799: (e, t) => {
        var n = Symbol.for("react.transitional.element"),
          r = Symbol.for("react.fragment");

        function i(e, t, r) {
          var i = null;
          if (void 0 !== r && (i = "" + r), void 0 !== t.key && (i = "" + t.key), "key" in t)
            for (var s in r = {}, t) "key" !== s && (r[s] = t[s]);
          else r = t;
          return t = r.ref, {
            $$typeof: n,
            type: e,
            key: i,
            ref: void 0 !== t ? t : null,
            props: r
          }
        }
        t.Fragment = r, t.jsx = i, t.jsxs = i
      },
      829: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        const i = r(n(736));
        t.default = class {
          constructor(e, t) {
            let {
              headers: n = {},
              schema: r,
              fetch: i
            } = t;
            this.url = e, this.headers = new Headers(n), this.schema = r, this.fetch = i
          }
          select(e, t) {
            const {
              head: n = !1,
              count: r
            } = null !== t && void 0 !== t ? t : {}, s = n ? "HEAD" : "GET";
            let o = !1;
            const a = (null !== e && void 0 !== e ? e : "*").split("").map(e => /\s/.test(e) && !o ? "" : ('"' === e && (o = !o), e)).join("");
            return this.url.searchParams.set("select", a), r && this.headers.append("Prefer", "count=".concat(r)), new i.default({
              method: s,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              fetch: this.fetch
            })
          }
          insert(e) {
            let {
              count: t,
              defaultToNull: n = !0
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            var r;
            if (t && this.headers.append("Prefer", "count=".concat(t)), n || this.headers.append("Prefer", "missing=default"), Array.isArray(e)) {
              const t = e.reduce((e, t) => e.concat(Object.keys(t)), []);
              if (t.length > 0) {
                const e = [...new Set(t)].map(e => '"'.concat(e, '"'));
                this.url.searchParams.set("columns", e.join(","))
              }
            }
            return new i.default({
              method: "POST",
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: null !== (r = this.fetch) && void 0 !== r ? r : fetch
            })
          }
          upsert(e) {
            let {
              onConflict: t,
              ignoreDuplicates: n = !1,
              count: r,
              defaultToNull: s = !0
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            var o;
            if (this.headers.append("Prefer", "resolution=".concat(n ? "ignore" : "merge", "-duplicates")), void 0 !== t && this.url.searchParams.set("on_conflict", t), r && this.headers.append("Prefer", "count=".concat(r)), s || this.headers.append("Prefer", "missing=default"), Array.isArray(e)) {
              const t = e.reduce((e, t) => e.concat(Object.keys(t)), []);
              if (t.length > 0) {
                const e = [...new Set(t)].map(e => '"'.concat(e, '"'));
                this.url.searchParams.set("columns", e.join(","))
              }
            }
            return new i.default({
              method: "POST",
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: null !== (o = this.fetch) && void 0 !== o ? o : fetch
            })
          }
          update(e) {
            let {
              count: t
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            var n;
            return t && this.headers.append("Prefer", "count=".concat(t)), new i.default({
              method: "PATCH",
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: null !== (n = this.fetch) && void 0 !== n ? n : fetch
            })
          }
          delete() {
            let {
              count: e
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            var t;
            return e && this.headers.append("Prefer", "count=".concat(e)), new i.default({
              method: "DELETE",
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              fetch: null !== (t = this.fetch) && void 0 !== t ? t : fetch
            })
          }
        }
      },
      853: (e, t, n) => {
        e.exports = n(896)
      },
      896: (e, t) => {
        function n(e, t) {
          var n = e.length;
          e.push(t);
          e: for (; 0 < n;) {
            var r = n - 1 >>> 1,
              i = e[r];
            if (!(0 < s(i, t))) break e;
            e[r] = t, e[n] = i, n = r
          }
        }

        function r(e) {
          return 0 === e.length ? null : e[0]
        }

        function i(e) {
          if (0 === e.length) return null;
          var t = e[0],
            n = e.pop();
          if (n !== t) {
            e[0] = n;
            e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) {
              var a = 2 * (r + 1) - 1,
                l = e[a],
                c = a + 1,
                u = e[c];
              if (0 > s(l, n)) c < i && 0 > s(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[a] = n, r = a);
              else {
                if (!(c < i && 0 > s(u, n))) break e;
                e[r] = u, e[c] = n, r = c
              }
            }
          }
          return t
        }

        function s(e, t) {
          var n = e.sortIndex - t.sortIndex;
          return 0 !== n ? n : e.id - t.id
        }
        if (t.unstable_now = void 0, "object" === typeof performance && "function" === typeof performance.now) {
          var o = performance;
          t.unstable_now = function() {
            return o.now()
          }
        } else {
          var a = Date,
            l = a.now();
          t.unstable_now = function() {
            return a.now() - l
          }
        }
        var c = [],
          u = [],
          h = 1,
          d = null,
          f = 3,
          p = !1,
          g = !1,
          m = !1,
          y = !1,
          v = "function" === typeof setTimeout ? setTimeout : null,
          b = "function" === typeof clearTimeout ? clearTimeout : null,
          w = "undefined" !== typeof setImmediate ? setImmediate : null;

        function _(e) {
          for (var t = r(u); null !== t;) {
            if (null === t.callback) i(u);
            else {
              if (!(t.startTime <= e)) break;
              i(u), t.sortIndex = t.expirationTime, n(c, t)
            }
            t = r(u)
          }
        }

        function x(e) {
          if (m = !1, _(e), !g)
            if (null !== r(c)) g = !0, S || (S = !0, k());
            else {
              var t = r(u);
              null !== t && M(x, t.startTime - e)
            }
        }
        var k, S = !1,
          E = -1,
          T = 5,
          C = -1;

        function O() {
          return !!y || !(t.unstable_now() - C < T)
        }

        function P() {
          if (y = !1, S) {
            var e = t.unstable_now();
            C = e;
            var n = !0;
            try {
              e: {
                g = !1,
                m && (m = !1, b(E), E = -1),
                p = !0;
                var s = f;
                try {
                  t: {
                    for (_(e), d = r(c); null !== d && !(d.expirationTime > e && O());) {
                      var o = d.callback;
                      if ("function" === typeof o) {
                        d.callback = null, f = d.priorityLevel;
                        var a = o(d.expirationTime <= e);
                        if (e = t.unstable_now(), "function" === typeof a) {
                          d.callback = a, _(e), n = !0;
                          break t
                        }
                        d === r(c) && i(c), _(e)
                      } else i(c);
                      d = r(c)
                    }
                    if (null !== d) n = !0;
                    else {
                      var l = r(u);
                      null !== l && M(x, l.startTime - e), n = !1
                    }
                  }
                  break e
                }
                finally {
                  d = null, f = s, p = !1
                }
                n = void 0
              }
            }
            finally {
              n ? k() : S = !1
            }
          }
        }
        if ("function" === typeof w) k = function() {
          w(P)
        };
        else if ("undefined" !== typeof MessageChannel) {
          var A = new MessageChannel,
            R = A.port2;
          A.port1.onmessage = P, k = function() {
            R.postMessage(null)
          }
        } else k = function() {
          v(P, 0)
        };

        function M(e, n) {
          E = v(function() {
            e(t.unstable_now())
          }, n)
        }
        t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
          e.callback = null
        }, t.unstable_forceFrameRate = function(e) {
          0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < e ? Math.floor(1e3 / e) : 5
        }, t.unstable_getCurrentPriorityLevel = function() {
          return f
        }, t.unstable_next = function(e) {
          switch (f) {
            case 1:
            case 2:
            case 3:
              var t = 3;
              break;
            default:
              t = f
          }
          var n = f;
          f = t;
          try {
            return e()
          } finally {
            f = n
          }
        }, t.unstable_requestPaint = function() {
          y = !0
        }, t.unstable_runWithPriority = function(e, t) {
          switch (e) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              e = 3
          }
          var n = f;
          f = e;
          try {
            return t()
          } finally {
            f = n
          }
        }, t.unstable_scheduleCallback = function(e, i, s) {
          var o = t.unstable_now();
          switch ("object" === typeof s && null !== s ? s = "number" === typeof(s = s.delay) && 0 < s ? o + s : o : s = o, e) {
            case 1:
              var a = -1;
              break;
            case 2:
              a = 250;
              break;
            case 5:
              a = 1073741823;
              break;
            case 4:
              a = 1e4;
              break;
            default:
              a = 5e3
          }
          return e = {
            id: h++,
            callback: i,
            priorityLevel: e,
            startTime: s,
            expirationTime: a = s + a,
            sortIndex: -1
          }, s > o ? (e.sortIndex = s, n(u, e), null === r(c) && e === r(u) && (m ? (b(E), E = -1) : m = !0, M(x, s - o))) : (e.sortIndex = a, n(c, e), g || p || (g = !0, S || (S = !0, k()))), e
        }, t.unstable_shouldYield = O, t.unstable_wrapCallback = function(e) {
          var t = f;
          return function() {
            var n = f;
            f = t;
            try {
              return e.apply(this, arguments)
            } finally {
              f = n
            }
          }
        }
      },
      950: (e, t, n) => {
        ! function e() {
          if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
          } catch (t) {
            console.error(t)
          }
        }(), e.exports = n(672)
      },
      980: function(e, t, n) {
        var r = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        };
        Object.defineProperty(t, "__esModule", {
          value: !0
        }), t.PostgrestError = t.PostgrestBuilder = t.PostgrestTransformBuilder = t.PostgrestFilterBuilder = t.PostgrestQueryBuilder = t.PostgrestClient = void 0;
        const i = r(n(210));
        t.PostgrestClient = i.default;
        const s = r(n(829));
        t.PostgrestQueryBuilder = s.default;
        const o = r(n(736));
        t.PostgrestFilterBuilder = o.default;
        const a = r(n(374));
        t.PostgrestTransformBuilder = a.default;
        const l = r(n(286));
        t.PostgrestBuilder = l.default;
        const c = r(n(611));
        t.PostgrestError = c.default, t.default = {
          PostgrestClient: i.default,
          PostgrestQueryBuilder: s.default,
          PostgrestFilterBuilder: o.default,
          PostgrestTransformBuilder: a.default,
          PostgrestBuilder: l.default,
          PostgrestError: c.default
        }
      }
    },
    t = {};

  function n(r) {
    var i = t[r];
    if (void 0 !== i) return i.exports;
    var s = t[r] = {
      exports: {}
    };
    return e[r].call(s.exports, s, s.exports, n), s.exports
  }
  n.m = e, n.d = (e, t) => {
    for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
      enumerable: !0,
      get: t[r]
    })
  }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce((t, r) => (n.f[r](e, t), t), [])), n.u = e => "static/js/" + e + ".eb570f4f.chunk.js", n.miniCssF = e => {}, n.g = function() {
    if ("object" === typeof globalThis) return globalThis;
    try {
      return this || new Function("return this")()
    } catch (e) {
      if ("object" === typeof window) return window
    }
  }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => {
    var e = {},
      t = "client:";
    n.l = (r, i, s, o) => {
      if (e[r]) e[r].push(i);
      else {
        var a, l;
        if (void 0 !== s)
          for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) {
            var h = c[u];
            if (h.getAttribute("src") == r || h.getAttribute("data-webpack") == t + s) {
              a = h;
              break
            }
          }
        a || (l = !0, (a = document.createElement("script")).charset = "utf-8", n.nc && a.setAttribute("nonce", n.nc), a.setAttribute("data-webpack", t + s), a.src = r), e[r] = [i];
        var d = (t, n) => {
            a.onerror = a.onload = null, clearTimeout(f);
            var i = e[r];
            if (delete e[r], a.parentNode && a.parentNode.removeChild(a), i && i.forEach(e => e(n)), t) return t(n)
          },
          f = setTimeout(d.bind(null, void 0, {
            type: "timeout",
            target: a
          }), 12e4);
        a.onerror = d.bind(null, a.onerror), a.onload = d.bind(null, a.onload), l && document.head.appendChild(a)
      }
    }
  })(), n.r = e => {
    "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    })
  }, n.p = "/", (() => {
    var e = {
      792: 0
    };
    n.f.j = (t, r) => {
      var i = n.o(e, t) ? e[t] : void 0;
      if (0 !== i)
        if (i) r.push(i[2]);
        else {
          var s = new Promise((n, r) => i = e[t] = [n, r]);
          r.push(i[2] = s);
          var o = n.p + n.u(t),
            a = new Error;
          n.l(o, r => {
            if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) {
              var s = r && ("load" === r.type ? "missing" : r.type),
                o = r && r.target && r.target.src;
              a.message = "Loading chunk " + t + " failed.\n(" + s + ": " + o + ")", a.name = "ChunkLoadError", a.type = s, a.request = o, i[1](a)
            }
          }, "chunk-" + t, t)
        }
    };
    var t = (t, r) => {
        var i, s, [o, a, l] = r,
          c = 0;
        if (o.some(t => 0 !== e[t])) {
          for (i in a) n.o(a, i) && (n.m[i] = a[i]);
          if (l) l(n)
        }
        for (t && t(r); c < o.length; c++) s = o[c], n.o(e, s) && e[s] && e[s][0](), e[s] = 0
      },
      r = self.webpackChunkclient = self.webpackChunkclient || [];
    r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r))
  })();
  var r = {};
  n.r(r), n.d(r, {
    Decoder: () => _f,
    Encoder: () => bf,
    PacketType: () => vf,
    protocol: () => yf
  });
  var i = n(43),
    s = n(391);

  function o(e) {
    return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
      return typeof e
    } : function(e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, o(e)
  }

  function a(e) {
    var t = function(e, t) {
      if ("object" != o(e) || !e) return e;
      var n = e[Symbol.toPrimitive];
      if (void 0 !== n) {
        var r = n.call(e, t || "default");
        if ("object" != o(r)) return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
      }
      return ("string" === t ? String : Number)(e)
    }(e, "string");
    return "symbol" == o(t) ? t : t + ""
  }

  function l(e, t, n) {
    return (t = a(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e
  }

  function c(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      })), n.push.apply(n, r)
    }
    return n
  }

  function u(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = null != arguments[t] ? arguments[t] : {};
      t % 2 ? c(Object(n), !0).forEach(function(t) {
        l(e, t, n[t])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach(function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      })
    }
    return e
  }

  function h(e) {
    return e + .5 | 0
  }
  const d = (e, t, n) => Math.max(Math.min(e, n), t);

  function f(e) {
    return d(h(2.55 * e), 0, 255)
  }

  function p(e) {
    return d(h(255 * e), 0, 255)
  }

  function g(e) {
    return d(h(e / 2.55) / 100, 0, 1)
  }

  function m(e) {
    return d(h(100 * e), 0, 100)
  }
  const y = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    },
    v = [..."0123456789ABCDEF"],
    b = e => v[15 & e],
    w = e => v[(240 & e) >> 4] + v[15 & e],
    _ = e => (240 & e) >> 4 === (15 & e);

  function x(e) {
    var t = (e => _(e.r) && _(e.g) && _(e.b) && _(e.a))(e) ? b : w;
    return e ? "#" + t(e.r) + t(e.g) + t(e.b) + ((e, t) => e < 255 ? t(e) : "")(e.a, t) : void 0
  }
  const k = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

  function S(e, t, n) {
    const r = t * Math.min(n, 1 - n),
      i = function(t) {
        let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (t + e / 30) % 12;
        return n - r * Math.max(Math.min(i - 3, 9 - i, 1), -1)
      };
    return [i(0), i(8), i(4)]
  }

  function E(e, t, n) {
    const r = function(r) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (r + e / 60) % 6;
      return n - n * t * Math.max(Math.min(i, 4 - i, 1), 0)
    };
    return [r(5), r(3), r(1)]
  }

  function T(e, t, n) {
    const r = S(e, 1, .5);
    let i;
    for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++) r[i] *= 1 - t - n, r[i] += t;
    return r
  }

  function C(e) {
    const t = e.r / 255,
      n = e.g / 255,
      r = e.b / 255,
      i = Math.max(t, n, r),
      s = Math.min(t, n, r),
      o = (i + s) / 2;
    let a, l, c;
    return i !== s && (c = i - s, l = o > .5 ? c / (2 - i - s) : c / (i + s), a = function(e, t, n, r, i) {
      return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4
    }(t, n, r, c, i), a = 60 * a + .5), [0 | a, l || 0, o]
  }

  function O(e, t, n, r) {
    return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(p)
  }

  function P(e, t, n) {
    return O(S, e, t, n)
  }

  function A(e) {
    return (e % 360 + 360) % 360
  }

  function R(e) {
    const t = k.exec(e);
    let n, r = 255;
    if (!t) return;
    t[5] !== n && (r = t[6] ? f(+t[5]) : p(+t[5]));
    const i = A(+t[2]),
      s = +t[3] / 100,
      o = +t[4] / 100;
    return n = "hwb" === t[1] ? function(e, t, n) {
      return O(T, e, t, n)
    }(i, s, o) : "hsv" === t[1] ? function(e, t, n) {
      return O(E, e, t, n)
    }(i, s, o) : P(i, s, o), {
      r: n[0],
      g: n[1],
      b: n[2],
      a: r
    }
  }
  const M = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    },
    L = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
  let j;

  function N(e) {
    j || (j = function() {
      const e = {},
        t = Object.keys(L),
        n = Object.keys(M);
      let r, i, s, o, a;
      for (r = 0; r < t.length; r++) {
        for (o = a = t[r], i = 0; i < n.length; i++) s = n[i], a = a.replace(s, M[s]);
        s = parseInt(L[o], 16), e[a] = [s >> 16 & 255, s >> 8 & 255, 255 & s]
      }
      return e
    }(), j.transparent = [0, 0, 0, 0]);
    const t = j[e.toLowerCase()];
    return t && {
      r: t[0],
      g: t[1],
      b: t[2],
      a: 4 === t.length ? t[3] : 255
    }
  }
  const I = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  const D = e => e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055,
    z = e => e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);

  function F(e, t, n) {
    if (e) {
      let r = C(e);
      r[t] = Math.max(0, Math.min(r[t] + r[t] * n, 0 === t ? 360 : 1)), r = P(r), e.r = r[0], e.g = r[1], e.b = r[2]
    }
  }

  function B(e, t) {
    return e ? Object.assign(t || {}, e) : e
  }

  function U(e) {
    var t = {
      r: 0,
      g: 0,
      b: 0,
      a: 255
    };
    return Array.isArray(e) ? e.length >= 3 && (t = {
      r: e[0],
      g: e[1],
      b: e[2],
      a: 255
    }, e.length > 3 && (t.a = p(e[3]))) : (t = B(e, {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    })).a = p(t.a), t
  }

  function W(e) {
    return "r" === e.charAt(0) ? function(e) {
      const t = I.exec(e);
      let n, r, i, s = 255;
      if (t) {
        if (t[7] !== n) {
          const e = +t[7];
          s = t[8] ? f(e) : d(255 * e, 0, 255)
        }
        return n = +t[1], r = +t[3], i = +t[5], n = 255 & (t[2] ? f(n) : d(n, 0, 255)), r = 255 & (t[4] ? f(r) : d(r, 0, 255)), i = 255 & (t[6] ? f(i) : d(i, 0, 255)), {
          r: n,
          g: r,
          b: i,
          a: s
        }
      }
    }(e) : R(e)
  }
  class H {
    constructor(e) {
      if (e instanceof H) return e;
      const t = typeof e;
      let n;
      "object" === t ? n = U(e) : "string" === t && (n = function(e) {
        var t, n = e.length;
        return "#" === e[0] && (4 === n || 5 === n ? t = {
          r: 255 & 17 * y[e[1]],
          g: 255 & 17 * y[e[2]],
          b: 255 & 17 * y[e[3]],
          a: 5 === n ? 17 * y[e[4]] : 255
        } : 7 !== n && 9 !== n || (t = {
          r: y[e[1]] << 4 | y[e[2]],
          g: y[e[3]] << 4 | y[e[4]],
          b: y[e[5]] << 4 | y[e[6]],
          a: 9 === n ? y[e[7]] << 4 | y[e[8]] : 255
        })), t
      }(e) || N(e) || W(e)), this._rgb = n, this._valid = !!n
    }
    get valid() {
      return this._valid
    }
    get rgb() {
      var e = B(this._rgb);
      return e && (e.a = g(e.a)), e
    }
    set rgb(e) {
      this._rgb = U(e)
    }
    rgbString() {
      return this._valid ? (e = this._rgb) && (e.a < 255 ? "rgba(".concat(e.r, ", ").concat(e.g, ", ").concat(e.b, ", ").concat(g(e.a), ")") : "rgb(".concat(e.r, ", ").concat(e.g, ", ").concat(e.b, ")")) : void 0;
      var e
    }
    hexString() {
      return this._valid ? x(this._rgb) : void 0
    }
    hslString() {
      return this._valid ? function(e) {
        if (!e) return;
        const t = C(e),
          n = t[0],
          r = m(t[1]),
          i = m(t[2]);
        return e.a < 255 ? "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(g(e.a), ")") : "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)")
      }(this._rgb) : void 0
    }
    mix(e, t) {
      if (e) {
        const n = this.rgb,
          r = e.rgb;
        let i;
        const s = t === i ? .5 : t,
          o = 2 * s - 1,
          a = n.a - r.a,
          l = ((o * a === -1 ? o : (o + a) / (1 + o * a)) + 1) / 2;
        i = 1 - l, n.r = 255 & l * n.r + i * r.r + .5, n.g = 255 & l * n.g + i * r.g + .5, n.b = 255 & l * n.b + i * r.b + .5, n.a = s * n.a + (1 - s) * r.a, this.rgb = n
      }
      return this
    }
    interpolate(e, t) {
      return e && (this._rgb = function(e, t, n) {
        const r = z(g(e.r)),
          i = z(g(e.g)),
          s = z(g(e.b));
        return {
          r: p(D(r + n * (z(g(t.r)) - r))),
          g: p(D(i + n * (z(g(t.g)) - i))),
          b: p(D(s + n * (z(g(t.b)) - s))),
          a: e.a + n * (t.a - e.a)
        }
      }(this._rgb, e._rgb, t)), this
    }
    clone() {
      return new H(this.rgb)
    }
    alpha(e) {
      return this._rgb.a = p(e), this
    }
    clearer(e) {
      return this._rgb.a *= 1 - e, this
    }
    greyscale() {
      const e = this._rgb,
        t = h(.3 * e.r + .59 * e.g + .11 * e.b);
      return e.r = e.g = e.b = t, this
    }
    opaquer(e) {
      return this._rgb.a *= 1 + e, this
    }
    negate() {
      const e = this._rgb;
      return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this
    }
    lighten(e) {
      return F(this._rgb, 2, e), this
    }
    darken(e) {
      return F(this._rgb, 2, -e), this
    }
    saturate(e) {
      return F(this._rgb, 1, e), this
    }
    desaturate(e) {
      return F(this._rgb, 1, -e), this
    }
    rotate(e) {
      return function(e, t) {
        var n = C(e);
        n[0] = A(n[0] + t), n = P(n), e.r = n[0], e.g = n[1], e.b = n[2]
      }(this._rgb, e), this
    }
  }

  function V() {}
  const q = (() => {
    let e = 0;
    return () => e++
  })();

  function K(e) {
    return null === e || void 0 === e
  }

  function $(e) {
    if (Array.isArray && Array.isArray(e)) return !0;
    const t = Object.prototype.toString.call(e);
    return "[object" === t.slice(0, 7) && "Array]" === t.slice(-6)
  }

  function Y(e) {
    return null !== e && "[object Object]" === Object.prototype.toString.call(e)
  }

  function J(e) {
    return ("number" === typeof e || e instanceof Number) && isFinite(+e)
  }

  function G(e, t) {
    return J(e) ? e : t
  }

  function Q(e, t) {
    return "undefined" === typeof e ? t : e
  }
  const X = (e, t) => "string" === typeof e && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;

  function Z(e, t, n) {
    if (e && "function" === typeof e.call) return e.apply(n, t)
  }

  function ee(e, t, n, r) {
    let i, s, o;
    if ($(e))
      if (s = e.length, r)
        for (i = s - 1; i >= 0; i--) t.call(n, e[i], i);
      else
        for (i = 0; i < s; i++) t.call(n, e[i], i);
    else if (Y(e))
      for (o = Object.keys(e), s = o.length, i = 0; i < s; i++) t.call(n, e[o[i]], o[i])
  }

  function te(e, t) {
    let n, r, i, s;
    if (!e || !t || e.length !== t.length) return !1;
    for (n = 0, r = e.length; n < r; ++n)
      if (i = e[n], s = t[n], i.datasetIndex !== s.datasetIndex || i.index !== s.index) return !1;
    return !0
  }

  function ne(e) {
    if ($(e)) return e.map(ne);
    if (Y(e)) {
      const t = Object.create(null),
        n = Object.keys(e),
        r = n.length;
      let i = 0;
      for (; i < r; ++i) t[n[i]] = ne(e[n[i]]);
      return t
    }
    return e
  }

  function re(e) {
    return -1 === ["__proto__", "prototype", "constructor"].indexOf(e)
  }

  function ie(e, t, n, r) {
    if (!re(e)) return;
    const i = t[e],
      s = n[e];
    Y(i) && Y(s) ? se(i, s, r) : t[e] = ne(s)
  }

  function se(e, t, n) {
    const r = $(t) ? t : [t],
      i = r.length;
    if (!Y(e)) return e;
    const s = (n = n || {}).merger || ie;
    let o;
    for (let a = 0; a < i; ++a) {
      if (o = r[a], !Y(o)) continue;
      const t = Object.keys(o);
      for (let r = 0, i = t.length; r < i; ++r) s(t[r], e, o, n)
    }
    return e
  }

  function oe(e, t) {
    return se(e, t, {
      merger: ae
    })
  }

  function ae(e, t, n) {
    if (!re(e)) return;
    const r = t[e],
      i = n[e];
    Y(r) && Y(i) ? oe(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = ne(i))
  }
  const le = {
    "": e => e,
    x: e => e.x,
    y: e => e.y
  };

  function ce(e, t) {
    const n = le[t] || (le[t] = function(e) {
      const t = function(e) {
        const t = e.split("."),
          n = [];
        let r = "";
        for (const i of t) r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = "");
        return n
      }(e);
      return e => {
        for (const n of t) {
          if ("" === n) break;
          e = e && e[n]
        }
        return e
      }
    }(t));
    return n(e)
  }

  function ue(e) {
    return e.charAt(0).toUpperCase() + e.slice(1)
  }
  const he = e => "undefined" !== typeof e,
    de = e => "function" === typeof e,
    fe = (e, t) => {
      if (e.size !== t.size) return !1;
      for (const n of e)
        if (!t.has(n)) return !1;
      return !0
    };
  const pe = Math.PI,
    ge = 2 * pe,
    me = ge + pe,
    ye = Number.POSITIVE_INFINITY,
    ve = pe / 180,
    be = pe / 2,
    we = pe / 4,
    _e = 2 * pe / 3,
    xe = Math.log10,
    ke = Math.sign;

  function Se(e, t, n) {
    return Math.abs(e - t) < n
  }

  function Ee(e) {
    const t = Math.round(e);
    e = Se(e, t, e / 1e3) ? t : e;
    const n = Math.pow(10, Math.floor(xe(e))),
      r = e / n;
    return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n
  }

  function Te(e) {
    return ! function(e) {
      return "symbol" === typeof e || "object" === typeof e && null !== e && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e)
    }(e) && !isNaN(parseFloat(e)) && isFinite(e)
  }

  function Ce(e, t, n) {
    let r, i, s;
    for (r = 0, i = e.length; r < i; r++) s = e[r][n], isNaN(s) || (t.min = Math.min(t.min, s), t.max = Math.max(t.max, s))
  }

  function Oe(e) {
    return e * (pe / 180)
  }

  function Pe(e) {
    return e * (180 / pe)
  }

  function Ae(e) {
    if (!J(e)) return;
    let t = 1,
      n = 0;
    for (; Math.round(e * t) / t !== e;) t *= 10, n++;
    return n
  }

  function Re(e, t) {
    const n = t.x - e.x,
      r = t.y - e.y,
      i = Math.sqrt(n * n + r * r);
    let s = Math.atan2(r, n);
    return s < -.5 * pe && (s += ge), {
      angle: s,
      distance: i
    }
  }

  function Me(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
  }

  function Le(e, t) {
    return (e - t + me) % ge - pe
  }

  function je(e) {
    return (e % ge + ge) % ge
  }

  function Ne(e, t, n, r) {
    const i = je(e),
      s = je(t),
      o = je(n),
      a = je(s - i),
      l = je(o - i),
      c = je(i - s),
      u = je(i - o);
    return i === s || i === o || r && s === o || a > l && c < u
  }

  function Ie(e, t, n) {
    return Math.max(t, Math.min(n, e))
  }

  function De(e, t, n) {
    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-6;
    return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r
  }

  function ze(e, t, n) {
    n = n || (n => e[n] < t);
    let r, i = e.length - 1,
      s = 0;
    for (; i - s > 1;) r = s + i >> 1, n(r) ? s = r : i = r;
    return {
      lo: s,
      hi: i
    }
  }
  const Fe = (e, t, n, r) => ze(e, n, r ? r => {
      const i = e[r][t];
      return i < n || i === n && e[r + 1][t] === n
    } : r => e[r][t] < n),
    Be = (e, t, n) => ze(e, n, r => e[r][t] >= n);
  const Ue = ["push", "pop", "shift", "splice", "unshift"];

  function We(e, t) {
    const n = e._chartjs;
    if (!n) return;
    const r = n.listeners,
      i = r.indexOf(t); - 1 !== i && r.splice(i, 1), r.length > 0 || (Ue.forEach(t => {
      delete e[t]
    }), delete e._chartjs)
  }

  function He(e) {
    const t = new Set(e);
    return t.size === e.length ? e : Array.from(t)
  }
  const Ve = "undefined" === typeof window ? function(e) {
    return e()
  } : window.requestAnimationFrame;

  function qe(e, t) {
    let n = [],
      r = !1;
    return function() {
      for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++) s[o] = arguments[o];
      n = s, r || (r = !0, Ve.call(window, () => {
        r = !1, e.apply(t, n)
      }))
    }
  }
  const Ke = e => "start" === e ? "left" : "end" === e ? "right" : "center",
    $e = (e, t, n) => "start" === e ? t : "end" === e ? n : (t + n) / 2;

  function Ye(e, t, n) {
    const r = t.length;
    let i = 0,
      s = r;
    if (e._sorted) {
      const {
        iScale: o,
        vScale: a,
        _parsed: l
      } = e, c = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, u = o.axis, {
        min: h,
        max: d,
        minDefined: f,
        maxDefined: p
      } = o.getUserBounds();
      if (f) {
        if (i = Math.min(Fe(l, u, h).lo, n ? r : Fe(t, u, o.getPixelForValue(h)).lo), c) {
          const e = l.slice(0, i + 1).reverse().findIndex(e => !K(e[a.axis]));
          i -= Math.max(0, e)
        }
        i = Ie(i, 0, r - 1)
      }
      if (p) {
        let e = Math.max(Fe(l, o.axis, d, !0).hi + 1, n ? 0 : Fe(t, u, o.getPixelForValue(d), !0).hi + 1);
        if (c) {
          const t = l.slice(e - 1).findIndex(e => !K(e[a.axis]));
          e += Math.max(0, t)
        }
        s = Ie(e, i, r) - i
      } else s = r - i
    }
    return {
      start: i,
      count: s
    }
  }

  function Je(e) {
    const {
      xScale: t,
      yScale: n,
      _scaleRanges: r
    } = e, i = {
      xmin: t.min,
      xmax: t.max,
      ymin: n.min,
      ymax: n.max
    };
    if (!r) return e._scaleRanges = i, !0;
    const s = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max;
    return Object.assign(r, i), s
  }
  const Ge = e => 0 === e || 1 === e,
    Qe = (e, t, n) => -Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * ge / n),
    Xe = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * ge / n) + 1,
    Ze = {
      linear: e => e,
      easeInQuad: e => e * e,
      easeOutQuad: e => -e * (e - 2),
      easeInOutQuad: e => (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1),
      easeInCubic: e => e * e * e,
      easeOutCubic: e => (e -= 1) * e * e + 1,
      easeInOutCubic: e => (e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2),
      easeInQuart: e => e * e * e * e,
      easeOutQuart: e => -((e -= 1) * e * e * e - 1),
      easeInOutQuart: e => (e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2),
      easeInQuint: e => e * e * e * e * e,
      easeOutQuint: e => (e -= 1) * e * e * e * e + 1,
      easeInOutQuint: e => (e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2),
      easeInSine: e => 1 - Math.cos(e * be),
      easeOutSine: e => Math.sin(e * be),
      easeInOutSine: e => -.5 * (Math.cos(pe * e) - 1),
      easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * (e - 1)),
      easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e),
      easeInOutExpo: e => Ge(e) ? e : e < .5 ? .5 * Math.pow(2, 10 * (2 * e - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * e - 1))),
      easeInCirc: e => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
      easeOutCirc: e => Math.sqrt(1 - (e -= 1) * e),
      easeInOutCirc: e => (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
      easeInElastic: e => Ge(e) ? e : Qe(e, .075, .3),
      easeOutElastic: e => Ge(e) ? e : Xe(e, .075, .3),
      easeInOutElastic(e) {
        const t = .1125;
        return Ge(e) ? e : e < .5 ? .5 * Qe(2 * e, t, .45) : .5 + .5 * Xe(2 * e - 1, t, .45)
      },
      easeInBack(e) {
        const t = 1.70158;
        return e * e * ((t + 1) * e - t)
      },
      easeOutBack(e) {
        const t = 1.70158;
        return (e -= 1) * e * ((t + 1) * e + t) + 1
      },
      easeInOutBack(e) {
        let t = 1.70158;
        return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2)
      },
      easeInBounce: e => 1 - Ze.easeOutBounce(1 - e),
      easeOutBounce(e) {
        const t = 7.5625,
          n = 2.75;
        return e < 1 / n ? t * e * e : e < 2 / n ? t * (e -= 1.5 / n) * e + .75 : e < 2.5 / n ? t * (e -= 2.25 / n) * e + .9375 : t * (e -= 2.625 / n) * e + .984375
      },
      easeInOutBounce: e => e < .5 ? .5 * Ze.easeInBounce(2 * e) : .5 * Ze.easeOutBounce(2 * e - 1) + .5
    };

  function et(e) {
    if (e && "object" === typeof e) {
      const t = e.toString();
      return "[object CanvasPattern]" === t || "[object CanvasGradient]" === t
    }
    return !1
  }

  function tt(e) {
    return et(e) ? e : new H(e)
  }

  function nt(e) {
    return et(e) ? e : new H(e).saturate(.5).darken(.1).hexString()
  }
  const rt = ["x", "y", "borderWidth", "radius", "tension"],
    it = ["color", "borderColor", "backgroundColor"];
  const st = new Map;

  function ot(e, t, n) {
    return function(e, t) {
      t = t || {};
      const n = e + JSON.stringify(t);
      let r = st.get(n);
      return r || (r = new Intl.NumberFormat(e, t), st.set(n, r)), r
    }(t, n).format(e)
  }
  const at = {
    values: e => $(e) ? e : "" + e,
    numeric(e, t, n) {
      if (0 === e) return "0";
      const r = this.chart.options.locale;
      let i, s = e;
      if (n.length > 1) {
        const t = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
        (t < 1e-4 || t > 1e15) && (i = "scientific"), s = function(e, t) {
          let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
          Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e));
          return n
        }(e, n)
      }
      const o = xe(Math.abs(s)),
        a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0),
        l = {
          notation: i,
          minimumFractionDigits: a,
          maximumFractionDigits: a
        };
      return Object.assign(l, this.options.ticks.format), ot(e, r, l)
    },
    logarithmic(e, t, n) {
      if (0 === e) return "0";
      const r = n[t].significand || e / Math.pow(10, Math.floor(xe(e)));
      return [1, 2, 3, 5, 10, 15].includes(r) || t > .8 * n.length ? at.numeric.call(this, e, t, n) : ""
    }
  };
  var lt = {
    formatters: at
  };
  const ct = Object.create(null),
    ut = Object.create(null);

  function ht(e, t) {
    if (!t) return e;
    const n = t.split(".");
    for (let r = 0, i = n.length; r < i; ++r) {
      const t = n[r];
      e = e[t] || (e[t] = Object.create(null))
    }
    return e
  }

  function dt(e, t, n) {
    return "string" === typeof t ? se(ht(e, t), n) : se(ht(e, ""), t)
  }
  class ft {
    constructor(e, t) {
      this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = e => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      }, this.hover = {}, this.hoverBackgroundColor = (e, t) => nt(t.backgroundColor), this.hoverBorderColor = (e, t) => nt(t.borderColor), this.hoverColor = (e, t) => nt(t.color), this.indexAxis = "x", this.interaction = {
        mode: "nearest",
        intersect: !0,
        includeInvisible: !1
      }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(t)
    }
    set(e, t) {
      return dt(this, e, t)
    }
    get(e) {
      return ht(this, e)
    }
    describe(e, t) {
      return dt(ut, e, t)
    }
    override(e, t) {
      return dt(ct, e, t)
    }
    route(e, t, n, r) {
      const i = ht(this, e),
        s = ht(this, n),
        o = "_" + t;
      Object.defineProperties(i, {
        [o]: {
          value: i[t],
          writable: !0
        },
        [t]: {
          enumerable: !0,
          get() {
            const e = this[o],
              t = s[r];
            return Y(e) ? Object.assign({}, t, e) : Q(e, t)
          },
          set(e) {
            this[o] = e
          }
        }
      })
    }
    apply(e) {
      e.forEach(e => e(this))
    }
  }
  var pt = new ft({
    _scriptable: e => !e.startsWith("on"),
    _indexable: e => "events" !== e,
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: !1,
      _indexable: !1
    }
  }, [function(e) {
    e.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    }), e.describe("animation", {
      _fallback: !1,
      _indexable: !1,
      _scriptable: e => "onProgress" !== e && "onComplete" !== e && "fn" !== e
    }), e.set("animations", {
      colors: {
        type: "color",
        properties: it
      },
      numbers: {
        type: "number",
        properties: rt
      }
    }), e.describe("animations", {
      _fallback: "animation"
    }), e.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: e => 0 | e
          }
        }
      }
    })
  }, function(e) {
    e.set("layout", {
      autoPadding: !0,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    })
  }, function(e) {
    e.set("scale", {
      display: !0,
      offset: !1,
      reverse: !1,
      beginAtZero: !1,
      bounds: "ticks",
      clip: !0,
      grace: 0,
      grid: {
        display: !0,
        lineWidth: 1,
        drawOnChartArea: !0,
        drawTicks: !0,
        tickLength: 8,
        tickWidth: (e, t) => t.lineWidth,
        tickColor: (e, t) => t.color,
        offset: !1
      },
      border: {
        display: !0,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: !1,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: !1,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: !0,
        autoSkip: !0,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: lt.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: !1,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
      _fallback: !1,
      _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && "callback" !== e && "parser" !== e,
      _indexable: e => "borderDash" !== e && "tickBorderDash" !== e && "dash" !== e
    }), e.describe("scales", {
      _fallback: "scale"
    }), e.describe("scale.ticks", {
      _scriptable: e => "backdropPadding" !== e && "callback" !== e,
      _indexable: e => "backdropPadding" !== e
    })
  }]);

  function gt(e, t, n, r, i) {
    let s = t[i];
    return s || (s = t[i] = e.measureText(i).width, n.push(i)), s > r && (r = s), r
  }

  function mt(e, t, n, r) {
    let i = (r = r || {}).data = r.data || {},
      s = r.garbageCollect = r.garbageCollect || [];
    r.font !== t && (i = r.data = {}, s = r.garbageCollect = [], r.font = t), e.save(), e.font = t;
    let o = 0;
    const a = n.length;
    let l, c, u, h, d;
    for (l = 0; l < a; l++)
      if (h = n[l], void 0 === h || null === h || $(h)) {
        if ($(h))
          for (c = 0, u = h.length; c < u; c++) d = h[c], void 0 === d || null === d || $(d) || (o = gt(e, i, s, o, d))
      } else o = gt(e, i, s, o, h);
    e.restore();
    const f = s.length / 2;
    if (f > n.length) {
      for (l = 0; l < f; l++) delete i[s[l]];
      s.splice(0, f)
    }
    return o
  }

  function yt(e, t, n) {
    const r = e.currentDevicePixelRatio,
      i = 0 !== n ? Math.max(n / 2, .5) : 0;
    return Math.round((t - i) * r) / r + i
  }

  function vt(e, t) {
    (t || e) && ((t = t || e.getContext("2d")).save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore())
  }

  function bt(e, t, n, r) {
    wt(e, t, n, r, null)
  }

  function wt(e, t, n, r, i) {
    let s, o, a, l, c, u, h, d;
    const f = t.pointStyle,
      p = t.rotation,
      g = t.radius;
    let m = (p || 0) * ve;
    if (f && "object" === typeof f && (s = f.toString(), "[object HTMLImageElement]" === s || "[object HTMLCanvasElement]" === s)) return e.save(), e.translate(n, r), e.rotate(m), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void e.restore();
    if (!(isNaN(g) || g <= 0)) {
      switch (e.beginPath(), f) {
        default:
          i ? e.ellipse(n, r, i / 2, g, 0, 0, ge) : e.arc(n, r, g, 0, ge), e.closePath();
          break;
        case "triangle":
          u = i ? i / 2 : g, e.moveTo(n + Math.sin(m) * u, r - Math.cos(m) * g), m += _e, e.lineTo(n + Math.sin(m) * u, r - Math.cos(m) * g), m += _e, e.lineTo(n + Math.sin(m) * u, r - Math.cos(m) * g), e.closePath();
          break;
        case "rectRounded":
          c = .516 * g, l = g - c, o = Math.cos(m + we) * l, h = Math.cos(m + we) * (i ? i / 2 - c : l), a = Math.sin(m + we) * l, d = Math.sin(m + we) * (i ? i / 2 - c : l), e.arc(n - h, r - a, c, m - pe, m - be), e.arc(n + d, r - o, c, m - be, m), e.arc(n + h, r + a, c, m, m + be), e.arc(n - d, r + o, c, m + be, m + pe), e.closePath();
          break;
        case "rect":
          if (!p) {
            l = Math.SQRT1_2 * g, u = i ? i / 2 : l, e.rect(n - u, r - l, 2 * u, 2 * l);
            break
          }
          m += we;
        case "rectRot":
          h = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - h, r - a), e.lineTo(n + d, r - o), e.lineTo(n + h, r + a), e.lineTo(n - d, r + o), e.closePath();
          break;
        case "crossRot":
          m += we;
        case "cross":
          h = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - h, r - a), e.lineTo(n + h, r + a), e.moveTo(n + d, r - o), e.lineTo(n - d, r + o);
          break;
        case "star":
          h = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - h, r - a), e.lineTo(n + h, r + a), e.moveTo(n + d, r - o), e.lineTo(n - d, r + o), m += we, h = Math.cos(m) * (i ? i / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - h, r - a), e.lineTo(n + h, r + a), e.moveTo(n + d, r - o), e.lineTo(n - d, r + o);
          break;
        case "line":
          o = i ? i / 2 : Math.cos(m) * g, a = Math.sin(m) * g, e.moveTo(n - o, r - a), e.lineTo(n + o, r + a);
          break;
        case "dash":
          e.moveTo(n, r), e.lineTo(n + Math.cos(m) * (i ? i / 2 : g), r + Math.sin(m) * g);
          break;
        case !1:
          e.closePath()
      }
      e.fill(), t.borderWidth > 0 && e.stroke()
    }
  }

  function _t(e, t, n) {
    return n = n || .5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n
  }

  function xt(e, t) {
    e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip()
  }

  function kt(e) {
    e.restore()
  }

  function St(e, t, n, r, i) {
    if (!t) return e.lineTo(n.x, n.y);
    if ("middle" === i) {
      const r = (t.x + n.x) / 2;
      e.lineTo(r, t.y), e.lineTo(r, n.y)
    } else "after" === i !== !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
    e.lineTo(n.x, n.y)
  }

  function Et(e, t, n, r) {
    if (!t) return e.lineTo(n.x, n.y);
    e.bezierCurveTo(r ? t.cp1x : t.cp2x, r ? t.cp1y : t.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y)
  }

  function Tt(e, t, n, r, i) {
    if (i.strikethrough || i.underline) {
      const s = e.measureText(r),
        o = t - s.actualBoundingBoxLeft,
        a = t + s.actualBoundingBoxRight,
        l = n - s.actualBoundingBoxAscent,
        c = n + s.actualBoundingBoxDescent,
        u = i.strikethrough ? (l + c) / 2 : c;
      e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(o, u), e.lineTo(a, u), e.stroke()
    }
  }

  function Ct(e, t) {
    const n = e.fillStyle;
    e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n
  }

  function Ot(e, t, n, r, i) {
    let s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
    const o = $(t) ? t : [t],
      a = s.strokeWidth > 0 && "" !== s.strokeColor;
    let l, c;
    for (e.save(), e.font = i.string, function(e, t) {
        t.translation && e.translate(t.translation[0], t.translation[1]), K(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline)
      }(e, s), l = 0; l < o.length; ++l) c = o[l], s.backdrop && Ct(e, s.backdrop), a && (s.strokeColor && (e.strokeStyle = s.strokeColor), K(s.strokeWidth) || (e.lineWidth = s.strokeWidth), e.strokeText(c, n, r, s.maxWidth)), e.fillText(c, n, r, s.maxWidth), Tt(e, n, r, c, s), r += Number(i.lineHeight);
    e.restore()
  }

  function Pt(e, t) {
    const {
      x: n,
      y: r,
      w: i,
      h: s,
      radius: o
    } = t;
    e.arc(n + o.topLeft, r + o.topLeft, o.topLeft, 1.5 * pe, pe, !0), e.lineTo(n, r + s - o.bottomLeft), e.arc(n + o.bottomLeft, r + s - o.bottomLeft, o.bottomLeft, pe, be, !0), e.lineTo(n + i - o.bottomRight, r + s), e.arc(n + i - o.bottomRight, r + s - o.bottomRight, o.bottomRight, be, 0, !0), e.lineTo(n + i, r + o.topRight), e.arc(n + i - o.topRight, r + o.topRight, o.topRight, 0, -be, !0), e.lineTo(n + o.topLeft, r)
  }
  const At = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
    Rt = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;

  function Mt(e, t) {
    const n = ("" + e).match(At);
    if (!n || "normal" === n[1]) return 1.2 * t;
    switch (e = +n[2], n[3]) {
      case "px":
        return e;
      case "%":
        e /= 100
    }
    return t * e
  }
  const Lt = e => +e || 0;

  function jt(e, t) {
    const n = {},
      r = Y(t),
      i = r ? Object.keys(t) : t,
      s = Y(e) ? r ? n => Q(e[n], e[t[n]]) : t => e[t] : () => e;
    for (const o of i) n[o] = Lt(s(o));
    return n
  }

  function Nt(e) {
    return jt(e, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    })
  }

  function It(e) {
    return jt(e, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
  }

  function Dt(e) {
    const t = Nt(e);
    return t.width = t.left + t.right, t.height = t.top + t.bottom, t
  }

  function zt(e, t) {
    e = e || {}, t = t || pt.font;
    let n = Q(e.size, t.size);
    "string" === typeof n && (n = parseInt(n, 10));
    let r = Q(e.style, t.style);
    r && !("" + r).match(Rt) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
    const i = {
      family: Q(e.family, t.family),
      lineHeight: Mt(Q(e.lineHeight, t.lineHeight), n),
      size: n,
      style: r,
      weight: Q(e.weight, t.weight),
      string: ""
    };
    return i.string = function(e) {
      return !e || K(e.size) || K(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family
    }(i), i
  }

  function Ft(e, t, n, r) {
    let i, s, o, a = !0;
    for (i = 0, s = e.length; i < s; ++i)
      if (o = e[i], void 0 !== o && (void 0 !== t && "function" === typeof o && (o = o(t), a = !1), void 0 !== n && $(o) && (o = o[n % o.length], a = !1), void 0 !== o)) return r && !a && (r.cacheable = !1), o
  }

  function Bt(e, t) {
    return Object.assign(Object.create(e), t)
  }

  function Ut(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [""],
      n = arguments.length > 3 ? arguments[3] : void 0,
      r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : () => e[0];
    const i = (arguments.length > 2 ? arguments[2] : void 0) || e;
    "undefined" === typeof n && (n = Xt("_fallback", e));
    const s = {
      [Symbol.toStringTag]: "Object",
      _cacheable: !0,
      _scopes: e,
      _rootScopes: i,
      _fallback: n,
      _getTarget: r,
      override: r => Ut([r, ...e], t, i, n)
    };
    return new Proxy(s, {
      deleteProperty: (t, n) => (delete t[n], delete t._keys, delete e[0][n], !0),
      get: (n, r) => Kt(n, r, () => function(e, t, n, r) {
        let i;
        for (const s of t)
          if (i = Xt(Vt(s, e), n), "undefined" !== typeof i) return qt(e, i) ? Gt(n, r, e, i) : i
      }(r, t, e, n)),
      getOwnPropertyDescriptor: (e, t) => Reflect.getOwnPropertyDescriptor(e._scopes[0], t),
      getPrototypeOf: () => Reflect.getPrototypeOf(e[0]),
      has: (e, t) => Zt(e).includes(t),
      ownKeys: e => Zt(e),
      set(e, t, n) {
        const i = e._storage || (e._storage = r());
        return e[t] = i[t] = n, delete e._keys, !0
      }
    })
  }

  function Wt(e, t, n, r) {
    const i = {
      _cacheable: !1,
      _proxy: e,
      _context: t,
      _subProxy: n,
      _stack: new Set,
      _descriptors: Ht(e, r),
      setContext: t => Wt(e, t, n, r),
      override: i => Wt(e.override(i), t, n, r)
    };
    return new Proxy(i, {
      deleteProperty: (t, n) => (delete t[n], delete e[n], !0),
      get: (e, t, n) => Kt(e, t, () => function(e, t, n) {
        const {
          _proxy: r,
          _context: i,
          _subProxy: s,
          _descriptors: o
        } = e;
        let a = r[t];
        de(a) && o.isScriptable(t) && (a = function(e, t, n, r) {
          const {
            _proxy: i,
            _context: s,
            _subProxy: o,
            _stack: a
          } = n;
          if (a.has(e)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e);
          a.add(e);
          let l = t(s, o || r);
          a.delete(e), qt(e, l) && (l = Gt(i._scopes, i, e, l));
          return l
        }(t, a, e, n));
        $(a) && a.length && (a = function(e, t, n, r) {
          const {
            _proxy: i,
            _context: s,
            _subProxy: o,
            _descriptors: a
          } = n;
          if ("undefined" !== typeof s.index && r(e)) return t[s.index % t.length];
          if (Y(t[0])) {
            const n = t,
              r = i._scopes.filter(e => e !== n);
            t = [];
            for (const l of n) {
              const n = Gt(r, i, e, l);
              t.push(Wt(n, s, o && o[e], a))
            }
          }
          return t
        }(t, a, e, o.isIndexable));
        qt(t, a) && (a = Wt(a, i, s && s[t], o));
        return a
      }(e, t, n)),
      getOwnPropertyDescriptor: (t, n) => t._descriptors.allKeys ? Reflect.has(e, n) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, n),
      getPrototypeOf: () => Reflect.getPrototypeOf(e),
      has: (t, n) => Reflect.has(e, n),
      ownKeys: () => Reflect.ownKeys(e),
      set: (t, n, r) => (e[n] = r, delete t[n], !0)
    })
  }

  function Ht(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
      scriptable: !0,
      indexable: !0
    };
    const {
      _scriptable: n = t.scriptable,
      _indexable: r = t.indexable,
      _allKeys: i = t.allKeys
    } = e;
    return {
      allKeys: i,
      scriptable: n,
      indexable: r,
      isScriptable: de(n) ? n : () => n,
      isIndexable: de(r) ? r : () => r
    }
  }
  const Vt = (e, t) => e ? e + ue(t) : t,
    qt = (e, t) => Y(t) && "adapters" !== e && (null === Object.getPrototypeOf(t) || t.constructor === Object);

  function Kt(e, t, n) {
    if (Object.prototype.hasOwnProperty.call(e, t) || "constructor" === t) return e[t];
    const r = n();
    return e[t] = r, r
  }

  function $t(e, t, n) {
    return de(e) ? e(t, n) : e
  }
  const Yt = (e, t) => !0 === e ? t : "string" === typeof e ? ce(t, e) : void 0;

  function Jt(e, t, n, r, i) {
    for (const s of t) {
      const t = Yt(n, s);
      if (t) {
        e.add(t);
        const s = $t(t._fallback, n, i);
        if ("undefined" !== typeof s && s !== n && s !== r) return s
      } else if (!1 === t && "undefined" !== typeof r && n !== r) return null
    }
    return !1
  }

  function Gt(e, t, n, r) {
    const i = t._rootScopes,
      s = $t(t._fallback, n, r),
      o = [...e, ...i],
      a = new Set;
    a.add(r);
    let l = Qt(a, o, n, s || n, r);
    return null !== l && (("undefined" === typeof s || s === n || (l = Qt(a, o, s, l, r), null !== l)) && Ut(Array.from(a), [""], i, s, () => function(e, t, n) {
      const r = e._getTarget();
      t in r || (r[t] = {});
      const i = r[t];
      if ($(i) && Y(n)) return n;
      return i || {}
    }(t, n, r)))
  }

  function Qt(e, t, n, r, i) {
    for (; n;) n = Jt(e, t, n, r, i);
    return n
  }

  function Xt(e, t) {
    for (const n of t) {
      if (!n) continue;
      const t = n[e];
      if ("undefined" !== typeof t) return t
    }
  }

  function Zt(e) {
    let t = e._keys;
    return t || (t = e._keys = function(e) {
      const t = new Set;
      for (const n of e)
        for (const e of Object.keys(n).filter(e => !e.startsWith("_"))) t.add(e);
      return Array.from(t)
    }(e._scopes)), t
  }

  function en(e, t, n, r) {
    const {
      iScale: i
    } = e, {
      key: s = "r"
    } = this._parsing, o = new Array(r);
    let a, l, c, u;
    for (a = 0, l = r; a < l; ++a) c = a + n, u = t[c], o[a] = {
      r: i.parse(ce(u, s), c)
    };
    return o
  }
  const tn = Number.EPSILON || 1e-14,
    nn = (e, t) => t < e.length && !e[t].skip && e[t],
    rn = e => "x" === e ? "y" : "x";

  function sn(e, t, n, r) {
    const i = e.skip ? t : e,
      s = t,
      o = n.skip ? t : n,
      a = Me(s, i),
      l = Me(o, s);
    let c = a / (a + l),
      u = l / (a + l);
    c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
    const h = r * c,
      d = r * u;
    return {
      previous: {
        x: s.x - h * (o.x - i.x),
        y: s.y - h * (o.y - i.y)
      },
      next: {
        x: s.x + d * (o.x - i.x),
        y: s.y + d * (o.y - i.y)
      }
    }
  }

  function on(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x";
    const n = rn(t),
      r = e.length,
      i = Array(r).fill(0),
      s = Array(r);
    let o, a, l, c = nn(e, 0);
    for (o = 0; o < r; ++o)
      if (a = l, l = c, c = nn(e, o + 1), l) {
        if (c) {
          const e = c[t] - l[t];
          i[o] = 0 !== e ? (c[n] - l[n]) / e : 0
        }
        s[o] = a ? c ? ke(i[o - 1]) !== ke(i[o]) ? 0 : (i[o - 1] + i[o]) / 2 : i[o - 1] : i[o]
      }!
    function(e, t, n) {
      const r = e.length;
      let i, s, o, a, l, c = nn(e, 0);
      for (let u = 0; u < r - 1; ++u) l = c, c = nn(e, u + 1), l && c && (Se(t[u], 0, tn) ? n[u] = n[u + 1] = 0 : (i = n[u] / t[u], s = n[u + 1] / t[u], a = Math.pow(i, 2) + Math.pow(s, 2), a <= 9 || (o = 3 / Math.sqrt(a), n[u] = i * o * t[u], n[u + 1] = s * o * t[u])))
    }(e, i, s),
    function(e, t) {
      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "x";
      const r = rn(n),
        i = e.length;
      let s, o, a, l = nn(e, 0);
      for (let c = 0; c < i; ++c) {
        if (o = a, a = l, l = nn(e, c + 1), !a) continue;
        const i = a[n],
          u = a[r];
        o && (s = (i - o[n]) / 3, a["cp1".concat(n)] = i - s, a["cp1".concat(r)] = u - s * t[c]), l && (s = (l[n] - i) / 3, a["cp2".concat(n)] = i + s, a["cp2".concat(r)] = u + s * t[c])
      }
    }(e, s, t)
  }

  function an(e, t, n) {
    return Math.max(Math.min(e, n), t)
  }

  function ln(e, t, n, r, i) {
    let s, o, a, l;
    if (t.spanGaps && (e = e.filter(e => !e.skip)), "monotone" === t.cubicInterpolationMode) on(e, i);
    else {
      let n = r ? e[e.length - 1] : e[0];
      for (s = 0, o = e.length; s < o; ++s) a = e[s], l = sn(n, a, e[Math.min(s + 1, o - (r ? 0 : 1)) % o], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, n = a
    }
    t.capBezierPoints && function(e, t) {
      let n, r, i, s, o, a = _t(e[0], t);
      for (n = 0, r = e.length; n < r; ++n) o = s, s = a, a = n < r - 1 && _t(e[n + 1], t), s && (i = e[n], o && (i.cp1x = an(i.cp1x, t.left, t.right), i.cp1y = an(i.cp1y, t.top, t.bottom)), a && (i.cp2x = an(i.cp2x, t.left, t.right), i.cp2y = an(i.cp2y, t.top, t.bottom)))
    }(e, n)
  }

  function cn() {
    return "undefined" !== typeof window && "undefined" !== typeof document
  }

  function un(e) {
    let t = e.parentNode;
    return t && "[object ShadowRoot]" === t.toString() && (t = t.host), t
  }

  function hn(e, t, n) {
    let r;
    return "string" === typeof e ? (r = parseInt(e, 10), -1 !== e.indexOf("%") && (r = r / 100 * t.parentNode[n])) : r = e, r
  }
  const dn = e => e.ownerDocument.defaultView.getComputedStyle(e, null);
  const fn = ["top", "right", "bottom", "left"];

  function pn(e, t, n) {
    const r = {};
    n = n ? "-" + n : "";
    for (let i = 0; i < 4; i++) {
      const s = fn[i];
      r[s] = parseFloat(e[t + "-" + s + n]) || 0
    }
    return r.width = r.left + r.right, r.height = r.top + r.bottom, r
  }

  function gn(e, t) {
    if ("native" in e) return e;
    const {
      canvas: n,
      currentDevicePixelRatio: r
    } = t, i = dn(n), s = "border-box" === i.boxSizing, o = pn(i, "padding"), a = pn(i, "border", "width"), {
      x: l,
      y: c,
      box: u
    } = function(e, t) {
      const n = e.touches,
        r = n && n.length ? n[0] : e,
        {
          offsetX: i,
          offsetY: s
        } = r;
      let o, a, l = !1;
      if (((e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot))(i, s, e.target)) o = i, a = s;
      else {
        const e = t.getBoundingClientRect();
        o = r.clientX - e.left, a = r.clientY - e.top, l = !0
      }
      return {
        x: o,
        y: a,
        box: l
      }
    }(e, n), h = o.left + (u && a.left), d = o.top + (u && a.top);
    let {
      width: f,
      height: p
    } = t;
    return s && (f -= o.width + a.width, p -= o.height + a.height), {
      x: Math.round((l - h) / f * n.width / r),
      y: Math.round((c - d) / p * n.height / r)
    }
  }
  const mn = e => Math.round(10 * e) / 10;

  function yn(e, t, n, r) {
    const i = dn(e),
      s = pn(i, "margin"),
      o = hn(i.maxWidth, e, "clientWidth") || ye,
      a = hn(i.maxHeight, e, "clientHeight") || ye,
      l = function(e, t, n) {
        let r, i;
        if (void 0 === t || void 0 === n) {
          const s = e && un(e);
          if (s) {
            const e = s.getBoundingClientRect(),
              o = dn(s),
              a = pn(o, "border", "width"),
              l = pn(o, "padding");
            t = e.width - l.width - a.width, n = e.height - l.height - a.height, r = hn(o.maxWidth, s, "clientWidth"), i = hn(o.maxHeight, s, "clientHeight")
          } else t = e.clientWidth, n = e.clientHeight
        }
        return {
          width: t,
          height: n,
          maxWidth: r || ye,
          maxHeight: i || ye
        }
      }(e, t, n);
    let {
      width: c,
      height: u
    } = l;
    if ("content-box" === i.boxSizing) {
      const e = pn(i, "border", "width"),
        t = pn(i, "padding");
      c -= t.width + e.width, u -= t.height + e.height
    }
    c = Math.max(0, c - s.width), u = Math.max(0, r ? c / r : u - s.height), c = mn(Math.min(c, o, l.maxWidth)), u = mn(Math.min(u, a, l.maxHeight)), c && !u && (u = mn(c / 2));
    return (void 0 !== t || void 0 !== n) && r && l.height && u > l.height && (u = l.height, c = mn(Math.floor(u * r))), {
      width: c,
      height: u
    }
  }

  function vn(e, t, n) {
    const r = t || 1,
      i = mn(e.height * r),
      s = mn(e.width * r);
    e.height = mn(e.height), e.width = mn(e.width);
    const o = e.canvas;
    return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = "".concat(e.height, "px"), o.style.width = "".concat(e.width, "px")), (e.currentDevicePixelRatio !== r || o.height !== i || o.width !== s) && (e.currentDevicePixelRatio = r, o.height = i, o.width = s, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0)
  }
  const bn = function() {
    let e = !1;
    try {
      const t = {
        get passive() {
          return e = !0, !1
        }
      };
      cn() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t))
    } catch (t) {}
    return e
  }();

  function wn(e, t) {
    const n = function(e, t) {
        return dn(e).getPropertyValue(t)
      }(e, t),
      r = n && n.match(/^(\d+)(\.\d+)?px$/);
    return r ? +r[1] : void 0
  }

  function _n(e, t, n, r) {
    return {
      x: e.x + n * (t.x - e.x),
      y: e.y + n * (t.y - e.y)
    }
  }

  function xn(e, t, n, r) {
    return {
      x: e.x + n * (t.x - e.x),
      y: "middle" === r ? n < .5 ? e.y : t.y : "after" === r ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
    }
  }

  function kn(e, t, n, r) {
    const i = {
        x: e.cp2x,
        y: e.cp2y
      },
      s = {
        x: t.cp1x,
        y: t.cp1y
      },
      o = _n(e, i, n),
      a = _n(i, s, n),
      l = _n(s, t, n),
      c = _n(o, a, n),
      u = _n(a, l, n);
    return _n(c, u, n)
  }

  function Sn(e, t, n) {
    return e ? function(e, t) {
      return {
        x: n => e + e + t - n,
        setWidth(e) {
          t = e
        },
        textAlign: e => "center" === e ? e : "right" === e ? "left" : "right",
        xPlus: (e, t) => e - t,
        leftForLtr: (e, t) => e - t
      }
    }(t, n) : {
      x: e => e,
      setWidth(e) {},
      textAlign: e => e,
      xPlus: (e, t) => e + t,
      leftForLtr: (e, t) => e
    }
  }

  function En(e, t) {
    let n, r;
    "ltr" !== t && "rtl" !== t || (n = e.canvas.style, r = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", t, "important"), e.prevTextDirection = r)
  }

  function Tn(e, t) {
    void 0 !== t && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]))
  }

  function Cn(e) {
    return "angle" === e ? {
      between: Ne,
      compare: Le,
      normalize: je
    } : {
      between: De,
      compare: (e, t) => e - t,
      normalize: e => e
    }
  }

  function On(e) {
    let {
      start: t,
      end: n,
      count: r,
      loop: i,
      style: s
    } = e;
    return {
      start: t % r,
      end: n % r,
      loop: i && (n - t + 1) % r === 0,
      style: s
    }
  }

  function Pn(e, t, n) {
    if (!n) return [e];
    const {
      property: r,
      start: i,
      end: s
    } = n, o = t.length, {
      compare: a,
      between: l,
      normalize: c
    } = Cn(r), {
      start: u,
      end: h,
      loop: d,
      style: f
    } = function(e, t, n) {
      const {
        property: r,
        start: i,
        end: s
      } = n, {
        between: o,
        normalize: a
      } = Cn(r), l = t.length;
      let c, u, {
        start: h,
        end: d,
        loop: f
      } = e;
      if (f) {
        for (h += l, d += l, c = 0, u = l; c < u && o(a(t[h % l][r]), i, s); ++c) h--, d--;
        h %= l, d %= l
      }
      return d < h && (d += l), {
        start: h,
        end: d,
        loop: f,
        style: e.style
      }
    }(e, t, n), p = [];
    let g, m, y, v = !1,
      b = null;
    const w = () => v || l(i, y, g) && 0 !== a(i, y),
      _ = () => !v || 0 === a(s, g) || l(s, y, g);
    for (let x = u, k = u; x <= h; ++x) m = t[x % o], m.skip || (g = c(m[r]), g !== y && (v = l(g, i, s), null === b && w() && (b = 0 === a(g, i) ? x : k), null !== b && _() && (p.push(On({
      start: b,
      end: x,
      loop: d,
      count: o,
      style: f
    })), b = null), k = x, y = g));
    return null !== b && p.push(On({
      start: b,
      end: h,
      loop: d,
      count: o,
      style: f
    })), p
  }

  function An(e, t) {
    const n = [],
      r = e.segments;
    for (let i = 0; i < r.length; i++) {
      const s = Pn(r[i], e.points, t);
      s.length && n.push(...s)
    }
    return n
  }

  function Rn(e, t, n, r) {
    return r && r.setContext && n ? function(e, t, n, r) {
      const i = e._chart.getContext(),
        s = Mn(e.options),
        {
          _datasetIndex: o,
          options: {
            spanGaps: a
          }
        } = e,
        l = n.length,
        c = [];
      let u = s,
        h = t[0].start,
        d = h;

      function f(e, t, r, i) {
        const s = a ? -1 : 1;
        if (e !== t) {
          for (e += l; n[e % l].skip;) e -= s;
          for (; n[t % l].skip;) t += s;
          e % l !== t % l && (c.push({
            start: e % l,
            end: t % l,
            loop: r,
            style: i
          }), u = i, h = t % l)
        }
      }
      for (const p of t) {
        h = a ? h : p.start;
        let e, t = n[h % l];
        for (d = h + 1; d <= p.end; d++) {
          const s = n[d % l];
          e = Mn(r.setContext(Bt(i, {
            type: "segment",
            p0: t,
            p1: s,
            p0DataIndex: (d - 1) % l,
            p1DataIndex: d % l,
            datasetIndex: o
          }))), Ln(e, u) && f(h, d - 1, p.loop, u), t = s, u = e
        }
        h < d - 1 && f(h, d - 1, p.loop, u)
      }
      return c
    }(e, t, n, r) : t
  }

  function Mn(e) {
    return {
      backgroundColor: e.backgroundColor,
      borderCapStyle: e.borderCapStyle,
      borderDash: e.borderDash,
      borderDashOffset: e.borderDashOffset,
      borderJoinStyle: e.borderJoinStyle,
      borderWidth: e.borderWidth,
      borderColor: e.borderColor
    }
  }

  function Ln(e, t) {
    if (!t) return !1;
    const n = [],
      r = function(e, t) {
        return et(t) ? (n.includes(t) || n.push(t), n.indexOf(t)) : t
      };
    return JSON.stringify(e, r) !== JSON.stringify(t, r)
  }

  function jn(e, t, n) {
    return e.options.clip ? e[n] : t[n]
  }

  function Nn(e, t) {
    const n = t._clip;
    if (n.disabled) return !1;
    const r = function(e, t) {
      const {
        xScale: n,
        yScale: r
      } = e;
      return n && r ? {
        left: jn(n, t, "left"),
        right: jn(n, t, "right"),
        top: jn(r, t, "top"),
        bottom: jn(r, t, "bottom")
      } : t
    }(t, e.chartArea);
    return {
      left: !1 === n.left ? 0 : r.left - (!0 === n.left ? 0 : n.left),
      right: !1 === n.right ? e.width : r.right + (!0 === n.right ? 0 : n.right),
      top: !1 === n.top ? 0 : r.top - (!0 === n.top ? 0 : n.top),
      bottom: !1 === n.bottom ? e.height : r.bottom + (!0 === n.bottom ? 0 : n.bottom)
    }
  }
  class In {
    constructor() {
      this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
    }
    _notify(e, t, n, r) {
      const i = t.listeners[r],
        s = t.duration;
      i.forEach(r => r({
        chart: e,
        initial: t.initial,
        numSteps: s,
        currentStep: Math.min(n - t.start, s)
      }))
    }
    _refresh() {
      this._request || (this._running = !0, this._request = Ve.call(window, () => {
        this._update(), this._request = null, this._running && this._refresh()
      }))
    }
    _update() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Date.now(),
        t = 0;
      this._charts.forEach((n, r) => {
        if (!n.running || !n.items.length) return;
        const i = n.items;
        let s, o = i.length - 1,
          a = !1;
        for (; o >= 0; --o) s = i[o], s._active ? (s._total > n.duration && (n.duration = s._total), s.tick(e), a = !0) : (i[o] = i[i.length - 1], i.pop());
        a && (r.draw(), this._notify(r, n, e, "progress")), i.length || (n.running = !1, this._notify(r, n, e, "complete"), n.initial = !1), t += i.length
      }), this._lastDate = e, 0 === t && (this._running = !1)
    }
    _getAnims(e) {
      const t = this._charts;
      let n = t.get(e);
      return n || (n = {
        running: !1,
        initial: !0,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      }, t.set(e, n)), n
    }
    listen(e, t, n) {
      this._getAnims(e).listeners[t].push(n)
    }
    add(e, t) {
      t && t.length && this._getAnims(e).items.push(...t)
    }
    has(e) {
      return this._getAnims(e).items.length > 0
    }
    start(e) {
      const t = this._charts.get(e);
      t && (t.running = !0, t.start = Date.now(), t.duration = t.items.reduce((e, t) => Math.max(e, t._duration), 0), this._refresh())
    }
    running(e) {
      if (!this._running) return !1;
      const t = this._charts.get(e);
      return !!(t && t.running && t.items.length)
    }
    stop(e) {
      const t = this._charts.get(e);
      if (!t || !t.items.length) return;
      const n = t.items;
      let r = n.length - 1;
      for (; r >= 0; --r) n[r].cancel();
      t.items = [], this._notify(e, t, Date.now(), "complete")
    }
    remove(e) {
      return this._charts.delete(e)
    }
  }
  var Dn = new In;
  const zn = "transparent",
    Fn = {
      boolean: (e, t, n) => n > .5 ? t : e,
      color(e, t, n) {
        const r = tt(e || zn),
          i = r.valid && tt(t || zn);
        return i && i.valid ? i.mix(r, n).hexString() : t
      },
      number: (e, t, n) => e + (t - e) * n
    };
  class Bn {
    constructor(e, t, n, r) {
      const i = t[n];
      r = Ft([e.to, r, i, e.from]);
      const s = Ft([e.from, i, r]);
      this._active = !0, this._fn = e.fn || Fn[e.type || typeof s], this._easing = Ze[e.easing] || Ze.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = t, this._prop = n, this._from = s, this._to = r, this._promises = void 0
    }
    active() {
      return this._active
    }
    update(e, t, n) {
      if (this._active) {
        this._notify(!1);
        const r = this._target[this._prop],
          i = n - this._start,
          s = this._duration - i;
        this._start = n, this._duration = Math.floor(Math.max(s, e.duration)), this._total += i, this._loop = !!e.loop, this._to = Ft([e.to, t, r, e.from]), this._from = Ft([e.from, r, t])
      }
    }
    cancel() {
      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
    }
    tick(e) {
      const t = e - this._start,
        n = this._duration,
        r = this._prop,
        i = this._from,
        s = this._loop,
        o = this._to;
      let a;
      if (this._active = i !== o && (s || t < n), !this._active) return this._target[r] = o, void this._notify(!0);
      t < 0 ? this._target[r] = i : (a = t / n % 2, a = s && a > 1 ? 2 - a : a, a = this._easing(Math.min(1, Math.max(0, a))), this._target[r] = this._fn(i, o, a))
    }
    wait() {
      const e = this._promises || (this._promises = []);
      return new Promise((t, n) => {
        e.push({
          res: t,
          rej: n
        })
      })
    }
    _notify(e) {
      const t = e ? "res" : "rej",
        n = this._promises || [];
      for (let r = 0; r < n.length; r++) n[r][t]()
    }
  }
  class Un {
    constructor(e, t) {
      this._chart = e, this._properties = new Map, this.configure(t)
    }
    configure(e) {
      if (!Y(e)) return;
      const t = Object.keys(pt.animation),
        n = this._properties;
      Object.getOwnPropertyNames(e).forEach(r => {
        const i = e[r];
        if (!Y(i)) return;
        const s = {};
        for (const e of t) s[e] = i[e];
        ($(i.properties) && i.properties || [r]).forEach(e => {
          e !== r && n.has(e) || n.set(e, s)
        })
      })
    }
    _animateOptions(e, t) {
      const n = t.options,
        r = function(e, t) {
          if (!t) return;
          let n = e.options;
          if (!n) return void(e.options = t);
          n.$shared && (e.options = n = Object.assign({}, n, {
            $shared: !1,
            $animations: {}
          }));
          return n
        }(e, n);
      if (!r) return [];
      const i = this._createAnimations(r, n);
      return n.$shared && function(e, t) {
        const n = [],
          r = Object.keys(t);
        for (let i = 0; i < r.length; i++) {
          const t = e[r[i]];
          t && t.active() && n.push(t.wait())
        }
        return Promise.all(n)
      }(e.options.$animations, n).then(() => {
        e.options = n
      }, () => {}), i
    }
    _createAnimations(e, t) {
      const n = this._properties,
        r = [],
        i = e.$animations || (e.$animations = {}),
        s = Object.keys(t),
        o = Date.now();
      let a;
      for (a = s.length - 1; a >= 0; --a) {
        const l = s[a];
        if ("$" === l.charAt(0)) continue;
        if ("options" === l) {
          r.push(...this._animateOptions(e, t));
          continue
        }
        const c = t[l];
        let u = i[l];
        const h = n.get(l);
        if (u) {
          if (h && u.active()) {
            u.update(h, c, o);
            continue
          }
          u.cancel()
        }
        h && h.duration ? (i[l] = u = new Bn(h, e, l, c), r.push(u)) : e[l] = c
      }
      return r
    }
    update(e, t) {
      if (0 === this._properties.size) return void Object.assign(e, t);
      const n = this._createAnimations(e, t);
      return n.length ? (Dn.add(this._chart, n), !0) : void 0
    }
  }

  function Wn(e, t) {
    const n = e && e.options || {},
      r = n.reverse,
      i = void 0 === n.min ? t : 0,
      s = void 0 === n.max ? t : 0;
    return {
      start: r ? s : i,
      end: r ? i : s
    }
  }

  function Hn(e, t) {
    const n = [],
      r = e._getSortedDatasetMetas(t);
    let i, s;
    for (i = 0, s = r.length; i < s; ++i) n.push(r[i].index);
    return n
  }

  function Vn(e, t, n) {
    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    const i = e.keys,
      s = "single" === r.mode;
    let o, a, l, c;
    if (null === t) return;
    let u = !1;
    for (o = 0, a = i.length; o < a; ++o) {
      if (l = +i[o], l === n) {
        if (u = !0, r.all) continue;
        break
      }
      c = e.values[l], J(c) && (s || 0 === t || ke(t) === ke(c)) && (t += c)
    }
    return u || r.all ? t : 0
  }

  function qn(e, t) {
    const n = e && e.options.stacked;
    return n || void 0 === n && void 0 !== t.stack
  }

  function Kn(e, t, n) {
    const r = e[t] || (e[t] = {});
    return r[n] || (r[n] = {})
  }

  function $n(e, t, n, r) {
    for (const i of t.getMatchingVisibleMetas(r).reverse()) {
      const t = e[i.index];
      if (n && t > 0 || !n && t < 0) return i.index
    }
    return null
  }

  function Yn(e, t) {
    const {
      chart: n,
      _cachedMeta: r
    } = e, i = n._stacks || (n._stacks = {}), {
      iScale: s,
      vScale: o,
      index: a
    } = r, l = s.axis, c = o.axis, u = function(e, t, n) {
      return "".concat(e.id, ".").concat(t.id, ".").concat(n.stack || n.type)
    }(s, o, r), h = t.length;
    let d;
    for (let f = 0; f < h; ++f) {
      const e = t[f],
        {
          [l]: n,
          [c]: s
        } = e;
      d = (e._stacks || (e._stacks = {}))[c] = Kn(i, u, n), d[a] = s, d._top = $n(d, o, !0, r.type), d._bottom = $n(d, o, !1, r.type);
      (d._visualValues || (d._visualValues = {}))[a] = s
    }
  }

  function Jn(e, t) {
    const n = e.scales;
    return Object.keys(n).filter(e => n[e].axis === t).shift()
  }

  function Gn(e, t) {
    const n = e.controller.index,
      r = e.vScale && e.vScale.axis;
    if (r) {
      t = t || e._parsed;
      for (const e of t) {
        const t = e._stacks;
        if (!t || void 0 === t[r] || void 0 === t[r][n]) return;
        delete t[r][n], void 0 !== t[r]._visualValues && void 0 !== t[r]._visualValues[n] && delete t[r]._visualValues[n]
      }
    }
  }
  const Qn = e => "reset" === e || "none" === e,
    Xn = (e, t) => t ? e : Object.assign({}, e);
  class Zn {
    constructor(e, t) {
      this.chart = e, this._ctx = e.ctx, this.index = t, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize()
    }
    initialize() {
      const e = this._cachedMeta;
      this.configure(), this.linkScales(), e._stacked = qn(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
    }
    updateIndex(e) {
      this.index !== e && Gn(this._cachedMeta), this.index = e
    }
    linkScales() {
      const e = this.chart,
        t = this._cachedMeta,
        n = this.getDataset(),
        r = (e, t, n, r) => "x" === e ? t : "r" === e ? r : n,
        i = t.xAxisID = Q(n.xAxisID, Jn(e, "x")),
        s = t.yAxisID = Q(n.yAxisID, Jn(e, "y")),
        o = t.rAxisID = Q(n.rAxisID, Jn(e, "r")),
        a = t.indexAxis,
        l = t.iAxisID = r(a, i, s, o),
        c = t.vAxisID = r(a, s, i, o);
      t.xScale = this.getScaleForId(i), t.yScale = this.getScaleForId(s), t.rScale = this.getScaleForId(o), t.iScale = this.getScaleForId(l), t.vScale = this.getScaleForId(c)
    }
    getDataset() {
      return this.chart.data.datasets[this.index]
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(e) {
      return this.chart.scales[e]
    }
    _getOtherScale(e) {
      const t = this._cachedMeta;
      return e === t.iScale ? t.vScale : t.iScale
    }
    reset() {
      this._update("reset")
    }
    _destroy() {
      const e = this._cachedMeta;
      this._data && We(this._data, this), e._stacked && Gn(e)
    }
    _dataCheck() {
      const e = this.getDataset(),
        t = e.data || (e.data = []),
        n = this._data;
      if (Y(t)) {
        const e = this._cachedMeta;
        this._data = function(e, t) {
          const {
            iScale: n,
            vScale: r
          } = t, i = "x" === n.axis ? "x" : "y", s = "x" === r.axis ? "x" : "y", o = Object.keys(e), a = new Array(o.length);
          let l, c, u;
          for (l = 0, c = o.length; l < c; ++l) u = o[l], a[l] = {
            [i]: u,
            [s]: e[u]
          };
          return a
        }(t, e)
      } else if (n !== t) {
        if (n) {
          We(n, this);
          const e = this._cachedMeta;
          Gn(e), e._parsed = []
        }
        t && Object.isExtensible(t) && (i = this, (r = t)._chartjs ? r._chartjs.listeners.push(i) : (Object.defineProperty(r, "_chartjs", {
          configurable: !0,
          enumerable: !1,
          value: {
            listeners: [i]
          }
        }), Ue.forEach(e => {
          const t = "_onData" + ue(e),
            n = r[e];
          Object.defineProperty(r, e, {
            configurable: !0,
            enumerable: !1,
            value() {
              for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++) i[s] = arguments[s];
              const o = n.apply(this, i);
              return r._chartjs.listeners.forEach(e => {
                "function" === typeof e[t] && e[t](...i)
              }), o
            }
          })
        }))), this._syncList = [], this._data = t
      }
      var r, i
    }
    addElements() {
      const e = this._cachedMeta;
      this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(e) {
      const t = this._cachedMeta,
        n = this.getDataset();
      let r = !1;
      this._dataCheck();
      const i = t._stacked;
      t._stacked = qn(t.vScale, t), t.stack !== n.stack && (r = !0, Gn(t), t.stack = n.stack), this._resyncElements(e), (r || i !== t._stacked) && (Yn(this, t._parsed), t._stacked = qn(t.vScale, t))
    }
    configure() {
      const e = this.chart.config,
        t = e.datasetScopeKeys(this._type),
        n = e.getOptionScopes(this.getDataset(), t, !0);
      this.options = e.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
    }
    parse(e, t) {
      const {
        _cachedMeta: n,
        _data: r
      } = this, {
        iScale: i,
        _stacked: s
      } = n, o = i.axis;
      let a, l, c, u = 0 === e && t === r.length || n._sorted,
        h = e > 0 && n._parsed[e - 1];
      if (!1 === this._parsing) n._parsed = r, n._sorted = !0, c = r;
      else {
        c = $(r[e]) ? this.parseArrayData(n, r, e, t) : Y(r[e]) ? this.parseObjectData(n, r, e, t) : this.parsePrimitiveData(n, r, e, t);
        const i = () => null === l[o] || h && l[o] < h[o];
        for (a = 0; a < t; ++a) n._parsed[a + e] = l = c[a], u && (i() && (u = !1), h = l);
        n._sorted = u
      }
      s && Yn(this, c)
    }
    parsePrimitiveData(e, t, n, r) {
      const {
        iScale: i,
        vScale: s
      } = e, o = i.axis, a = s.axis, l = i.getLabels(), c = i === s, u = new Array(r);
      let h, d, f;
      for (h = 0, d = r; h < d; ++h) f = h + n, u[h] = {
        [o]: c || i.parse(l[f], f),
        [a]: s.parse(t[f], f)
      };
      return u
    }
    parseArrayData(e, t, n, r) {
      const {
        xScale: i,
        yScale: s
      } = e, o = new Array(r);
      let a, l, c, u;
      for (a = 0, l = r; a < l; ++a) c = a + n, u = t[c], o[a] = {
        x: i.parse(u[0], c),
        y: s.parse(u[1], c)
      };
      return o
    }
    parseObjectData(e, t, n, r) {
      const {
        xScale: i,
        yScale: s
      } = e, {
        xAxisKey: o = "x",
        yAxisKey: a = "y"
      } = this._parsing, l = new Array(r);
      let c, u, h, d;
      for (c = 0, u = r; c < u; ++c) h = c + n, d = t[h], l[c] = {
        x: i.parse(ce(d, o), h),
        y: s.parse(ce(d, a), h)
      };
      return l
    }
    getParsed(e) {
      return this._cachedMeta._parsed[e]
    }
    getDataElement(e) {
      return this._cachedMeta.data[e]
    }
    applyStack(e, t, n) {
      const r = this.chart,
        i = this._cachedMeta,
        s = t[e.axis];
      return Vn({
        keys: Hn(r, !0),
        values: t._stacks[e.axis]._visualValues
      }, s, i.index, {
        mode: n
      })
    }
    updateRangeFromParsed(e, t, n, r) {
      const i = n[t.axis];
      let s = null === i ? NaN : i;
      const o = r && n._stacks[t.axis];
      r && o && (r.values = o, s = Vn(r, i, this._cachedMeta.index)), e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)
    }
    getMinMax(e, t) {
      const n = this._cachedMeta,
        r = n._parsed,
        i = n._sorted && e === n.iScale,
        s = r.length,
        o = this._getOtherScale(e),
        a = ((e, t, n) => e && !t.hidden && t._stacked && {
          keys: Hn(n, !0),
          values: null
        })(t, n, this.chart),
        l = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        },
        {
          min: c,
          max: u
        } = function(e) {
          const {
            min: t,
            max: n,
            minDefined: r,
            maxDefined: i
          } = e.getUserBounds();
          return {
            min: r ? t : Number.NEGATIVE_INFINITY,
            max: i ? n : Number.POSITIVE_INFINITY
          }
        }(o);
      let h, d;

      function f() {
        d = r[h];
        const t = d[o.axis];
        return !J(d[e.axis]) || c > t || u < t
      }
      for (h = 0; h < s && (f() || (this.updateRangeFromParsed(l, e, d, a), !i)); ++h);
      if (i)
        for (h = s - 1; h >= 0; --h)
          if (!f()) {
            this.updateRangeFromParsed(l, e, d, a);
            break
          } return l
    }
    getAllParsedValues(e) {
      const t = this._cachedMeta._parsed,
        n = [];
      let r, i, s;
      for (r = 0, i = t.length; r < i; ++r) s = t[r][e.axis], J(s) && n.push(s);
      return n
    }
    getMaxOverflow() {
      return !1
    }
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        n = t.iScale,
        r = t.vScale,
        i = this.getParsed(e);
      return {
        label: n ? "" + n.getLabelForValue(i[n.axis]) : "",
        value: r ? "" + r.getLabelForValue(i[r.axis]) : ""
      }
    }
    _update(e) {
      const t = this._cachedMeta;
      this.update(e || "default"), t._clip = function(e) {
        let t, n, r, i;
        return Y(e) ? (t = e.top, n = e.right, r = e.bottom, i = e.left) : t = n = r = i = e, {
          top: t,
          right: n,
          bottom: r,
          left: i,
          disabled: !1 === e
        }
      }(Q(this.options.clip, function(e, t, n) {
        if (!1 === n) return !1;
        const r = Wn(e, n),
          i = Wn(t, n);
        return {
          top: i.end,
          right: r.end,
          bottom: i.start,
          left: r.start
        }
      }(t.xScale, t.yScale, this.getMaxOverflow())))
    }
    update(e) {}
    draw() {
      const e = this._ctx,
        t = this.chart,
        n = this._cachedMeta,
        r = n.data || [],
        i = t.chartArea,
        s = [],
        o = this._drawStart || 0,
        a = this._drawCount || r.length - o,
        l = this.options.drawActiveElementsOnTop;
      let c;
      for (n.dataset && n.dataset.draw(e, i, o, a), c = o; c < o + a; ++c) {
        const t = r[c];
        t.hidden || (t.active && l ? s.push(t) : t.draw(e, i))
      }
      for (c = 0; c < s.length; ++c) s[c].draw(e, i)
    }
    getStyle(e, t) {
      const n = t ? "active" : "default";
      return void 0 === e && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(e || 0, n)
    }
    getContext(e, t, n) {
      const r = this.getDataset();
      let i;
      if (e >= 0 && e < this._cachedMeta.data.length) {
        const t = this._cachedMeta.data[e];
        i = t.$context || (t.$context = function(e, t, n) {
          return Bt(e, {
            active: !1,
            dataIndex: t,
            parsed: void 0,
            raw: void 0,
            element: n,
            index: t,
            mode: "default",
            type: "data"
          })
        }(this.getContext(), e, t)), i.parsed = this.getParsed(e), i.raw = r.data[e], i.index = i.dataIndex = e
      } else i = this.$context || (this.$context = function(e, t) {
        return Bt(e, {
          active: !1,
          dataset: void 0,
          datasetIndex: t,
          index: t,
          mode: "default",
          type: "dataset"
        })
      }(this.chart.getContext(), this.index)), i.dataset = r, i.index = i.datasetIndex = this.index;
      return i.active = !!t, i.mode = n, i
    }
    resolveDatasetElementOptions(e) {
      return this._resolveElementOptions(this.datasetElementType.id, e)
    }
    resolveDataElementOptions(e, t) {
      return this._resolveElementOptions(this.dataElementType.id, t, e)
    }
    _resolveElementOptions(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default",
        n = arguments.length > 2 ? arguments[2] : void 0;
      const r = "active" === t,
        i = this._cachedDataOpts,
        s = e + "-" + t,
        o = i[s],
        a = this.enableOptionSharing && he(n);
      if (o) return Xn(o, a);
      const l = this.chart.config,
        c = l.datasetElementScopeKeys(this._type, e),
        u = r ? ["".concat(e, "Hover"), "hover", e, ""] : [e, ""],
        h = l.getOptionScopes(this.getDataset(), c),
        d = Object.keys(pt.elements[e]),
        f = l.resolveNamedOptions(h, d, () => this.getContext(n, r, t), u);
      return f.$shared && (f.$shared = a, i[s] = Object.freeze(Xn(f, a))), f
    }
    _resolveAnimations(e, t, n) {
      const r = this.chart,
        i = this._cachedDataOpts,
        s = "animation-".concat(t),
        o = i[s];
      if (o) return o;
      let a;
      if (!1 !== r.options.animation) {
        const r = this.chart.config,
          i = r.datasetAnimationScopeKeys(this._type, t),
          s = r.getOptionScopes(this.getDataset(), i);
        a = r.createResolver(s, this.getContext(e, n, t))
      }
      const l = new Un(r, a && a.animations);
      return a && a._cacheable && (i[s] = Object.freeze(l)), l
    }
    getSharedOptions(e) {
      if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e))
    }
    includeOptions(e, t) {
      return !t || Qn(e) || this.chart._animationsDisabled
    }
    _getSharedOptions(e, t) {
      const n = this.resolveDataElementOptions(e, t),
        r = this._sharedOptions,
        i = this.getSharedOptions(n),
        s = this.includeOptions(t, i) || i !== r;
      return this.updateSharedOptions(i, t, n), {
        sharedOptions: i,
        includeOptions: s
      }
    }
    updateElement(e, t, n, r) {
      Qn(r) ? Object.assign(e, n) : this._resolveAnimations(t, r).update(e, n)
    }
    updateSharedOptions(e, t, n) {
      e && !Qn(t) && this._resolveAnimations(void 0, t).update(e, n)
    }
    _setStyle(e, t, n, r) {
      e.active = r;
      const i = this.getStyle(t, r);
      this._resolveAnimations(t, n, r).update(e, {
        options: !r && this.getSharedOptions(i) || i
      })
    }
    removeHoverStyle(e, t, n) {
      this._setStyle(e, n, "active", !1)
    }
    setHoverStyle(e, t, n) {
      this._setStyle(e, n, "active", !0)
    }
    _removeDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", !0)
    }
    _resyncElements(e) {
      const t = this._data,
        n = this._cachedMeta.data;
      for (const [o, a, l] of this._syncList) this[o](a, l);
      this._syncList = [];
      const r = n.length,
        i = t.length,
        s = Math.min(i, r);
      s && this.parse(0, s), i > r ? this._insertElements(r, i - r, e) : i < r && this._removeElements(i, r - i)
    }
    _insertElements(e, t) {
      let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      const r = this._cachedMeta,
        i = r.data,
        s = e + t;
      let o;
      const a = e => {
        for (e.length += t, o = e.length - 1; o >= s; o--) e[o] = e[o - t]
      };
      for (a(i), o = e; o < s; ++o) i[o] = new this.dataElementType;
      this._parsing && a(r._parsed), this.parse(e, t), n && this.updateElements(i, e, t, "reset")
    }
    updateElements(e, t, n, r) {}
    _removeElements(e, t) {
      const n = this._cachedMeta;
      if (this._parsing) {
        const r = n._parsed.splice(e, t);
        n._stacked && Gn(n, r)
      }
      n.data.splice(e, t)
    }
    _sync(e) {
      if (this._parsing) this._syncList.push(e);
      else {
        const [t, n, r] = e;
        this[t](n, r)
      }
      this.chart._dataChanges.push([this.index, ...e])
    }
    _onDataPush() {
      const e = arguments.length;
      this._sync(["_insertElements", this.getDataset().data.length - e, e])
    }
    _onDataPop() {
      this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
    }
    _onDataShift() {
      this._sync(["_removeElements", 0, 1])
    }
    _onDataSplice(e, t) {
      t && this._sync(["_removeElements", e, t]);
      const n = arguments.length - 2;
      n && this._sync(["_insertElements", e, n])
    }
    _onDataUnshift() {
      this._sync(["_insertElements", 0, arguments.length])
    }
  }

  function er(e) {
    const t = e.iScale,
      n = function(e, t) {
        if (!e._cache.$bar) {
          const n = e.getMatchingVisibleMetas(t);
          let r = [];
          for (let t = 0, i = n.length; t < i; t++) r = r.concat(n[t].controller.getAllParsedValues(e));
          e._cache.$bar = He(r.sort((e, t) => e - t))
        }
        return e._cache.$bar
      }(t, e.type);
    let r, i, s, o, a = t._length;
    const l = () => {
      32767 !== s && -32768 !== s && (he(o) && (a = Math.min(a, Math.abs(s - o) || a)), o = s)
    };
    for (r = 0, i = n.length; r < i; ++r) s = t.getPixelForValue(n[r]), l();
    for (o = void 0, r = 0, i = t.ticks.length; r < i; ++r) s = t.getPixelForTick(r), l();
    return a
  }

  function tr(e, t, n, r) {
    return $(e) ? function(e, t, n, r) {
      const i = n.parse(e[0], r),
        s = n.parse(e[1], r),
        o = Math.min(i, s),
        a = Math.max(i, s);
      let l = o,
        c = a;
      Math.abs(o) > Math.abs(a) && (l = a, c = o), t[n.axis] = c, t._custom = {
        barStart: l,
        barEnd: c,
        start: i,
        end: s,
        min: o,
        max: a
      }
    }(e, t, n, r) : t[n.axis] = n.parse(e, r), t
  }

  function nr(e, t, n, r) {
    const i = e.iScale,
      s = e.vScale,
      o = i.getLabels(),
      a = i === s,
      l = [];
    let c, u, h, d;
    for (c = n, u = n + r; c < u; ++c) d = t[c], h = {}, h[i.axis] = a || i.parse(o[c], c), l.push(tr(d, h, s, c));
    return l
  }

  function rr(e) {
    return e && void 0 !== e.barStart && void 0 !== e.barEnd
  }

  function ir(e, t, n, r) {
    let i = t.borderSkipped;
    const s = {};
    if (!i) return void(e.borderSkipped = s);
    if (!0 === i) return void(e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    });
    const {
      start: o,
      end: a,
      reverse: l,
      top: c,
      bottom: u
    } = function(e) {
      let t, n, r, i, s;
      return e.horizontal ? (t = e.base > e.x, n = "left", r = "right") : (t = e.base < e.y, n = "bottom", r = "top"), t ? (i = "end", s = "start") : (i = "start", s = "end"), {
        start: n,
        end: r,
        reverse: t,
        top: i,
        bottom: s
      }
    }(e);
    "middle" === i && n && (e.enableBorderRadius = !0, (n._top || 0) === r ? i = c : (n._bottom || 0) === r ? i = u : (s[sr(u, o, a, l)] = !0, i = c)), s[sr(i, o, a, l)] = !0, e.borderSkipped = s
  }

  function sr(e, t, n, r) {
    var i, s, o;
    return r ? (o = n, e = or(e = (i = e) === (s = t) ? o : i === o ? s : i, n, t)) : e = or(e, t, n), e
  }

  function or(e, t, n) {
    return "start" === e ? t : "end" === e ? n : e
  }

  function ar(e, t, n) {
    let {
      inflateAmount: r
    } = t;
    e.inflateAmount = "auto" === r ? 1 === n ? .33 : 0 : r
  }
  l(Zn, "defaults", {}), l(Zn, "datasetElementType", null), l(Zn, "dataElementType", null);
  class lr extends Zn {
    parsePrimitiveData(e, t, n, r) {
      return nr(e, t, n, r)
    }
    parseArrayData(e, t, n, r) {
      return nr(e, t, n, r)
    }
    parseObjectData(e, t, n, r) {
      const {
        iScale: i,
        vScale: s
      } = e, {
        xAxisKey: o = "x",
        yAxisKey: a = "y"
      } = this._parsing, l = "x" === i.axis ? o : a, c = "x" === s.axis ? o : a, u = [];
      let h, d, f, p;
      for (h = n, d = n + r; h < d; ++h) p = t[h], f = {}, f[i.axis] = i.parse(ce(p, l), h), u.push(tr(ce(p, c), f, s, h));
      return u
    }
    updateRangeFromParsed(e, t, n, r) {
      super.updateRangeFromParsed(e, t, n, r);
      const i = n._custom;
      i && t === this._cachedMeta.vScale && (e.min = Math.min(e.min, i.min), e.max = Math.max(e.max, i.max))
    }
    getMaxOverflow() {
      return 0
    }
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        {
          iScale: n,
          vScale: r
        } = t,
        i = this.getParsed(e),
        s = i._custom,
        o = rr(s) ? "[" + s.start + ", " + s.end + "]" : "" + r.getLabelForValue(i[r.axis]);
      return {
        label: "" + n.getLabelForValue(i[n.axis]),
        value: o
      }
    }
    initialize() {
      this.enableOptionSharing = !0, super.initialize();
      this._cachedMeta.stack = this.getDataset().stack
    }
    update(e) {
      const t = this._cachedMeta;
      this.updateElements(t.data, 0, t.data.length, e)
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        {
          index: s,
          _cachedMeta: {
            vScale: o
          }
        } = this,
        a = o.getBasePixel(),
        l = o.isHorizontal(),
        c = this._getRuler(),
        {
          sharedOptions: u,
          includeOptions: h
        } = this._getSharedOptions(t, r);
      for (let d = t; d < t + n; d++) {
        const t = this.getParsed(d),
          n = i || K(t[o.axis]) ? {
            base: a,
            head: a
          } : this._calculateBarValuePixels(d),
          f = this._calculateBarIndexPixels(d, c),
          p = (t._stacks || {})[o.axis],
          g = {
            horizontal: l,
            base: n.base,
            enableBorderRadius: !p || rr(t._custom) || s === p._top || s === p._bottom,
            x: l ? n.head : f.center,
            y: l ? f.center : n.head,
            height: l ? f.size : Math.abs(n.size),
            width: l ? Math.abs(n.size) : f.size
          };
        h && (g.options = u || this.resolveDataElementOptions(d, e[d].active ? "active" : r));
        const m = g.options || e[d].options;
        ir(g, m, p, s), ar(g, m, c.ratio), this.updateElement(e[d], d, g, r)
      }
    }
    _getStacks(e, t) {
      const {
        iScale: n
      } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter(e => e.controller.options.grouped), i = n.options.stacked, s = [], o = this._cachedMeta.controller.getParsed(t), a = o && o[n.axis], l = e => {
        const t = e._parsed.find(e => e[n.axis] === a),
          r = t && t[e.vScale.axis];
        if (K(r) || isNaN(r)) return !0
      };
      for (const c of r)
        if ((void 0 === t || !l(c)) && ((!1 === i || -1 === s.indexOf(c.stack) || void 0 === i && void 0 === c.stack) && s.push(c.stack), c.index === e)) break;
      return s.length || s.push(void 0), s
    }
    _getStackCount(e) {
      return this._getStacks(void 0, e).length
    }
    _getAxisCount() {
      return this._getAxis().length
    }
    getFirstScaleIdForIndexAxis() {
      const e = this.chart.scales,
        t = this.chart.options.indexAxis;
      return Object.keys(e).filter(n => e[n].axis === t).shift()
    }
    _getAxis() {
      const e = {},
        t = this.getFirstScaleIdForIndexAxis();
      for (const n of this.chart.data.datasets) e[Q("x" === this.chart.options.indexAxis ? n.xAxisID : n.yAxisID, t)] = !0;
      return Object.keys(e)
    }
    _getStackIndex(e, t, n) {
      const r = this._getStacks(e, n),
        i = void 0 !== t ? r.indexOf(t) : -1;
      return -1 === i ? r.length - 1 : i
    }
    _getRuler() {
      const e = this.options,
        t = this._cachedMeta,
        n = t.iScale,
        r = [];
      let i, s;
      for (i = 0, s = t.data.length; i < s; ++i) r.push(n.getPixelForValue(this.getParsed(i)[n.axis], i));
      const o = e.barThickness;
      return {
        min: o || er(t),
        pixels: r,
        start: n._startPixel,
        end: n._endPixel,
        stackCount: this._getStackCount(),
        scale: n,
        grouped: e.grouped,
        ratio: o ? 1 : e.categoryPercentage * e.barPercentage
      }
    }
    _calculateBarValuePixels(e) {
      const {
        _cachedMeta: {
          vScale: t,
          _stacked: n,
          index: r
        },
        options: {
          base: i,
          minBarLength: s
        }
      } = this, o = i || 0, a = this.getParsed(e), l = a._custom, c = rr(l);
      let u, h, d = a[t.axis],
        f = 0,
        p = n ? this.applyStack(t, a, n) : d;
      p !== d && (f = p - d, p = d), c && (d = l.barStart, p = l.barEnd - l.barStart, 0 !== d && ke(d) !== ke(l.barEnd) && (f = 0), f += d);
      const g = K(i) || c ? f : i;
      let m = t.getPixelForValue(g);
      if (u = this.chart.getDataVisibility(e) ? t.getPixelForValue(f + p) : m, h = u - m, Math.abs(h) < s) {
        h = function(e, t, n) {
          return 0 !== e ? ke(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1)
        }(h, t, o) * s, d === o && (m -= h / 2);
        const e = t.getPixelForDecimal(0),
          i = t.getPixelForDecimal(1),
          l = Math.min(e, i),
          f = Math.max(e, i);
        m = Math.max(Math.min(m, f), l), u = m + h, n && !c && (a._stacks[t.axis]._visualValues[r] = t.getValueForPixel(u) - t.getValueForPixel(m))
      }
      if (m === t.getPixelForValue(o)) {
        const e = ke(h) * t.getLineWidthForValue(o) / 2;
        m += e, h -= e
      }
      return {
        size: h,
        base: m,
        head: u,
        center: u + h / 2
      }
    }
    _calculateBarIndexPixels(e, t) {
      const n = t.scale,
        r = this.options,
        i = r.skipNull,
        s = Q(r.maxBarThickness, 1 / 0);
      let o, a;
      const l = this._getAxisCount();
      if (t.grouped) {
        const n = i ? this._getStackCount(e) : t.stackCount,
          c = "flex" === r.barThickness ? function(e, t, n, r) {
            const i = t.pixels,
              s = i[e];
            let o = e > 0 ? i[e - 1] : null,
              a = e < i.length - 1 ? i[e + 1] : null;
            const l = n.categoryPercentage;
            null === o && (o = s - (null === a ? t.end - t.start : a - s)), null === a && (a = s + s - o);
            const c = s - (s - Math.min(o, a)) / 2 * l;
            return {
              chunk: Math.abs(a - o) / 2 * l / r,
              ratio: n.barPercentage,
              start: c
            }
          }(e, t, r, n * l) : function(e, t, n, r) {
            const i = n.barThickness;
            let s, o;
            return K(i) ? (s = t.min * n.categoryPercentage, o = n.barPercentage) : (s = i * r, o = 1), {
              chunk: s / r,
              ratio: o,
              start: t.pixels[e] - s / 2
            }
          }(e, t, r, n * l),
          u = "x" === this.chart.options.indexAxis ? this.getDataset().xAxisID : this.getDataset().yAxisID,
          h = this._getAxis().indexOf(Q(u, this.getFirstScaleIdForIndexAxis())),
          d = this._getStackIndex(this.index, this._cachedMeta.stack, i ? e : void 0) + h;
        o = c.start + c.chunk * d + c.chunk / 2, a = Math.min(s, c.chunk * c.ratio)
      } else o = n.getPixelForValue(this.getParsed(e)[n.axis], e), a = Math.min(s, t.min * t.ratio);
      return {
        base: o - a / 2,
        head: o + a / 2,
        center: o,
        size: a
      }
    }
    draw() {
      const e = this._cachedMeta,
        t = e.vScale,
        n = e.data,
        r = n.length;
      let i = 0;
      for (; i < r; ++i) null === this.getParsed(i)[t.axis] || n[i].hidden || n[i].draw(this._ctx)
    }
  }
  l(lr, "id", "bar"), l(lr, "defaults", {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: .8,
    barPercentage: .9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  }), l(lr, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  });
  class cr extends Zn {
    initialize() {
      this.enableOptionSharing = !0, super.initialize()
    }
    parsePrimitiveData(e, t, n, r) {
      const i = super.parsePrimitiveData(e, t, n, r);
      for (let s = 0; s < i.length; s++) i[s]._custom = this.resolveDataElementOptions(s + n).radius;
      return i
    }
    parseArrayData(e, t, n, r) {
      const i = super.parseArrayData(e, t, n, r);
      for (let s = 0; s < i.length; s++) {
        const e = t[n + s];
        i[s]._custom = Q(e[2], this.resolveDataElementOptions(s + n).radius)
      }
      return i
    }
    parseObjectData(e, t, n, r) {
      const i = super.parseObjectData(e, t, n, r);
      for (let s = 0; s < i.length; s++) {
        const e = t[n + s];
        i[s]._custom = Q(e && e.r && +e.r, this.resolveDataElementOptions(s + n).radius)
      }
      return i
    }
    getMaxOverflow() {
      const e = this._cachedMeta.data;
      let t = 0;
      for (let n = e.length - 1; n >= 0; --n) t = Math.max(t, e[n].size(this.resolveDataElementOptions(n)) / 2);
      return t > 0 && t
    }
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        n = this.chart.data.labels || [],
        {
          xScale: r,
          yScale: i
        } = t,
        s = this.getParsed(e),
        o = r.getLabelForValue(s.x),
        a = i.getLabelForValue(s.y),
        l = s._custom;
      return {
        label: n[e] || "",
        value: "(" + o + ", " + a + (l ? ", " + l : "") + ")"
      }
    }
    update(e) {
      const t = this._cachedMeta.data;
      this.updateElements(t, 0, t.length, e)
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        {
          iScale: s,
          vScale: o
        } = this._cachedMeta,
        {
          sharedOptions: a,
          includeOptions: l
        } = this._getSharedOptions(t, r),
        c = s.axis,
        u = o.axis;
      for (let h = t; h < t + n; h++) {
        const t = e[h],
          n = !i && this.getParsed(h),
          d = {},
          f = d[c] = i ? s.getPixelForDecimal(.5) : s.getPixelForValue(n[c]),
          p = d[u] = i ? o.getBasePixel() : o.getPixelForValue(n[u]);
        d.skip = isNaN(f) || isNaN(p), l && (d.options = a || this.resolveDataElementOptions(h, t.active ? "active" : r), i && (d.options.radius = 0)), this.updateElement(t, h, d, r)
      }
    }
    resolveDataElementOptions(e, t) {
      const n = this.getParsed(e);
      let r = super.resolveDataElementOptions(e, t);
      r.$shared && (r = Object.assign({}, r, {
        $shared: !1
      }));
      const i = r.radius;
      return "active" !== t && (r.radius = 0), r.radius += Q(n && n._custom, i), r
    }
  }
  l(cr, "id", "bubble"), l(cr, "defaults", {
    datasetElementType: !1,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  }), l(cr, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  class ur extends Zn {
    constructor(e, t) {
      super(e, t), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
    }
    linkScales() {}
    parse(e, t) {
      const n = this.getDataset().data,
        r = this._cachedMeta;
      if (!1 === this._parsing) r._parsed = n;
      else {
        let i, s, o = e => +n[e];
        if (Y(n[e])) {
          const {
            key: e = "value"
          } = this._parsing;
          o = t => +ce(n[t], e)
        }
        for (i = e, s = e + t; i < s; ++i) r._parsed[i] = o(i)
      }
    }
    _getRotation() {
      return Oe(this.options.rotation - 90)
    }
    _getCircumference() {
      return Oe(this.options.circumference)
    }
    _getRotationExtents() {
      let e = ge,
        t = -ge;
      for (let n = 0; n < this.chart.data.datasets.length; ++n)
        if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
          const r = this.chart.getDatasetMeta(n).controller,
            i = r._getRotation(),
            s = r._getCircumference();
          e = Math.min(e, i), t = Math.max(t, i + s)
        } return {
        rotation: e,
        circumference: t - e
      }
    }
    update(e) {
      const t = this.chart,
        {
          chartArea: n
        } = t,
        r = this._cachedMeta,
        i = r.data,
        s = this.getMaxBorderWidth() + this.getMaxOffset(i) + this.options.spacing,
        o = Math.max((Math.min(n.width, n.height) - s) / 2, 0),
        a = Math.min(((e, t) => "string" === typeof e && e.endsWith("%") ? parseFloat(e) / 100 : +e / t)(this.options.cutout, o), 1),
        l = this._getRingWeight(this.index),
        {
          circumference: c,
          rotation: u
        } = this._getRotationExtents(),
        {
          ratioX: h,
          ratioY: d,
          offsetX: f,
          offsetY: p
        } = function(e, t, n) {
          let r = 1,
            i = 1,
            s = 0,
            o = 0;
          if (t < ge) {
            const a = e,
              l = a + t,
              c = Math.cos(a),
              u = Math.sin(a),
              h = Math.cos(l),
              d = Math.sin(l),
              f = (e, t, r) => Ne(e, a, l, !0) ? 1 : Math.max(t, t * n, r, r * n),
              p = (e, t, r) => Ne(e, a, l, !0) ? -1 : Math.min(t, t * n, r, r * n),
              g = f(0, c, h),
              m = f(be, u, d),
              y = p(pe, c, h),
              v = p(pe + be, u, d);
            r = (g - y) / 2, i = (m - v) / 2, s = -(g + y) / 2, o = -(m + v) / 2
          }
          return {
            ratioX: r,
            ratioY: i,
            offsetX: s,
            offsetY: o
          }
        }(u, c, a),
        g = (n.width - s) / h,
        m = (n.height - s) / d,
        y = Math.max(Math.min(g, m) / 2, 0),
        v = X(this.options.radius, y),
        b = (v - Math.max(v * a, 0)) / this._getVisibleDatasetWeightTotal();
      this.offsetX = f * v, this.offsetY = p * v, r.total = this.calculateTotal(), this.outerRadius = v - b * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - b * l, 0), this.updateElements(i, 0, i.length, e)
    }
    _circumference(e, t) {
      const n = this.options,
        r = this._cachedMeta,
        i = this._getCircumference();
      return t && n.animation.animateRotate || !this.chart.getDataVisibility(e) || null === r._parsed[e] || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * i / ge)
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        s = this.chart,
        o = s.chartArea,
        a = s.options.animation,
        l = (o.left + o.right) / 2,
        c = (o.top + o.bottom) / 2,
        u = i && a.animateScale,
        h = u ? 0 : this.innerRadius,
        d = u ? 0 : this.outerRadius,
        {
          sharedOptions: f,
          includeOptions: p
        } = this._getSharedOptions(t, r);
      let g, m = this._getRotation();
      for (g = 0; g < t; ++g) m += this._circumference(g, i);
      for (g = t; g < t + n; ++g) {
        const t = this._circumference(g, i),
          n = e[g],
          s = {
            x: l + this.offsetX,
            y: c + this.offsetY,
            startAngle: m,
            endAngle: m + t,
            circumference: t,
            outerRadius: d,
            innerRadius: h
          };
        p && (s.options = f || this.resolveDataElementOptions(g, n.active ? "active" : r)), m += t, this.updateElement(n, g, s, r)
      }
    }
    calculateTotal() {
      const e = this._cachedMeta,
        t = e.data;
      let n, r = 0;
      for (n = 0; n < t.length; n++) {
        const i = e._parsed[n];
        null === i || isNaN(i) || !this.chart.getDataVisibility(n) || t[n].hidden || (r += Math.abs(i))
      }
      return r
    }
    calculateCircumference(e) {
      const t = this._cachedMeta.total;
      return t > 0 && !isNaN(e) ? ge * (Math.abs(e) / t) : 0
    }
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        n = this.chart,
        r = n.data.labels || [],
        i = ot(t._parsed[e], n.options.locale);
      return {
        label: r[e] || "",
        value: i
      }
    }
    getMaxBorderWidth(e) {
      let t = 0;
      const n = this.chart;
      let r, i, s, o, a;
      if (!e)
        for (r = 0, i = n.data.datasets.length; r < i; ++r)
          if (n.isDatasetVisible(r)) {
            s = n.getDatasetMeta(r), e = s.data, o = s.controller;
            break
          } if (!e) return 0;
      for (r = 0, i = e.length; r < i; ++r) a = o.resolveDataElementOptions(r), "inner" !== a.borderAlign && (t = Math.max(t, a.borderWidth || 0, a.hoverBorderWidth || 0));
      return t
    }
    getMaxOffset(e) {
      let t = 0;
      for (let n = 0, r = e.length; n < r; ++n) {
        const e = this.resolveDataElementOptions(n);
        t = Math.max(t, e.offset || 0, e.hoverOffset || 0)
      }
      return t
    }
    _getRingWeightOffset(e) {
      let t = 0;
      for (let n = 0; n < e; ++n) this.chart.isDatasetVisible(n) && (t += this._getRingWeight(n));
      return t
    }
    _getRingWeight(e) {
      return Math.max(Q(this.chart.data.datasets[e].weight, 1), 0)
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
    }
  }
  l(ur, "id", "doughnut"), l(ur, "defaults", {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  }), l(ur, "descriptors", {
    _scriptable: e => "spacing" !== e,
    _indexable: e => "spacing" !== e && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
  }), l(ur, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const t = e.data,
              {
                labels: {
                  pointStyle: n,
                  textAlign: r,
                  color: i,
                  useBorderRadius: s,
                  borderRadius: o
                }
              } = e.legend.options;
            return t.labels.length && t.datasets.length ? t.labels.map((t, a) => {
              const l = e.getDatasetMeta(0).controller.getStyle(a);
              return {
                text: t,
                fillStyle: l.backgroundColor,
                fontColor: i,
                hidden: !e.getDataVisibility(a),
                lineDash: l.borderDash,
                lineDashOffset: l.borderDashOffset,
                lineJoin: l.borderJoinStyle,
                lineWidth: l.borderWidth,
                strokeStyle: l.borderColor,
                textAlign: r,
                pointStyle: n,
                borderRadius: s && (o || l.borderRadius),
                index: a
              }
            }) : []
          }
        },
        onClick(e, t, n) {
          n.chart.toggleDataVisibility(t.index), n.chart.update()
        }
      }
    }
  });
  class hr extends Zn {
    initialize() {
      this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
    }
    update(e) {
      const t = this._cachedMeta,
        {
          dataset: n,
          data: r = [],
          _dataset: i
        } = t,
        s = this.chart._animationsDisabled;
      let {
        start: o,
        count: a
      } = Ye(t, r, s);
      this._drawStart = o, this._drawCount = a, Je(t) && (o = 0, a = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!i._decimated, n.points = r;
      const l = this.resolveDatasetElementOptions(e);
      this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(n, void 0, {
        animated: !s,
        options: l
      }, e), this.updateElements(r, o, a, e)
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        {
          iScale: s,
          vScale: o,
          _stacked: a,
          _dataset: l
        } = this._cachedMeta,
        {
          sharedOptions: c,
          includeOptions: u
        } = this._getSharedOptions(t, r),
        h = s.axis,
        d = o.axis,
        {
          spanGaps: f,
          segment: p
        } = this.options,
        g = Te(f) ? f : Number.POSITIVE_INFINITY,
        m = this.chart._animationsDisabled || i || "none" === r,
        y = t + n,
        v = e.length;
      let b = t > 0 && this.getParsed(t - 1);
      for (let w = 0; w < v; ++w) {
        const n = e[w],
          f = m ? n : {};
        if (w < t || w >= y) {
          f.skip = !0;
          continue
        }
        const v = this.getParsed(w),
          _ = K(v[d]),
          x = f[h] = s.getPixelForValue(v[h], w),
          k = f[d] = i || _ ? o.getBasePixel() : o.getPixelForValue(a ? this.applyStack(o, v, a) : v[d], w);
        f.skip = isNaN(x) || isNaN(k) || _, f.stop = w > 0 && Math.abs(v[h] - b[h]) > g, p && (f.parsed = v, f.raw = l.data[w]), u && (f.options = c || this.resolveDataElementOptions(w, n.active ? "active" : r)), m || this.updateElement(n, w, f, r), b = v
      }
    }
    getMaxOverflow() {
      const e = this._cachedMeta,
        t = e.dataset,
        n = t.options && t.options.borderWidth || 0,
        r = e.data || [];
      if (!r.length) return n;
      const i = r[0].size(this.resolveDataElementOptions(0)),
        s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
      return Math.max(n, i, s) / 2
    }
    draw() {
      const e = this._cachedMeta;
      e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw()
    }
  }
  l(hr, "id", "line"), l(hr, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  }), l(hr, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  class dr extends Zn {
    constructor(e, t) {
      super(e, t), this.innerRadius = void 0, this.outerRadius = void 0
    }
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        n = this.chart,
        r = n.data.labels || [],
        i = ot(t._parsed[e].r, n.options.locale);
      return {
        label: r[e] || "",
        value: i
      }
    }
    parseObjectData(e, t, n, r) {
      return en.bind(this)(e, t, n, r)
    }
    update(e) {
      const t = this._cachedMeta.data;
      this._updateRadius(), this.updateElements(t, 0, t.length, e)
    }
    getMinMax() {
      const e = this._cachedMeta,
        t = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        };
      return e.data.forEach((e, n) => {
        const r = this.getParsed(n).r;
        !isNaN(r) && this.chart.getDataVisibility(n) && (r < t.min && (t.min = r), r > t.max && (t.max = r))
      }), t
    }
    _updateRadius() {
      const e = this.chart,
        t = e.chartArea,
        n = e.options,
        r = Math.min(t.right - t.left, t.bottom - t.top),
        i = Math.max(r / 2, 0),
        s = (i - Math.max(n.cutoutPercentage ? i / 100 * n.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount();
      this.outerRadius = i - s * this.index, this.innerRadius = this.outerRadius - s
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        s = this.chart,
        o = s.options.animation,
        a = this._cachedMeta.rScale,
        l = a.xCenter,
        c = a.yCenter,
        u = a.getIndexAngle(0) - .5 * pe;
      let h, d = u;
      const f = 360 / this.countVisibleElements();
      for (h = 0; h < t; ++h) d += this._computeAngle(h, r, f);
      for (h = t; h < t + n; h++) {
        const t = e[h];
        let n = d,
          p = d + this._computeAngle(h, r, f),
          g = s.getDataVisibility(h) ? a.getDistanceFromCenterForValue(this.getParsed(h).r) : 0;
        d = p, i && (o.animateScale && (g = 0), o.animateRotate && (n = p = u));
        const m = {
          x: l,
          y: c,
          innerRadius: 0,
          outerRadius: g,
          startAngle: n,
          endAngle: p,
          options: this.resolveDataElementOptions(h, t.active ? "active" : r)
        };
        this.updateElement(t, h, m, r)
      }
    }
    countVisibleElements() {
      const e = this._cachedMeta;
      let t = 0;
      return e.data.forEach((e, n) => {
        !isNaN(this.getParsed(n).r) && this.chart.getDataVisibility(n) && t++
      }), t
    }
    _computeAngle(e, t, n) {
      return this.chart.getDataVisibility(e) ? Oe(this.resolveDataElementOptions(e, t).angle || n) : 0
    }
  }
  l(dr, "id", "polarArea"), l(dr, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !0
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  }), l(dr, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const t = e.data;
            if (t.labels.length && t.datasets.length) {
              const {
                labels: {
                  pointStyle: n,
                  color: r
                }
              } = e.legend.options;
              return t.labels.map((t, i) => {
                const s = e.getDatasetMeta(0).controller.getStyle(i);
                return {
                  text: t,
                  fillStyle: s.backgroundColor,
                  strokeStyle: s.borderColor,
                  fontColor: r,
                  lineWidth: s.borderWidth,
                  pointStyle: n,
                  hidden: !e.getDataVisibility(i),
                  index: i
                }
              })
            }
            return []
          }
        },
        onClick(e, t, n) {
          n.chart.toggleDataVisibility(t.index), n.chart.update()
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: !1
        },
        beginAtZero: !0,
        grid: {
          circular: !0
        },
        pointLabels: {
          display: !1
        },
        startAngle: 0
      }
    }
  });
  class fr extends ur {}
  l(fr, "id", "pie"), l(fr, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  class pr extends Zn {
    getLabelAndValue(e) {
      const t = this._cachedMeta.vScale,
        n = this.getParsed(e);
      return {
        label: t.getLabels()[e],
        value: "" + t.getLabelForValue(n[t.axis])
      }
    }
    parseObjectData(e, t, n, r) {
      return en.bind(this)(e, t, n, r)
    }
    update(e) {
      const t = this._cachedMeta,
        n = t.dataset,
        r = t.data || [],
        i = t.iScale.getLabels();
      if (n.points = r, "resize" !== e) {
        const t = this.resolveDatasetElementOptions(e);
        this.options.showLine || (t.borderWidth = 0);
        const s = {
          _loop: !0,
          _fullLoop: i.length === r.length,
          options: t
        };
        this.updateElement(n, void 0, s, e)
      }
      this.updateElements(r, 0, r.length, e)
    }
    updateElements(e, t, n, r) {
      const i = this._cachedMeta.rScale,
        s = "reset" === r;
      for (let o = t; o < t + n; o++) {
        const t = e[o],
          n = this.resolveDataElementOptions(o, t.active ? "active" : r),
          a = i.getPointPositionForValue(o, this.getParsed(o).r),
          l = s ? i.xCenter : a.x,
          c = s ? i.yCenter : a.y,
          u = {
            x: l,
            y: c,
            angle: a.angle,
            skip: isNaN(l) || isNaN(c),
            options: n
          };
        this.updateElement(t, o, u, r)
      }
    }
  }
  l(pr, "id", "radar"), l(pr, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: !0,
    elements: {
      line: {
        fill: "start"
      }
    }
  }), l(pr, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  class gr extends Zn {
    getLabelAndValue(e) {
      const t = this._cachedMeta,
        n = this.chart.data.labels || [],
        {
          xScale: r,
          yScale: i
        } = t,
        s = this.getParsed(e),
        o = r.getLabelForValue(s.x),
        a = i.getLabelForValue(s.y);
      return {
        label: n[e] || "",
        value: "(" + o + ", " + a + ")"
      }
    }
    update(e) {
      const t = this._cachedMeta,
        {
          data: n = []
        } = t,
        r = this.chart._animationsDisabled;
      let {
        start: i,
        count: s
      } = Ye(t, n, r);
      if (this._drawStart = i, this._drawCount = s, Je(t) && (i = 0, s = n.length), this.options.showLine) {
        this.datasetElementType || this.addElements();
        const {
          dataset: i,
          _dataset: s
        } = t;
        i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = n;
        const o = this.resolveDatasetElementOptions(e);
        o.segment = this.options.segment, this.updateElement(i, void 0, {
          animated: !r,
          options: o
        }, e)
      } else this.datasetElementType && (delete t.dataset, this.datasetElementType = !1);
      this.updateElements(n, i, s, e)
    }
    addElements() {
      const {
        showLine: e
      } = this.options;
      !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements()
    }
    updateElements(e, t, n, r) {
      const i = "reset" === r,
        {
          iScale: s,
          vScale: o,
          _stacked: a,
          _dataset: l
        } = this._cachedMeta,
        c = this.resolveDataElementOptions(t, r),
        u = this.getSharedOptions(c),
        h = this.includeOptions(r, u),
        d = s.axis,
        f = o.axis,
        {
          spanGaps: p,
          segment: g
        } = this.options,
        m = Te(p) ? p : Number.POSITIVE_INFINITY,
        y = this.chart._animationsDisabled || i || "none" === r;
      let v = t > 0 && this.getParsed(t - 1);
      for (let b = t; b < t + n; ++b) {
        const t = e[b],
          n = this.getParsed(b),
          c = y ? t : {},
          p = K(n[f]),
          w = c[d] = s.getPixelForValue(n[d], b),
          _ = c[f] = i || p ? o.getBasePixel() : o.getPixelForValue(a ? this.applyStack(o, n, a) : n[f], b);
        c.skip = isNaN(w) || isNaN(_) || p, c.stop = b > 0 && Math.abs(n[d] - v[d]) > m, g && (c.parsed = n, c.raw = l.data[b]), h && (c.options = u || this.resolveDataElementOptions(b, t.active ? "active" : r)), y || this.updateElement(t, b, c, r), v = n
      }
      this.updateSharedOptions(u, r, c)
    }
    getMaxOverflow() {
      const e = this._cachedMeta,
        t = e.data || [];
      if (!this.options.showLine) {
        let e = 0;
        for (let n = t.length - 1; n >= 0; --n) e = Math.max(e, t[n].size(this.resolveDataElementOptions(n)) / 2);
        return e > 0 && e
      }
      const n = e.dataset,
        r = n.options && n.options.borderWidth || 0;
      if (!t.length) return r;
      const i = t[0].size(this.resolveDataElementOptions(0)),
        s = t[t.length - 1].size(this.resolveDataElementOptions(t.length - 1));
      return Math.max(r, i, s) / 2
    }
  }
  l(gr, "id", "scatter"), l(gr, "defaults", {
    datasetElementType: !1,
    dataElementType: "point",
    showLine: !1,
    fill: !1
  }), l(gr, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });

  function mr() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
  }
  class yr {
    static override(e) {
      Object.assign(yr.prototype, e)
    }
    constructor(e) {
      l(this, "options", void 0), this.options = e || {}
    }
    init() {}
    formats() {
      return mr()
    }
    parse() {
      return mr()
    }
    format() {
      return mr()
    }
    add() {
      return mr()
    }
    diff() {
      return mr()
    }
    startOf() {
      return mr()
    }
    endOf() {
      return mr()
    }
  }
  var vr = yr;

  function br(e, t, n, r) {
    const {
      controller: i,
      data: s,
      _sorted: o
    } = e, a = i._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
    if (a && t === a.axis && "r" !== t && o && s.length) {
      const o = a._reversePixels ? Be : Fe;
      if (!r) {
        const r = o(s, t, n);
        if (l) {
          const {
            vScale: t
          } = i._cachedMeta, {
            _parsed: n
          } = e, s = n.slice(0, r.lo + 1).reverse().findIndex(e => !K(e[t.axis]));
          r.lo -= Math.max(0, s);
          const o = n.slice(r.hi).findIndex(e => !K(e[t.axis]));
          r.hi += Math.max(0, o)
        }
        return r
      }
      if (i._sharedOptions) {
        const e = s[0],
          r = "function" === typeof e.getRange && e.getRange(t);
        if (r) {
          const e = o(s, t, n - r),
            i = o(s, t, n + r);
          return {
            lo: e.lo,
            hi: i.hi
          }
        }
      }
    }
    return {
      lo: 0,
      hi: s.length - 1
    }
  }

  function wr(e, t, n, r, i) {
    const s = e.getSortedVisibleDatasetMetas(),
      o = n[t];
    for (let a = 0, l = s.length; a < l; ++a) {
      const {
        index: e,
        data: n
      } = s[a], {
        lo: l,
        hi: c
      } = br(s[a], t, o, i);
      for (let t = l; t <= c; ++t) {
        const i = n[t];
        i.skip || r(i, e, t)
      }
    }
  }

  function _r(e, t, n, r, i) {
    const s = [];
    if (!i && !e.isPointInArea(t)) return s;
    return wr(e, n, t, function(n, o, a) {
      (i || _t(n, e.chartArea, 0)) && n.inRange(t.x, t.y, r) && s.push({
        element: n,
        datasetIndex: o,
        index: a
      })
    }, !0), s
  }

  function xr(e, t, n, r, i, s) {
    let o = [];
    const a = function(e) {
      const t = -1 !== e.indexOf("x"),
        n = -1 !== e.indexOf("y");
      return function(e, r) {
        const i = t ? Math.abs(e.x - r.x) : 0,
          s = n ? Math.abs(e.y - r.y) : 0;
        return Math.sqrt(Math.pow(i, 2) + Math.pow(s, 2))
      }
    }(n);
    let l = Number.POSITIVE_INFINITY;
    return wr(e, n, t, function(n, c, u) {
      const h = n.inRange(t.x, t.y, i);
      if (r && !h) return;
      const d = n.getCenterPoint(i);
      if (!(!!s || e.isPointInArea(d)) && !h) return;
      const f = a(t, d);
      f < l ? (o = [{
        element: n,
        datasetIndex: c,
        index: u
      }], l = f) : f === l && o.push({
        element: n,
        datasetIndex: c,
        index: u
      })
    }), o
  }

  function kr(e, t, n, r, i, s) {
    return s || e.isPointInArea(t) ? "r" !== n || r ? xr(e, t, n, r, i, s) : function(e, t, n, r) {
      let i = [];
      return wr(e, n, t, function(e, n, s) {
        const {
          startAngle: o,
          endAngle: a
        } = e.getProps(["startAngle", "endAngle"], r), {
          angle: l
        } = Re(e, {
          x: t.x,
          y: t.y
        });
        Ne(l, o, a) && i.push({
          element: e,
          datasetIndex: n,
          index: s
        })
      }), i
    }(e, t, n, i) : []
  }

  function Sr(e, t, n, r, i) {
    const s = [],
      o = "x" === n ? "inXRange" : "inYRange";
    let a = !1;
    return wr(e, n, t, (e, r, l) => {
      e[o] && e[o](t[n], i) && (s.push({
        element: e,
        datasetIndex: r,
        index: l
      }), a = a || e.inRange(t.x, t.y, i))
    }), r && !a ? [] : s
  }
  var Er = {
    evaluateInteractionItems: wr,
    modes: {
      index(e, t, n, r) {
        const i = gn(t, e),
          s = n.axis || "x",
          o = n.includeInvisible || !1,
          a = n.intersect ? _r(e, i, s, r, o) : kr(e, i, s, !1, r, o),
          l = [];
        return a.length ? (e.getSortedVisibleDatasetMetas().forEach(e => {
          const t = a[0].index,
            n = e.data[t];
          n && !n.skip && l.push({
            element: n,
            datasetIndex: e.index,
            index: t
          })
        }), l) : []
      },
      dataset(e, t, n, r) {
        const i = gn(t, e),
          s = n.axis || "xy",
          o = n.includeInvisible || !1;
        let a = n.intersect ? _r(e, i, s, r, o) : kr(e, i, s, !1, r, o);
        if (a.length > 0) {
          const t = a[0].datasetIndex,
            n = e.getDatasetMeta(t).data;
          a = [];
          for (let e = 0; e < n.length; ++e) a.push({
            element: n[e],
            datasetIndex: t,
            index: e
          })
        }
        return a
      },
      point: (e, t, n, r) => _r(e, gn(t, e), n.axis || "xy", r, n.includeInvisible || !1),
      nearest(e, t, n, r) {
        const i = gn(t, e),
          s = n.axis || "xy",
          o = n.includeInvisible || !1;
        return kr(e, i, s, n.intersect, r, o)
      },
      x: (e, t, n, r) => Sr(e, gn(t, e), "x", n.intersect, r),
      y: (e, t, n, r) => Sr(e, gn(t, e), "y", n.intersect, r)
    }
  };
  const Tr = ["left", "top", "right", "bottom"];

  function Cr(e, t) {
    return e.filter(e => e.pos === t)
  }

  function Or(e, t) {
    return e.filter(e => -1 === Tr.indexOf(e.pos) && e.box.axis === t)
  }

  function Pr(e, t) {
    return e.sort((e, n) => {
      const r = t ? n : e,
        i = t ? e : n;
      return r.weight === i.weight ? r.index - i.index : r.weight - i.weight
    })
  }

  function Ar(e, t) {
    const n = function(e) {
        const t = {};
        for (const n of e) {
          const {
            stack: e,
            pos: r,
            stackWeight: i
          } = n;
          if (!e || !Tr.includes(r)) continue;
          const s = t[e] || (t[e] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
          });
          s.count++, s.weight += i
        }
        return t
      }(e),
      {
        vBoxMaxWidth: r,
        hBoxMaxHeight: i
      } = t;
    let s, o, a;
    for (s = 0, o = e.length; s < o; ++s) {
      a = e[s];
      const {
        fullSize: o
      } = a.box, l = n[a.stack], c = l && a.stackWeight / l.weight;
      a.horizontal ? (a.width = c ? c * r : o && t.availableWidth, a.height = i) : (a.width = r, a.height = c ? c * i : o && t.availableHeight)
    }
    return n
  }

  function Rr(e, t, n, r) {
    return Math.max(e[n], t[n]) + Math.max(e[r], t[r])
  }

  function Mr(e, t) {
    e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right)
  }

  function Lr(e, t, n, r) {
    const {
      pos: i,
      box: s
    } = n, o = e.maxPadding;
    if (!Y(i)) {
      n.size && (e[i] -= n.size);
      const t = r[n.stack] || {
        size: 0,
        count: 1
      };
      t.size = Math.max(t.size, n.horizontal ? s.height : s.width), n.size = t.size / t.count, e[i] += n.size
    }
    s.getPadding && Mr(o, s.getPadding());
    const a = Math.max(0, t.outerWidth - Rr(o, e, "left", "right")),
      l = Math.max(0, t.outerHeight - Rr(o, e, "top", "bottom")),
      c = a !== e.w,
      u = l !== e.h;
    return e.w = a, e.h = l, n.horizontal ? {
      same: c,
      other: u
    } : {
      same: u,
      other: c
    }
  }

  function jr(e, t) {
    const n = t.maxPadding;

    function r(e) {
      const r = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      return e.forEach(e => {
        r[e] = Math.max(t[e], n[e])
      }), r
    }
    return r(e ? ["left", "right"] : ["top", "bottom"])
  }

  function Nr(e, t, n, r) {
    const i = [];
    let s, o, a, l, c, u;
    for (s = 0, o = e.length, c = 0; s < o; ++s) {
      a = e[s], l = a.box, l.update(a.width || t.w, a.height || t.h, jr(a.horizontal, t));
      const {
        same: o,
        other: h
      } = Lr(t, n, a, r);
      c |= o && i.length, u = u || h, l.fullSize || i.push(a)
    }
    return c && Nr(i, t, n, r) || u
  }

  function Ir(e, t, n, r, i) {
    e.top = n, e.left = t, e.right = t + r, e.bottom = n + i, e.width = r, e.height = i
  }

  function Dr(e, t, n, r) {
    const i = n.padding;
    let {
      x: s,
      y: o
    } = t;
    for (const a of e) {
      const e = a.box,
        l = r[a.stack] || {
          count: 1,
          placed: 0,
          weight: 1
        },
        c = a.stackWeight / l.weight || 1;
      if (a.horizontal) {
        const r = t.w * c,
          s = l.size || e.height;
        he(l.start) && (o = l.start), e.fullSize ? Ir(e, i.left, o, n.outerWidth - i.right - i.left, s) : Ir(e, t.left + l.placed, o, r, s), l.start = o, l.placed += r, o = e.bottom
      } else {
        const r = t.h * c,
          o = l.size || e.width;
        he(l.start) && (s = l.start), e.fullSize ? Ir(e, s, i.top, o, n.outerHeight - i.bottom - i.top) : Ir(e, s, t.top + l.placed, o, r), l.start = s, l.placed += r, s = e.right
      }
    }
    t.x = s, t.y = o
  }
  var zr = {
    addBox(e, t) {
      e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
        return [{
          z: 0,
          draw(e) {
            t.draw(e)
          }
        }]
      }, e.boxes.push(t)
    },
    removeBox(e, t) {
      const n = e.boxes ? e.boxes.indexOf(t) : -1; - 1 !== n && e.boxes.splice(n, 1)
    },
    configure(e, t, n) {
      t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight
    },
    update(e, t, n, r) {
      if (!e) return;
      const i = Dt(e.options.layout.padding),
        s = Math.max(t - i.width, 0),
        o = Math.max(n - i.height, 0),
        a = function(e) {
          const t = function(e) {
              const t = [];
              let n, r, i, s, o, a;
              for (n = 0, r = (e || []).length; n < r; ++n) i = e[n], ({
                position: s,
                options: {
                  stack: o,
                  stackWeight: a = 1
                }
              } = i), t.push({
                index: n,
                box: i,
                pos: s,
                horizontal: i.isHorizontal(),
                weight: i.weight,
                stack: o && s + o,
                stackWeight: a
              });
              return t
            }(e),
            n = Pr(t.filter(e => e.box.fullSize), !0),
            r = Pr(Cr(t, "left"), !0),
            i = Pr(Cr(t, "right")),
            s = Pr(Cr(t, "top"), !0),
            o = Pr(Cr(t, "bottom")),
            a = Or(t, "x"),
            l = Or(t, "y");
          return {
            fullSize: n,
            leftAndTop: r.concat(s),
            rightAndBottom: i.concat(l).concat(o).concat(a),
            chartArea: Cr(t, "chartArea"),
            vertical: r.concat(i).concat(l),
            horizontal: s.concat(o).concat(a)
          }
        }(e.boxes),
        l = a.vertical,
        c = a.horizontal;
      ee(e.boxes, e => {
        "function" === typeof e.beforeLayout && e.beforeLayout()
      });
      const u = l.reduce((e, t) => t.box.options && !1 === t.box.options.display ? e : e + 1, 0) || 1,
        h = Object.freeze({
          outerWidth: t,
          outerHeight: n,
          padding: i,
          availableWidth: s,
          availableHeight: o,
          vBoxMaxWidth: s / 2 / u,
          hBoxMaxHeight: o / 2
        }),
        d = Object.assign({}, i);
      Mr(d, Dt(r));
      const f = Object.assign({
          maxPadding: d,
          w: s,
          h: o,
          x: i.left,
          y: i.top
        }, i),
        p = Ar(l.concat(c), h);
      Nr(a.fullSize, f, h, p), Nr(l, f, h, p), Nr(c, f, h, p) && Nr(l, f, h, p),
        function(e) {
          const t = e.maxPadding;

          function n(n) {
            const r = Math.max(t[n] - e[n], 0);
            return e[n] += r, r
          }
          e.y += n("top"), e.x += n("left"), n("right"), n("bottom")
        }(f), Dr(a.leftAndTop, f, h, p), f.x += f.w, f.y += f.h, Dr(a.rightAndBottom, f, h, p), e.chartArea = {
          left: f.left,
          top: f.top,
          right: f.left + f.w,
          bottom: f.top + f.h,
          height: f.h,
          width: f.w
        }, ee(a.chartArea, t => {
          const n = t.box;
          Object.assign(n, e.chartArea), n.update(f.w, f.h, {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          })
        })
    }
  };
  class Fr {
    acquireContext(e, t) {}
    releaseContext(e) {
      return !1
    }
    addEventListener(e, t, n) {}
    removeEventListener(e, t, n) {}
    getDevicePixelRatio() {
      return 1
    }
    getMaximumSize(e, t, n, r) {
      return t = Math.max(0, t || e.width), n = n || e.height, {
        width: t,
        height: Math.max(0, r ? Math.floor(t / r) : n)
      }
    }
    isAttached(e) {
      return !0
    }
    updateConfig(e) {}
  }
  class Br extends Fr {
    acquireContext(e) {
      return e && e.getContext && e.getContext("2d") || null
    }
    updateConfig(e) {
      e.options.animation = !1
    }
  }
  const Ur = "$chartjs",
    Wr = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    },
    Hr = e => null === e || "" === e;
  const Vr = !!bn && {
    passive: !0
  };

  function qr(e, t, n) {
    e && e.canvas && e.canvas.removeEventListener(t, n, Vr)
  }

  function Kr(e, t) {
    for (const n of e)
      if (n === t || n.contains(t)) return !0
  }

  function $r(e, t, n) {
    const r = e.canvas,
      i = new MutationObserver(e => {
        let t = !1;
        for (const n of e) t = t || Kr(n.addedNodes, r), t = t && !Kr(n.removedNodes, r);
        t && n()
      });
    return i.observe(document, {
      childList: !0,
      subtree: !0
    }), i
  }

  function Yr(e, t, n) {
    const r = e.canvas,
      i = new MutationObserver(e => {
        let t = !1;
        for (const n of e) t = t || Kr(n.removedNodes, r), t = t && !Kr(n.addedNodes, r);
        t && n()
      });
    return i.observe(document, {
      childList: !0,
      subtree: !0
    }), i
  }
  const Jr = new Map;
  let Gr = 0;

  function Qr() {
    const e = window.devicePixelRatio;
    e !== Gr && (Gr = e, Jr.forEach((t, n) => {
      n.currentDevicePixelRatio !== e && t()
    }))
  }

  function Xr(e, t, n) {
    const r = e.canvas,
      i = r && un(r);
    if (!i) return;
    const s = qe((e, t) => {
        const r = i.clientWidth;
        n(e, t), r < i.clientWidth && n()
      }, window),
      o = new ResizeObserver(e => {
        const t = e[0],
          n = t.contentRect.width,
          r = t.contentRect.height;
        0 === n && 0 === r || s(n, r)
      });
    return o.observe(i),
      function(e, t) {
        Jr.size || window.addEventListener("resize", Qr), Jr.set(e, t)
      }(e, s), o
  }

  function Zr(e, t, n) {
    n && n.disconnect(), "resize" === t && function(e) {
      Jr.delete(e), Jr.size || window.removeEventListener("resize", Qr)
    }(e)
  }

  function ei(e, t, n) {
    const r = e.canvas,
      i = qe(t => {
        null !== e.ctx && n(function(e, t) {
          const n = Wr[e.type] || e.type,
            {
              x: r,
              y: i
            } = gn(e, t);
          return {
            type: n,
            chart: t,
            native: e,
            x: void 0 !== r ? r : null,
            y: void 0 !== i ? i : null
          }
        }(t, e))
      }, e);
    return function(e, t, n) {
      e && e.addEventListener(t, n, Vr)
    }(r, t, i), i
  }
  class ti extends Fr {
    acquireContext(e, t) {
      const n = e && e.getContext && e.getContext("2d");
      return n && n.canvas === e ? (function(e, t) {
        const n = e.style,
          r = e.getAttribute("height"),
          i = e.getAttribute("width");
        if (e[Ur] = {
            initial: {
              height: r,
              width: i,
              style: {
                display: n.display,
                height: n.height,
                width: n.width
              }
            }
          }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Hr(i)) {
          const t = wn(e, "width");
          void 0 !== t && (e.width = t)
        }
        if (Hr(r))
          if ("" === e.style.height) e.height = e.width / (t || 2);
          else {
            const t = wn(e, "height");
            void 0 !== t && (e.height = t)
          }
      }(e, t), n) : null
    }
    releaseContext(e) {
      const t = e.canvas;
      if (!t[Ur]) return !1;
      const n = t[Ur].initial;
      ["height", "width"].forEach(e => {
        const r = n[e];
        K(r) ? t.removeAttribute(e) : t.setAttribute(e, r)
      });
      const r = n.style || {};
      return Object.keys(r).forEach(e => {
        t.style[e] = r[e]
      }), t.width = t.width, delete t[Ur], !0
    }
    addEventListener(e, t, n) {
      this.removeEventListener(e, t);
      const r = e.$proxies || (e.$proxies = {}),
        i = {
          attach: $r,
          detach: Yr,
          resize: Xr
        } [t] || ei;
      r[t] = i(e, t, n)
    }
    removeEventListener(e, t) {
      const n = e.$proxies || (e.$proxies = {}),
        r = n[t];
      if (!r) return;
      ({
        attach: Zr,
        detach: Zr,
        resize: Zr
      } [t] || qr)(e, t, r), n[t] = void 0
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio
    }
    getMaximumSize(e, t, n, r) {
      return yn(e, t, n, r)
    }
    isAttached(e) {
      const t = e && un(e);
      return !(!t || !t.isConnected)
    }
  }
  class ni {
    constructor() {
      l(this, "x", void 0), l(this, "y", void 0), l(this, "active", !1), l(this, "options", void 0), l(this, "$animations", void 0)
    }
    tooltipPosition(e) {
      const {
        x: t,
        y: n
      } = this.getProps(["x", "y"], e);
      return {
        x: t,
        y: n
      }
    }
    hasValue() {
      return Te(this.x) && Te(this.y)
    }
    getProps(e, t) {
      const n = this.$animations;
      if (!t || !n) return this;
      const r = {};
      return e.forEach(e => {
        r[e] = n[e] && n[e].active() ? n[e]._to : this[e]
      }), r
    }
  }

  function ri(e, t) {
    const n = e.options.ticks,
      r = function(e) {
        const t = e.options.offset,
          n = e._tickSize(),
          r = e._length / n + (t ? 0 : 1),
          i = e._maxLength / n;
        return Math.floor(Math.min(r, i))
      }(e),
      i = Math.min(n.maxTicksLimit || r, r),
      s = n.major.enabled ? function(e) {
        const t = [];
        let n, r;
        for (n = 0, r = e.length; n < r; n++) e[n].major && t.push(n);
        return t
      }(t) : [],
      o = s.length,
      a = s[0],
      l = s[o - 1],
      c = [];
    if (o > i) return function(e, t, n, r) {
      let i, s = 0,
        o = n[0];
      for (r = Math.ceil(r), i = 0; i < e.length; i++) i === o && (t.push(e[i]), s++, o = n[s * r])
    }(t, c, s, o / i), c;
    const u = function(e, t, n) {
      const r = function(e) {
          const t = e.length;
          let n, r;
          if (t < 2) return !1;
          for (r = e[0], n = 1; n < t; ++n)
            if (e[n] - e[n - 1] !== r) return !1;
          return r
        }(e),
        i = t.length / n;
      if (!r) return Math.max(i, 1);
      const s = function(e) {
        const t = [],
          n = Math.sqrt(e);
        let r;
        for (r = 1; r < n; r++) e % r === 0 && (t.push(r), t.push(e / r));
        return n === (0 | n) && t.push(n), t.sort((e, t) => e - t).pop(), t
      }(r);
      for (let o = 0, a = s.length - 1; o < a; o++) {
        const e = s[o];
        if (e > i) return e
      }
      return Math.max(i, 1)
    }(s, t, i);
    if (o > 0) {
      let e, n;
      const r = o > 1 ? Math.round((l - a) / (o - 1)) : null;
      for (ii(t, c, u, K(r) ? 0 : a - r, a), e = 0, n = o - 1; e < n; e++) ii(t, c, u, s[e], s[e + 1]);
      return ii(t, c, u, l, K(r) ? t.length : l + r), c
    }
    return ii(t, c, u), c
  }

  function ii(e, t, n, r, i) {
    const s = Q(r, 0),
      o = Math.min(Q(i, e.length), e.length);
    let a, l, c, u = 0;
    for (n = Math.ceil(n), i && (a = i - r, n = a / Math.floor(a / n)), c = s; c < 0;) u++, c = Math.round(s + u * n);
    for (l = Math.max(s, 0); l < o; l++) l === c && (t.push(e[l]), u++, c = Math.round(s + u * n))
  }
  l(ni, "defaults", {}), l(ni, "defaultRoutes", void 0);
  const si = (e, t, n) => "top" === t || "left" === t ? e[t] + n : e[t] - n,
    oi = (e, t) => Math.min(t || e, e);

  function ai(e, t) {
    const n = [],
      r = e.length / t,
      i = e.length;
    let s = 0;
    for (; s < i; s += r) n.push(e[Math.floor(s)]);
    return n
  }

  function li(e, t, n) {
    const r = e.ticks.length,
      i = Math.min(t, r - 1),
      s = e._startPixel,
      o = e._endPixel,
      a = 1e-6;
    let l, c = e.getPixelForTick(i);
    if (!(n && (l = 1 === r ? Math.max(c - s, o - c) : 0 === t ? (e.getPixelForTick(1) - c) / 2 : (c - e.getPixelForTick(i - 1)) / 2, c += i < t ? l : -l, c < s - a || c > o + a))) return c
  }

  function ci(e) {
    return e.drawTicks ? e.tickLength : 0
  }

  function ui(e, t) {
    if (!e.display) return 0;
    const n = zt(e.font, t),
      r = Dt(e.padding);
    return ($(e.text) ? e.text.length : 1) * n.lineHeight + r.height
  }

  function hi(e, t, n) {
    let r = Ke(e);
    return (n && "right" !== t || !n && "right" === t) && (r = (e => "left" === e ? "right" : "right" === e ? "left" : e)(r)), r
  }
  class di extends ni {
    constructor(e) {
      super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
    }
    init(e) {
      this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax)
    }
    parse(e, t) {
      return e
    }
    getUserBounds() {
      let {
        _userMin: e,
        _userMax: t,
        _suggestedMin: n,
        _suggestedMax: r
      } = this;
      return e = G(e, Number.POSITIVE_INFINITY), t = G(t, Number.NEGATIVE_INFINITY), n = G(n, Number.POSITIVE_INFINITY), r = G(r, Number.NEGATIVE_INFINITY), {
        min: G(e, n),
        max: G(t, r),
        minDefined: J(e),
        maxDefined: J(t)
      }
    }
    getMinMax(e) {
      let t, {
        min: n,
        max: r,
        minDefined: i,
        maxDefined: s
      } = this.getUserBounds();
      if (i && s) return {
        min: n,
        max: r
      };
      const o = this.getMatchingVisibleMetas();
      for (let a = 0, l = o.length; a < l; ++a) t = o[a].controller.getMinMax(this, e), i || (n = Math.min(n, t.min)), s || (r = Math.max(r, t.max));
      return n = s && n > r ? r : n, r = i && n > r ? n : r, {
        min: G(n, G(r, n)),
        max: G(r, G(n, r))
      }
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      }
    }
    getTicks() {
      return this.ticks
    }
    getLabels() {
      const e = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || []
    }
    getLabelItems() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.chart.chartArea;
      return this._labelItems || (this._labelItems = this._computeLabelItems(e))
    }
    beforeLayout() {
      this._cache = {}, this._dataLimitsCached = !1
    }
    beforeUpdate() {
      Z(this.options.beforeUpdate, [this])
    }
    update(e, t, n) {
      const {
        beginAtZero: r,
        grace: i,
        ticks: s
      } = this.options, o = s.sampleSize;
      this.beforeUpdate(), this.maxWidth = e, this.maxHeight = t, this._margins = n = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function(e, t, n) {
        const {
          min: r,
          max: i
        } = e, s = X(t, (i - r) / 2), o = (e, t) => n && 0 === e ? 0 : e + t;
        return {
          min: o(r, -Math.abs(s)),
          max: o(i, s)
        }
      }(this, i, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
      const a = o < this.ticks.length;
      this._convertTicksToLabels(a ? ai(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || "auto" === s.source) && (this.ticks = ri(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
    }
    configure() {
      let e, t, n = this.options.reverse;
      this.isHorizontal() ? (e = this.left, t = this.right) : (e = this.top, t = this.bottom, n = !n), this._startPixel = e, this._endPixel = t, this._reversePixels = n, this._length = t - e, this._alignToPixels = this.options.alignToPixels
    }
    afterUpdate() {
      Z(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
      Z(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
    }
    afterSetDimensions() {
      Z(this.options.afterSetDimensions, [this])
    }
    _callHooks(e) {
      this.chart.notifyPlugins(e, this.getContext()), Z(this.options[e], [this])
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
      this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
      return []
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
      Z(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(e) {
      const t = this.options.ticks;
      let n, r, i;
      for (n = 0, r = e.length; n < r; n++) i = e[n], i.label = Z(t.callback, [i.value, n, e], this)
    }
    afterTickToLabelConversion() {
      Z(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
      Z(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
      const e = this.options,
        t = e.ticks,
        n = oi(this.ticks.length, e.ticks.maxTicksLimit),
        r = t.minRotation || 0,
        i = t.maxRotation;
      let s, o, a, l = r;
      if (!this._isVisible() || !t.display || r >= i || n <= 1 || !this.isHorizontal()) return void(this.labelRotation = r);
      const c = this._getLabelSizes(),
        u = c.widest.width,
        h = c.highest.height,
        d = Ie(this.chart.width - u, 0, this.maxWidth);
      s = e.offset ? this.maxWidth / n : d / (n - 1), u + 6 > s && (s = d / (n - (e.offset ? .5 : 1)), o = this.maxHeight - ci(e.grid) - t.padding - ui(e.title, this.chart.options.font), a = Math.sqrt(u * u + h * h), l = Pe(Math.min(Math.asin(Ie((c.highest.height + 6) / s, -1, 1)), Math.asin(Ie(o / a, -1, 1)) - Math.asin(Ie(h / a, -1, 1)))), l = Math.max(r, Math.min(i, l))), this.labelRotation = l
    }
    afterCalculateLabelRotation() {
      Z(this.options.afterCalculateLabelRotation, [this])
    }
    afterAutoSkip() {}
    beforeFit() {
      Z(this.options.beforeFit, [this])
    }
    fit() {
      const e = {
          width: 0,
          height: 0
        },
        {
          chart: t,
          options: {
            ticks: n,
            title: r,
            grid: i
          }
        } = this,
        s = this._isVisible(),
        o = this.isHorizontal();
      if (s) {
        const s = ui(r, t.options.font);
        if (o ? (e.width = this.maxWidth, e.height = ci(i) + s) : (e.height = this.maxHeight, e.width = ci(i) + s), n.display && this.ticks.length) {
          const {
            first: t,
            last: r,
            widest: i,
            highest: s
          } = this._getLabelSizes(), a = 2 * n.padding, l = Oe(this.labelRotation), c = Math.cos(l), u = Math.sin(l);
          if (o) {
            const t = n.mirror ? 0 : u * i.width + c * s.height;
            e.height = Math.min(this.maxHeight, e.height + t + a)
          } else {
            const t = n.mirror ? 0 : c * i.width + u * s.height;
            e.width = Math.min(this.maxWidth, e.width + t + a)
          }
          this._calculatePadding(t, r, u, c)
        }
      }
      this._handleMargins(), o ? (this.width = this._length = t.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = t.height - this._margins.top - this._margins.bottom)
    }
    _calculatePadding(e, t, n, r) {
      const {
        ticks: {
          align: i,
          padding: s
        },
        position: o
      } = this.options, a = 0 !== this.labelRotation, l = "top" !== o && "x" === this.axis;
      if (this.isHorizontal()) {
        const o = this.getPixelForTick(0) - this.left,
          c = this.right - this.getPixelForTick(this.ticks.length - 1);
        let u = 0,
          h = 0;
        a ? l ? (u = r * e.width, h = n * t.height) : (u = n * e.height, h = r * t.width) : "start" === i ? h = t.width : "end" === i ? u = e.width : "inner" !== i && (u = e.width / 2, h = t.width / 2), this.paddingLeft = Math.max((u - o + s) * this.width / (this.width - o), 0), this.paddingRight = Math.max((h - c + s) * this.width / (this.width - c), 0)
      } else {
        let n = t.height / 2,
          r = e.height / 2;
        "start" === i ? (n = 0, r = e.height) : "end" === i && (n = t.height, r = 0), this.paddingTop = n + s, this.paddingBottom = r + s
      }
    }
    _handleMargins() {
      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
    }
    afterFit() {
      Z(this.options.afterFit, [this])
    }
    isHorizontal() {
      const {
        axis: e,
        position: t
      } = this.options;
      return "top" === t || "bottom" === t || "x" === e
    }
    isFullSize() {
      return this.options.fullSize
    }
    _convertTicksToLabels(e) {
      let t, n;
      for (this.beforeTickToLabelConversion(), this.generateTickLabels(e), t = 0, n = e.length; t < n; t++) K(e[t].label) && (e.splice(t, 1), n--, t--);
      this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
      let e = this._labelSizes;
      if (!e) {
        const t = this.options.ticks.sampleSize;
        let n = this.ticks;
        t < n.length && (n = ai(n, t)), this._labelSizes = e = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit)
      }
      return e
    }
    _computeLabelSizes(e, t, n) {
      const {
        ctx: r,
        _longestTextCache: i
      } = this, s = [], o = [], a = Math.floor(t / oi(t, n));
      let l, c, u, h, d, f, p, g, m, y, v, b = 0,
        w = 0;
      for (l = 0; l < t; l += a) {
        if (h = e[l].label, d = this._resolveTickFontOptions(l), r.font = f = d.string, p = i[f] = i[f] || {
            data: {},
            gc: []
          }, g = d.lineHeight, m = y = 0, K(h) || $(h)) {
          if ($(h))
            for (c = 0, u = h.length; c < u; ++c) v = h[c], K(v) || $(v) || (m = gt(r, p.data, p.gc, m, v), y += g)
        } else m = gt(r, p.data, p.gc, m, h), y = g;
        s.push(m), o.push(y), b = Math.max(m, b), w = Math.max(y, w)
      }! function(e, t) {
        ee(e, e => {
          const n = e.gc,
            r = n.length / 2;
          let i;
          if (r > t) {
            for (i = 0; i < r; ++i) delete e.data[n[i]];
            n.splice(0, r)
          }
        })
      }(i, t);
      const _ = s.indexOf(b),
        x = o.indexOf(w),
        k = e => ({
          width: s[e] || 0,
          height: o[e] || 0
        });
      return {
        first: k(0),
        last: k(t - 1),
        widest: k(_),
        highest: k(x),
        widths: s,
        heights: o
      }
    }
    getLabelForValue(e) {
      return e
    }
    getPixelForValue(e, t) {
      return NaN
    }
    getValueForPixel(e) {}
    getPixelForTick(e) {
      const t = this.ticks;
      return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value)
    }
    getPixelForDecimal(e) {
      this._reversePixels && (e = 1 - e);
      const t = this._startPixel + e * this._length;
      return function(e) {
        return Ie(e, -32768, 32767)
      }(this._alignToPixels ? yt(this.chart, t, 0) : t)
    }
    getDecimalForPixel(e) {
      const t = (e - this._startPixel) / this._length;
      return this._reversePixels ? 1 - t : t
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
      const {
        min: e,
        max: t
      } = this;
      return e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0
    }
    getContext(e) {
      const t = this.ticks || [];
      if (e >= 0 && e < t.length) {
        const n = t[e];
        return n.$context || (n.$context = function(e, t, n) {
          return Bt(e, {
            tick: n,
            index: t,
            type: "tick"
          })
        }(this.getContext(), e, n))
      }
      return this.$context || (this.$context = Bt(this.chart.getContext(), {
        scale: this,
        type: "scale"
      }))
    }
    _tickSize() {
      const e = this.options.ticks,
        t = Oe(this.labelRotation),
        n = Math.abs(Math.cos(t)),
        r = Math.abs(Math.sin(t)),
        i = this._getLabelSizes(),
        s = e.autoSkipPadding || 0,
        o = i ? i.widest.width + s : 0,
        a = i ? i.highest.height + s : 0;
      return this.isHorizontal() ? a * n > o * r ? o / n : a / r : a * r < o * n ? a / n : o / r
    }
    _isVisible() {
      const e = this.options.display;
      return "auto" !== e ? !!e : this.getMatchingVisibleMetas().length > 0
    }
    _computeGridLineItems(e) {
      const t = this.axis,
        n = this.chart,
        r = this.options,
        {
          grid: i,
          position: s,
          border: o
        } = r,
        a = i.offset,
        l = this.isHorizontal(),
        c = this.ticks.length + (a ? 1 : 0),
        u = ci(i),
        h = [],
        d = o.setContext(this.getContext()),
        f = d.display ? d.width : 0,
        p = f / 2,
        g = function(e) {
          return yt(n, e, f)
        };
      let m, y, v, b, w, _, x, k, S, E, T, C;
      if ("top" === s) m = g(this.bottom), _ = this.bottom - u, k = m - p, E = g(e.top) + p, C = e.bottom;
      else if ("bottom" === s) m = g(this.top), E = e.top, C = g(e.bottom) - p, _ = m + p, k = this.top + u;
      else if ("left" === s) m = g(this.right), w = this.right - u, x = m - p, S = g(e.left) + p, T = e.right;
      else if ("right" === s) m = g(this.left), S = e.left, T = g(e.right) - p, w = m + p, x = this.left + u;
      else if ("x" === t) {
        if ("center" === s) m = g((e.top + e.bottom) / 2 + .5);
        else if (Y(s)) {
          const e = Object.keys(s)[0],
            t = s[e];
          m = g(this.chart.scales[e].getPixelForValue(t))
        }
        E = e.top, C = e.bottom, _ = m + p, k = _ + u
      } else if ("y" === t) {
        if ("center" === s) m = g((e.left + e.right) / 2);
        else if (Y(s)) {
          const e = Object.keys(s)[0],
            t = s[e];
          m = g(this.chart.scales[e].getPixelForValue(t))
        }
        w = m - p, x = w - u, S = e.left, T = e.right
      }
      const O = Q(r.ticks.maxTicksLimit, c),
        P = Math.max(1, Math.ceil(c / O));
      for (y = 0; y < c; y += P) {
        const e = this.getContext(y),
          t = i.setContext(e),
          r = o.setContext(e),
          s = t.lineWidth,
          c = t.color,
          u = r.dash || [],
          d = r.dashOffset,
          f = t.tickWidth,
          p = t.tickColor,
          g = t.tickBorderDash || [],
          m = t.tickBorderDashOffset;
        v = li(this, y, a), void 0 !== v && (b = yt(n, v, s), l ? w = x = S = T = b : _ = k = E = C = b, h.push({
          tx1: w,
          ty1: _,
          tx2: x,
          ty2: k,
          x1: S,
          y1: E,
          x2: T,
          y2: C,
          width: s,
          color: c,
          borderDash: u,
          borderDashOffset: d,
          tickWidth: f,
          tickColor: p,
          tickBorderDash: g,
          tickBorderDashOffset: m
        }))
      }
      return this._ticksLength = c, this._borderValue = m, h
    }
    _computeLabelItems(e) {
      const t = this.axis,
        n = this.options,
        {
          position: r,
          ticks: i
        } = n,
        s = this.isHorizontal(),
        o = this.ticks,
        {
          align: a,
          crossAlign: l,
          padding: c,
          mirror: u
        } = i,
        h = ci(n.grid),
        d = h + c,
        f = u ? -c : d,
        p = -Oe(this.labelRotation),
        g = [];
      let m, y, v, b, w, _, x, k, S, E, T, C, O = "middle";
      if ("top" === r) _ = this.bottom - f, x = this._getXAxisLabelAlignment();
      else if ("bottom" === r) _ = this.top + f, x = this._getXAxisLabelAlignment();
      else if ("left" === r) {
        const e = this._getYAxisLabelAlignment(h);
        x = e.textAlign, w = e.x
      } else if ("right" === r) {
        const e = this._getYAxisLabelAlignment(h);
        x = e.textAlign, w = e.x
      } else if ("x" === t) {
        if ("center" === r) _ = (e.top + e.bottom) / 2 + d;
        else if (Y(r)) {
          const e = Object.keys(r)[0],
            t = r[e];
          _ = this.chart.scales[e].getPixelForValue(t) + d
        }
        x = this._getXAxisLabelAlignment()
      } else if ("y" === t) {
        if ("center" === r) w = (e.left + e.right) / 2 - d;
        else if (Y(r)) {
          const e = Object.keys(r)[0],
            t = r[e];
          w = this.chart.scales[e].getPixelForValue(t)
        }
        x = this._getYAxisLabelAlignment(h).textAlign
      }
      "y" === t && ("start" === a ? O = "top" : "end" === a && (O = "bottom"));
      const P = this._getLabelSizes();
      for (m = 0, y = o.length; m < y; ++m) {
        v = o[m], b = v.label;
        const e = i.setContext(this.getContext(m));
        k = this.getPixelForTick(m) + i.labelOffset, S = this._resolveTickFontOptions(m), E = S.lineHeight, T = $(b) ? b.length : 1;
        const t = T / 2,
          n = e.color,
          a = e.textStrokeColor,
          c = e.textStrokeWidth;
        let h, d = x;
        if (s ? (w = k, "inner" === x && (d = m === y - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"), C = "top" === r ? "near" === l || 0 !== p ? -T * E + E / 2 : "center" === l ? -P.highest.height / 2 - t * E + E : -P.highest.height + E / 2 : "near" === l || 0 !== p ? E / 2 : "center" === l ? P.highest.height / 2 - t * E : P.highest.height - T * E, u && (C *= -1), 0 === p || e.showLabelBackdrop || (w += E / 2 * Math.sin(p))) : (_ = k, C = (1 - T) * E / 2), e.showLabelBackdrop) {
          const t = Dt(e.backdropPadding),
            n = P.heights[m],
            r = P.widths[m];
          let i = C - t.top,
            s = 0 - t.left;
          switch (O) {
            case "middle":
              i -= n / 2;
              break;
            case "bottom":
              i -= n
          }
          switch (x) {
            case "center":
              s -= r / 2;
              break;
            case "right":
              s -= r;
              break;
            case "inner":
              m === y - 1 ? s -= r : m > 0 && (s -= r / 2)
          }
          h = {
            left: s,
            top: i,
            width: r + t.width,
            height: n + t.height,
            color: e.backdropColor
          }
        }
        g.push({
          label: b,
          font: S,
          textOffset: C,
          options: {
            rotation: p,
            color: n,
            strokeColor: a,
            strokeWidth: c,
            textAlign: d,
            textBaseline: O,
            translation: [w, _],
            backdrop: h
          }
        })
      }
      return g
    }
    _getXAxisLabelAlignment() {
      const {
        position: e,
        ticks: t
      } = this.options;
      if (-Oe(this.labelRotation)) return "top" === e ? "left" : "right";
      let n = "center";
      return "start" === t.align ? n = "left" : "end" === t.align ? n = "right" : "inner" === t.align && (n = "inner"), n
    }
    _getYAxisLabelAlignment(e) {
      const {
        position: t,
        ticks: {
          crossAlign: n,
          mirror: r,
          padding: i
        }
      } = this.options, s = e + i, o = this._getLabelSizes().widest.width;
      let a, l;
      return "left" === t ? r ? (l = this.right + i, "near" === n ? a = "left" : "center" === n ? (a = "center", l += o / 2) : (a = "right", l += o)) : (l = this.right - s, "near" === n ? a = "right" : "center" === n ? (a = "center", l -= o / 2) : (a = "left", l = this.left)) : "right" === t ? r ? (l = this.left + i, "near" === n ? a = "right" : "center" === n ? (a = "center", l -= o / 2) : (a = "left", l -= o)) : (l = this.left + s, "near" === n ? a = "left" : "center" === n ? (a = "center", l += o / 2) : (a = "right", l = this.right)) : a = "right", {
        textAlign: a,
        x: l
      }
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) return;
      const e = this.chart,
        t = this.options.position;
      return "left" === t || "right" === t ? {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      } : "top" === t || "bottom" === t ? {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      } : void 0
    }
    drawBackground() {
      const {
        ctx: e,
        options: {
          backgroundColor: t
        },
        left: n,
        top: r,
        width: i,
        height: s
      } = this;
      t && (e.save(), e.fillStyle = t, e.fillRect(n, r, i, s), e.restore())
    }
    getLineWidthForValue(e) {
      const t = this.options.grid;
      if (!this._isVisible() || !t.display) return 0;
      const n = this.ticks.findIndex(t => t.value === e);
      if (n >= 0) {
        return t.setContext(this.getContext(n)).lineWidth
      }
      return 0
    }
    drawGrid(e) {
      const t = this.options.grid,
        n = this.ctx,
        r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
      let i, s;
      const o = (e, t, r) => {
        r.width && r.color && (n.save(), n.lineWidth = r.width, n.strokeStyle = r.color, n.setLineDash(r.borderDash || []), n.lineDashOffset = r.borderDashOffset, n.beginPath(), n.moveTo(e.x, e.y), n.lineTo(t.x, t.y), n.stroke(), n.restore())
      };
      if (t.display)
        for (i = 0, s = r.length; i < s; ++i) {
          const e = r[i];
          t.drawOnChartArea && o({
            x: e.x1,
            y: e.y1
          }, {
            x: e.x2,
            y: e.y2
          }, e), t.drawTicks && o({
            x: e.tx1,
            y: e.ty1
          }, {
            x: e.tx2,
            y: e.ty2
          }, {
            color: e.tickColor,
            width: e.tickWidth,
            borderDash: e.tickBorderDash,
            borderDashOffset: e.tickBorderDashOffset
          })
        }
    }
    drawBorder() {
      const {
        chart: e,
        ctx: t,
        options: {
          border: n,
          grid: r
        }
      } = this, i = n.setContext(this.getContext()), s = n.display ? i.width : 0;
      if (!s) return;
      const o = r.setContext(this.getContext(0)).lineWidth,
        a = this._borderValue;
      let l, c, u, h;
      this.isHorizontal() ? (l = yt(e, this.left, s) - s / 2, c = yt(e, this.right, o) + o / 2, u = h = a) : (u = yt(e, this.top, s) - s / 2, h = yt(e, this.bottom, o) + o / 2, l = c = a), t.save(), t.lineWidth = i.width, t.strokeStyle = i.color, t.beginPath(), t.moveTo(l, u), t.lineTo(c, h), t.stroke(), t.restore()
    }
    drawLabels(e) {
      if (!this.options.ticks.display) return;
      const t = this.ctx,
        n = this._computeLabelArea();
      n && xt(t, n);
      const r = this.getLabelItems(e);
      for (const i of r) {
        const e = i.options,
          n = i.font;
        Ot(t, i.label, 0, i.textOffset, n, e)
      }
      n && kt(t)
    }
    drawTitle() {
      const {
        ctx: e,
        options: {
          position: t,
          title: n,
          reverse: r
        }
      } = this;
      if (!n.display) return;
      const i = zt(n.font),
        s = Dt(n.padding),
        o = n.align;
      let a = i.lineHeight / 2;
      "bottom" === t || "center" === t || Y(t) ? (a += s.bottom, $(n.text) && (a += i.lineHeight * (n.text.length - 1))) : a += s.top;
      const {
        titleX: l,
        titleY: c,
        maxWidth: u,
        rotation: h
      } = function(e, t, n, r) {
        const {
          top: i,
          left: s,
          bottom: o,
          right: a,
          chart: l
        } = e, {
          chartArea: c,
          scales: u
        } = l;
        let h, d, f, p = 0;
        const g = o - i,
          m = a - s;
        if (e.isHorizontal()) {
          if (d = $e(r, s, a), Y(n)) {
            const e = Object.keys(n)[0],
              r = n[e];
            f = u[e].getPixelForValue(r) + g - t
          } else f = "center" === n ? (c.bottom + c.top) / 2 + g - t : si(e, n, t);
          h = a - s
        } else {
          if (Y(n)) {
            const e = Object.keys(n)[0],
              r = n[e];
            d = u[e].getPixelForValue(r) - m + t
          } else d = "center" === n ? (c.left + c.right) / 2 - m + t : si(e, n, t);
          f = $e(r, o, i), p = "left" === n ? -be : be
        }
        return {
          titleX: d,
          titleY: f,
          maxWidth: h,
          rotation: p
        }
      }(this, a, t, o);
      Ot(e, n.text, 0, 0, i, {
        color: n.color,
        maxWidth: u,
        rotation: h,
        textAlign: hi(o, t, r),
        textBaseline: "middle",
        translation: [l, c]
      })
    }
    draw(e) {
      this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e))
    }
    _layers() {
      const e = this.options,
        t = e.ticks && e.ticks.z || 0,
        n = Q(e.grid && e.grid.z, -1),
        r = Q(e.border && e.border.z, 0);
      return this._isVisible() && this.draw === di.prototype.draw ? [{
        z: n,
        draw: e => {
          this.drawBackground(), this.drawGrid(e), this.drawTitle()
        }
      }, {
        z: r,
        draw: () => {
          this.drawBorder()
        }
      }, {
        z: t,
        draw: e => {
          this.drawLabels(e)
        }
      }] : [{
        z: t,
        draw: e => {
          this.draw(e)
        }
      }]
    }
    getMatchingVisibleMetas(e) {
      const t = this.chart.getSortedVisibleDatasetMetas(),
        n = this.axis + "AxisID",
        r = [];
      let i, s;
      for (i = 0, s = t.length; i < s; ++i) {
        const s = t[i];
        s[n] !== this.id || e && s.type !== e || r.push(s)
      }
      return r
    }
    _resolveTickFontOptions(e) {
      return zt(this.options.ticks.setContext(this.getContext(e)).font)
    }
    _maxDigits() {
      const e = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / e
    }
  }
  class fi {
    constructor(e, t, n) {
      this.type = e, this.scope = t, this.override = n, this.items = Object.create(null)
    }
    isForType(e) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype)
    }
    register(e) {
      const t = Object.getPrototypeOf(e);
      let n;
      (function(e) {
        return "id" in e && "defaults" in e
      })(t) && (n = this.register(t));
      const r = this.items,
        i = e.id,
        s = this.scope + "." + i;
      if (!i) throw new Error("class does not have id: " + e);
      return i in r || (r[i] = e, function(e, t, n) {
        const r = se(Object.create(null), [n ? pt.get(n) : {}, pt.get(t), e.defaults]);
        pt.set(t, r), e.defaultRoutes && function(e, t) {
          Object.keys(t).forEach(n => {
            const r = n.split("."),
              i = r.pop(),
              s = [e].concat(r).join("."),
              o = t[n].split("."),
              a = o.pop(),
              l = o.join(".");
            pt.route(s, i, l, a)
          })
        }(t, e.defaultRoutes);
        e.descriptors && pt.describe(t, e.descriptors)
      }(e, s, n), this.override && pt.override(e.id, e.overrides)), s
    }
    get(e) {
      return this.items[e]
    }
    unregister(e) {
      const t = this.items,
        n = e.id,
        r = this.scope;
      n in t && delete t[n], r && n in pt[r] && (delete pt[r][n], this.override && delete ct[n])
    }
  }
  class pi {
    constructor() {
      this.controllers = new fi(Zn, "datasets", !0), this.elements = new fi(ni, "elements"), this.plugins = new fi(Object, "plugins"), this.scales = new fi(di, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("register", t)
    }
    remove() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("unregister", t)
    }
    addControllers() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("register", t, this.controllers)
    }
    addElements() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("register", t, this.elements)
    }
    addPlugins() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("register", t, this.plugins)
    }
    addScales() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("register", t, this.scales)
    }
    getController(e) {
      return this._get(e, this.controllers, "controller")
    }
    getElement(e) {
      return this._get(e, this.elements, "element")
    }
    getPlugin(e) {
      return this._get(e, this.plugins, "plugin")
    }
    getScale(e) {
      return this._get(e, this.scales, "scale")
    }
    removeControllers() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("unregister", t, this.controllers)
    }
    removeElements() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("unregister", t, this.elements)
    }
    removePlugins() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("unregister", t, this.plugins)
    }
    removeScales() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      this._each("unregister", t, this.scales)
    }
    _each(e, t, n) {
      [...t].forEach(t => {
        const r = n || this._getRegistryForType(t);
        n || r.isForType(t) || r === this.plugins && t.id ? this._exec(e, r, t) : ee(t, t => {
          const r = n || this._getRegistryForType(t);
          this._exec(e, r, t)
        })
      })
    }
    _exec(e, t, n) {
      const r = ue(e);
      Z(n["before" + r], [], n), t[e](n), Z(n["after" + r], [], n)
    }
    _getRegistryForType(e) {
      for (let t = 0; t < this._typedRegistries.length; t++) {
        const n = this._typedRegistries[t];
        if (n.isForType(e)) return n
      }
      return this.plugins
    }
    _get(e, t, n) {
      const r = t.get(e);
      if (void 0 === r) throw new Error('"' + e + '" is not a registered ' + n + ".");
      return r
    }
  }
  var gi = new pi;
  class mi {
    constructor() {
      this._init = void 0
    }
    notify(e, t, n, r) {
      if ("beforeInit" === t && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")), void 0 === this._init) return;
      const i = r ? this._descriptors(e).filter(r) : this._descriptors(e),
        s = this._notify(i, e, t, n);
      return "afterDestroy" === t && (this._notify(i, e, "stop"), this._notify(this._init, e, "uninstall"), this._init = void 0), s
    }
    _notify(e, t, n, r) {
      r = r || {};
      for (const i of e) {
        const e = i.plugin;
        if (!1 === Z(e[n], [t, r, i.options], e) && r.cancelable) return !1
      }
      return !0
    }
    invalidate() {
      K(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
    }
    _descriptors(e) {
      if (this._cache) return this._cache;
      const t = this._cache = this._createDescriptors(e);
      return this._notifyStateChanges(e), t
    }
    _createDescriptors(e, t) {
      const n = e && e.config,
        r = Q(n.options && n.options.plugins, {}),
        i = function(e) {
          const t = {},
            n = [],
            r = Object.keys(gi.plugins.items);
          for (let s = 0; s < r.length; s++) n.push(gi.getPlugin(r[s]));
          const i = e.plugins || [];
          for (let s = 0; s < i.length; s++) {
            const e = i[s]; - 1 === n.indexOf(e) && (n.push(e), t[e.id] = !0)
          }
          return {
            plugins: n,
            localIds: t
          }
        }(n);
      return !1 !== r || t ? function(e, t, n, r) {
        let {
          plugins: i,
          localIds: s
        } = t;
        const o = [],
          a = e.getContext();
        for (const l of i) {
          const t = l.id,
            i = yi(n[t], r);
          null !== i && o.push({
            plugin: l,
            options: vi(e.config, {
              plugin: l,
              local: s[t]
            }, i, a)
          })
        }
        return o
      }(e, i, r, t) : []
    }
    _notifyStateChanges(e) {
      const t = this._oldCache || [],
        n = this._cache,
        r = (e, t) => e.filter(e => !t.some(t => e.plugin.id === t.plugin.id));
      this._notify(r(t, n), e, "stop"), this._notify(r(n, t), e, "start")
    }
  }

  function yi(e, t) {
    return t || !1 !== e ? !0 === e ? {} : e : null
  }

  function vi(e, t, n, r) {
    let {
      plugin: i,
      local: s
    } = t;
    const o = e.pluginScopeKeys(i),
      a = e.getOptionScopes(n, o);
    return s && i.defaults && a.push(i.defaults), e.createResolver(a, r, [""], {
      scriptable: !1,
      indexable: !1,
      allKeys: !0
    })
  }

  function bi(e, t) {
    const n = pt.datasets[e] || {};
    return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x"
  }

  function wi(e) {
    if ("x" === e || "y" === e || "r" === e) return e
  }

  function _i(e) {
    return "top" === e || "bottom" === e ? "x" : "left" === e || "right" === e ? "y" : void 0
  }

  function xi(e) {
    if (wi(e)) return e;
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
    for (const i of n) {
      const t = i.axis || _i(i.position) || e.length > 1 && wi(e[0].toLowerCase());
      if (t) return t
    }
    throw new Error("Cannot determine type of '".concat(e, "' axis. Please provide 'axis' or 'position' option."))
  }

  function ki(e, t, n) {
    if (n[t + "AxisID"] === e) return {
      axis: t
    }
  }

  function Si(e, t) {
    const n = ct[e.type] || {
        scales: {}
      },
      r = t.scales || {},
      i = bi(e.type, t),
      s = Object.create(null);
    return Object.keys(r).forEach(t => {
      const o = r[t];
      if (!Y(o)) return console.error("Invalid scale configuration for scale: ".concat(t));
      if (o._proxy) return console.warn("Ignoring resolver passed as options for scale: ".concat(t));
      const a = xi(t, o, function(e, t) {
          if (t.data && t.data.datasets) {
            const n = t.data.datasets.filter(t => t.xAxisID === e || t.yAxisID === e);
            if (n.length) return ki(e, "x", n[0]) || ki(e, "y", n[0])
          }
          return {}
        }(t, e), pt.scales[o.type]),
        l = function(e, t) {
          return e === t ? "_index_" : "_value_"
        }(a, i),
        c = n.scales || {};
      s[t] = oe(Object.create(null), [{
        axis: a
      }, o, c[a], c[l]])
    }), e.data.datasets.forEach(n => {
      const i = n.type || e.type,
        o = n.indexAxis || bi(i, t),
        a = (ct[i] || {}).scales || {};
      Object.keys(a).forEach(e => {
        const t = function(e, t) {
            let n = e;
            return "_index_" === e ? n = t : "_value_" === e && (n = "x" === t ? "y" : "x"), n
          }(e, o),
          i = n[t + "AxisID"] || t;
        s[i] = s[i] || Object.create(null), oe(s[i], [{
          axis: t
        }, r[i], a[e]])
      })
    }), Object.keys(s).forEach(e => {
      const t = s[e];
      oe(t, [pt.scales[t.type], pt.scale])
    }), s
  }

  function Ei(e) {
    const t = e.options || (e.options = {});
    t.plugins = Q(t.plugins, {}), t.scales = Si(e, t)
  }

  function Ti(e) {
    return (e = e || {}).datasets = e.datasets || [], e.labels = e.labels || [], e
  }
  const Ci = new Map,
    Oi = new Set;

  function Pi(e, t) {
    let n = Ci.get(e);
    return n || (n = t(), Ci.set(e, n), Oi.add(n)), n
  }
  const Ai = (e, t, n) => {
    const r = ce(t, n);
    void 0 !== r && e.add(r)
  };
  class Ri {
    constructor(e) {
      this._config = function(e) {
        return (e = e || {}).data = Ti(e.data), Ei(e), e
      }(e), this._scopeCache = new Map, this._resolverCache = new Map
    }
    get platform() {
      return this._config.platform
    }
    get type() {
      return this._config.type
    }
    set type(e) {
      this._config.type = e
    }
    get data() {
      return this._config.data
    }
    set data(e) {
      this._config.data = Ti(e)
    }
    get options() {
      return this._config.options
    }
    set options(e) {
      this._config.options = e
    }
    get plugins() {
      return this._config.plugins
    }
    update() {
      const e = this._config;
      this.clearCache(), Ei(e)
    }
    clearCache() {
      this._scopeCache.clear(), this._resolverCache.clear()
    }
    datasetScopeKeys(e) {
      return Pi(e, () => [
        ["datasets.".concat(e), ""]
      ])
    }
    datasetAnimationScopeKeys(e, t) {
      return Pi("".concat(e, ".transition.").concat(t), () => [
        ["datasets.".concat(e, ".transitions.").concat(t), "transitions.".concat(t)],
        ["datasets.".concat(e), ""]
      ])
    }
    datasetElementScopeKeys(e, t) {
      return Pi("".concat(e, "-").concat(t), () => [
        ["datasets.".concat(e, ".elements.").concat(t), "datasets.".concat(e), "elements.".concat(t), ""]
      ])
    }
    pluginScopeKeys(e) {
      const t = e.id,
        n = this.type;
      return Pi("".concat(n, "-plugin-").concat(t), () => [
        ["plugins.".concat(t), ...e.additionalOptionScopes || []]
      ])
    }
    _cachedScopes(e, t) {
      const n = this._scopeCache;
      let r = n.get(e);
      return r && !t || (r = new Map, n.set(e, r)), r
    }
    getOptionScopes(e, t, n) {
      const {
        options: r,
        type: i
      } = this, s = this._cachedScopes(e, n), o = s.get(t);
      if (o) return o;
      const a = new Set;
      t.forEach(t => {
        e && (a.add(e), t.forEach(t => Ai(a, e, t))), t.forEach(e => Ai(a, r, e)), t.forEach(e => Ai(a, ct[i] || {}, e)), t.forEach(e => Ai(a, pt, e)), t.forEach(e => Ai(a, ut, e))
      });
      const l = Array.from(a);
      return 0 === l.length && l.push(Object.create(null)), Oi.has(t) && s.set(t, l), l
    }
    chartOptionScopes() {
      const {
        options: e,
        type: t
      } = this;
      return [e, ct[t] || {}, pt.datasets[t] || {}, {
        type: t
      }, pt, ut]
    }
    resolveNamedOptions(e, t, n) {
      let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [""];
      const i = {
          $shared: !0
        },
        {
          resolver: s,
          subPrefixes: o
        } = Mi(this._resolverCache, e, r);
      let a = s;
      if (function(e, t) {
          const {
            isScriptable: n,
            isIndexable: r
          } = Ht(e);
          for (const i of t) {
            const t = n(i),
              s = r(i),
              o = (s || t) && e[i];
            if (t && (de(o) || Li(o)) || s && $(o)) return !0
          }
          return !1
        }(s, t)) {
        i.$shared = !1;
        a = Wt(s, n = de(n) ? n() : n, this.createResolver(e, n, o))
      }
      for (const l of t) i[l] = a[l];
      return i
    }
    createResolver(e, t) {
      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [""],
        r = arguments.length > 3 ? arguments[3] : void 0;
      const {
        resolver: i
      } = Mi(this._resolverCache, e, n);
      return Y(t) ? Wt(i, t, void 0, r) : i
    }
  }

  function Mi(e, t, n) {
    let r = e.get(t);
    r || (r = new Map, e.set(t, r));
    const i = n.join();
    let s = r.get(i);
    if (!s) {
      s = {
        resolver: Ut(t, n),
        subPrefixes: n.filter(e => !e.toLowerCase().includes("hover"))
      }, r.set(i, s)
    }
    return s
  }
  const Li = e => Y(e) && Object.getOwnPropertyNames(e).some(t => de(e[t]));
  const ji = ["top", "bottom", "left", "right", "chartArea"];

  function Ni(e, t) {
    return "top" === e || "bottom" === e || -1 === ji.indexOf(e) && "x" === t
  }

  function Ii(e, t) {
    return function(n, r) {
      return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e]
    }
  }

  function Di(e) {
    const t = e.chart,
      n = t.options.animation;
    t.notifyPlugins("afterRender"), Z(n && n.onComplete, [e], t)
  }

  function zi(e) {
    const t = e.chart,
      n = t.options.animation;
    Z(n && n.onProgress, [e], t)
  }

  function Fi(e) {
    return cn() && "string" === typeof e ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e
  }
  const Bi = {},
    Ui = e => {
      const t = Fi(e);
      return Object.values(Bi).filter(e => e.canvas === t).pop()
    };

  function Wi(e, t, n) {
    const r = Object.keys(e);
    for (const i of r) {
      const r = +i;
      if (r >= t) {
        const s = e[i];
        delete e[i], (n > 0 || r > t) && (e[r + n] = s)
      }
    }
  }
  class Hi {
    static register() {
      gi.add(...arguments), Vi()
    }
    static unregister() {
      gi.remove(...arguments), Vi()
    }
    constructor(e, t) {
      const n = this.config = new Ri(t),
        r = Fi(e),
        i = Ui(r);
      if (i) throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused.");
      const s = n.createResolver(n.chartOptionScopes(), this.getContext());
      this.platform = new(n.platform || function(e) {
        return !cn() || "undefined" !== typeof OffscreenCanvas && e instanceof OffscreenCanvas ? Br : ti
      }(r)), this.platform.updateConfig(n);
      const o = this.platform.acquireContext(r, s.aspectRatio),
        a = o && o.canvas,
        l = a && a.height,
        c = a && a.width;
      this.id = q(), this.ctx = o, this.canvas = a, this.width = c, this.height = l, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new mi, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function(e, t) {
        let n;
        return function() {
          for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
          return t ? (clearTimeout(n), n = setTimeout(e, t, i)) : e.apply(this, i), t
        }
      }(e => this.update(e), s.resizeDelay || 0), this._dataChanges = [], Bi[this.id] = this, o && a ? (Dn.listen(this, "complete", Di), Dn.listen(this, "progress", zi), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
    }
    get aspectRatio() {
      const {
        options: {
          aspectRatio: e,
          maintainAspectRatio: t
        },
        width: n,
        height: r,
        _aspectRatio: i
      } = this;
      return K(e) ? t && i ? i : r ? n / r : null : e
    }
    get data() {
      return this.config.data
    }
    set data(e) {
      this.config.data = e
    }
    get options() {
      return this._options
    }
    set options(e) {
      this.config.options = e
    }
    get registry() {
      return gi
    }
    _initialize() {
      return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : vn(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
    }
    clear() {
      return vt(this.canvas, this.ctx), this
    }
    stop() {
      return Dn.stop(this), this
    }
    resize(e, t) {
      Dn.running(this) ? this._resizeBeforeDraw = {
        width: e,
        height: t
      } : this._resize(e, t)
    }
    _resize(e, t) {
      const n = this.options,
        r = this.canvas,
        i = n.maintainAspectRatio && this.aspectRatio,
        s = this.platform.getMaximumSize(r, e, t, i),
        o = n.devicePixelRatio || this.platform.getDevicePixelRatio(),
        a = this.width ? "resize" : "attach";
      this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, vn(this, o, !0) && (this.notifyPlugins("resize", {
        size: s
      }), Z(n.onResize, [this, s], this), this.attached && this._doResize(a) && this.render())
    }
    ensureScalesHaveIDs() {
      ee(this.options.scales || {}, (e, t) => {
        e.id = t
      })
    }
    buildOrUpdateScales() {
      const e = this.options,
        t = e.scales,
        n = this.scales,
        r = Object.keys(n).reduce((e, t) => (e[t] = !1, e), {});
      let i = [];
      t && (i = i.concat(Object.keys(t).map(e => {
        const n = t[e],
          r = xi(e, n),
          i = "r" === r,
          s = "x" === r;
        return {
          options: n,
          dposition: i ? "chartArea" : s ? "bottom" : "left",
          dtype: i ? "radialLinear" : s ? "category" : "linear"
        }
      }))), ee(i, t => {
        const i = t.options,
          s = i.id,
          o = xi(s, i),
          a = Q(i.type, t.dtype);
        void 0 !== i.position && Ni(i.position, o) === Ni(t.dposition) || (i.position = t.dposition), r[s] = !0;
        let l = null;
        if (s in n && n[s].type === a) l = n[s];
        else {
          l = new(gi.getScale(a))({
            id: s,
            type: a,
            ctx: this.ctx,
            chart: this
          }), n[l.id] = l
        }
        l.init(i, e)
      }), ee(r, (e, t) => {
        e || delete n[t]
      }), ee(n, e => {
        zr.configure(this, e, e.options), zr.addBox(this, e)
      })
    }
    _updateMetasets() {
      const e = this._metasets,
        t = this.data.datasets.length,
        n = e.length;
      if (e.sort((e, t) => e.index - t.index), n > t) {
        for (let e = t; e < n; ++e) this._destroyDatasetMeta(e);
        e.splice(t, n - t)
      }
      this._sortedMetasets = e.slice(0).sort(Ii("order", "index"))
    }
    _removeUnreferencedMetasets() {
      const {
        _metasets: e,
        data: {
          datasets: t
        }
      } = this;
      e.length > t.length && delete this._stacks, e.forEach((e, n) => {
        0 === t.filter(t => t === e._dataset).length && this._destroyDatasetMeta(n)
      })
    }
    buildOrUpdateControllers() {
      const e = [],
        t = this.data.datasets;
      let n, r;
      for (this._removeUnreferencedMetasets(), n = 0, r = t.length; n < r; n++) {
        const r = t[n];
        let i = this.getDatasetMeta(n);
        const s = r.type || this.config.type;
        if (i.type && i.type !== s && (this._destroyDatasetMeta(n), i = this.getDatasetMeta(n)), i.type = s, i.indexAxis = r.indexAxis || bi(s, this.options), i.order = r.order || 0, i.index = n, i.label = "" + r.label, i.visible = this.isDatasetVisible(n), i.controller) i.controller.updateIndex(n), i.controller.linkScales();
        else {
          const t = gi.getController(s),
            {
              datasetElementType: r,
              dataElementType: o
            } = pt.datasets[s];
          Object.assign(t, {
            dataElementType: gi.getElement(o),
            datasetElementType: r && gi.getElement(r)
          }), i.controller = new t(this, n), e.push(i.controller)
        }
      }
      return this._updateMetasets(), e
    }
    _resetElements() {
      ee(this.data.datasets, (e, t) => {
        this.getDatasetMeta(t).controller.reset()
      }, this)
    }
    reset() {
      this._resetElements(), this.notifyPlugins("reset")
    }
    update(e) {
      const t = this.config;
      t.update();
      const n = this._options = t.createResolver(t.chartOptionScopes(), this.getContext()),
        r = this._animationsDisabled = !n.animation;
      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
          mode: e,
          cancelable: !0
        })) return;
      const i = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let s = 0;
      for (let l = 0, c = this.data.datasets.length; l < c; l++) {
        const {
          controller: e
        } = this.getDatasetMeta(l), t = !r && -1 === i.indexOf(e);
        e.buildOrUpdateElements(t), s = Math.max(+e.getMaxOverflow(), s)
      }
      s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), r || ee(i, e => {
        e.reset()
      }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
        mode: e
      }), this._layers.sort(Ii("z", "_idx"));
      const {
        _active: o,
        _lastEvent: a
      } = this;
      a ? this._eventHandler(a, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render()
    }
    _updateScales() {
      ee(this.scales, e => {
        zr.removeBox(this, e)
      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
    }
    _checkEventBindings() {
      const e = this.options,
        t = new Set(Object.keys(this._listeners)),
        n = new Set(e.events);
      fe(t, n) && !!this._responsiveListeners === e.responsive || (this.unbindEvents(), this.bindEvents())
    }
    _updateHiddenIndices() {
      const {
        _hiddenIndices: e
      } = this, t = this._getUniformDataChanges() || [];
      for (const {
          method: n,
          start: r,
          count: i
        }
        of t) {
        Wi(e, r, "_removeElements" === n ? -i : i)
      }
    }
    _getUniformDataChanges() {
      const e = this._dataChanges;
      if (!e || !e.length) return;
      this._dataChanges = [];
      const t = this.data.datasets.length,
        n = t => new Set(e.filter(e => e[0] === t).map((e, t) => t + "," + e.splice(1).join(","))),
        r = n(0);
      for (let i = 1; i < t; i++)
        if (!fe(r, n(i))) return;
      return Array.from(r).map(e => e.split(",")).map(e => ({
        method: e[1],
        start: +e[2],
        count: +e[3]
      }))
    }
    _updateLayout(e) {
      if (!1 === this.notifyPlugins("beforeLayout", {
          cancelable: !0
        })) return;
      zr.update(this, this.width, this.height, e);
      const t = this.chartArea,
        n = t.width <= 0 || t.height <= 0;
      this._layers = [], ee(this.boxes, e => {
        n && "chartArea" === e.position || (e.configure && e.configure(), this._layers.push(...e._layers()))
      }, this), this._layers.forEach((e, t) => {
        e._idx = t
      }), this.notifyPlugins("afterLayout")
    }
    _updateDatasets(e) {
      if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
          mode: e,
          cancelable: !0
        })) {
        for (let e = 0, t = this.data.datasets.length; e < t; ++e) this.getDatasetMeta(e).controller.configure();
        for (let t = 0, n = this.data.datasets.length; t < n; ++t) this._updateDataset(t, de(e) ? e({
          datasetIndex: t
        }) : e);
        this.notifyPlugins("afterDatasetsUpdate", {
          mode: e
        })
      }
    }
    _updateDataset(e, t) {
      const n = this.getDatasetMeta(e),
        r = {
          meta: n,
          index: e,
          mode: t,
          cancelable: !0
        };
      !1 !== this.notifyPlugins("beforeDatasetUpdate", r) && (n.controller._update(t), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r))
    }
    render() {
      !1 !== this.notifyPlugins("beforeRender", {
        cancelable: !0
      }) && (Dn.has(this) ? this.attached && !Dn.running(this) && Dn.start(this) : (this.draw(), Di({
        chart: this
      })))
    }
    draw() {
      let e;
      if (this._resizeBeforeDraw) {
        const {
          width: e,
          height: t
        } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null, this._resize(e, t)
      }
      if (this.clear(), this.width <= 0 || this.height <= 0) return;
      if (!1 === this.notifyPlugins("beforeDraw", {
          cancelable: !0
        })) return;
      const t = this._layers;
      for (e = 0; e < t.length && t[e].z <= 0; ++e) t[e].draw(this.chartArea);
      for (this._drawDatasets(); e < t.length; ++e) t[e].draw(this.chartArea);
      this.notifyPlugins("afterDraw")
    }
    _getSortedDatasetMetas(e) {
      const t = this._sortedMetasets,
        n = [];
      let r, i;
      for (r = 0, i = t.length; r < i; ++r) {
        const i = t[r];
        e && !i.visible || n.push(i)
      }
      return n
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
      if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
          cancelable: !0
        })) return;
      const e = this.getSortedVisibleDatasetMetas();
      for (let t = e.length - 1; t >= 0; --t) this._drawDataset(e[t]);
      this.notifyPlugins("afterDatasetsDraw")
    }
    _drawDataset(e) {
      const t = this.ctx,
        n = {
          meta: e,
          index: e.index,
          cancelable: !0
        },
        r = Nn(this, e);
      !1 !== this.notifyPlugins("beforeDatasetDraw", n) && (r && xt(t, r), e.controller.draw(), r && kt(t), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n))
    }
    isPointInArea(e) {
      return _t(e, this.chartArea, this._minPadding)
    }
    getElementsAtEventForMode(e, t, n, r) {
      const i = Er.modes[t];
      return "function" === typeof i ? i(this, e, n, r) : []
    }
    getDatasetMeta(e) {
      const t = this.data.datasets[e],
        n = this._metasets;
      let r = n.filter(e => e && e._dataset === t).pop();
      return r || (r = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: t && t.order || 0,
        index: e,
        _dataset: t,
        _parsed: [],
        _sorted: !1
      }, n.push(r)), r
    }
    getContext() {
      return this.$context || (this.$context = Bt(null, {
        chart: this,
        type: "chart"
      }))
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(e) {
      const t = this.data.datasets[e];
      if (!t) return !1;
      const n = this.getDatasetMeta(e);
      return "boolean" === typeof n.hidden ? !n.hidden : !t.hidden
    }
    setDatasetVisibility(e, t) {
      this.getDatasetMeta(e).hidden = !t
    }
    toggleDataVisibility(e) {
      this._hiddenIndices[e] = !this._hiddenIndices[e]
    }
    getDataVisibility(e) {
      return !this._hiddenIndices[e]
    }
    _updateVisibility(e, t, n) {
      const r = n ? "show" : "hide",
        i = this.getDatasetMeta(e),
        s = i.controller._resolveAnimations(void 0, r);
      he(t) ? (i.data[t].hidden = !n, this.update()) : (this.setDatasetVisibility(e, n), s.update(i, {
        visible: n
      }), this.update(t => t.datasetIndex === e ? r : void 0))
    }
    hide(e, t) {
      this._updateVisibility(e, t, !1)
    }
    show(e, t) {
      this._updateVisibility(e, t, !0)
    }
    _destroyDatasetMeta(e) {
      const t = this._metasets[e];
      t && t.controller && t.controller._destroy(), delete this._metasets[e]
    }
    _stop() {
      let e, t;
      for (this.stop(), Dn.remove(this), e = 0, t = this.data.datasets.length; e < t; ++e) this._destroyDatasetMeta(e)
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const {
        canvas: e,
        ctx: t
      } = this;
      this._stop(), this.config.clearCache(), e && (this.unbindEvents(), vt(e, t), this.platform.releaseContext(t), this.canvas = null, this.ctx = null), delete Bi[this.id], this.notifyPlugins("afterDestroy")
    }
    toBase64Image() {
      return this.canvas.toDataURL(...arguments)
    }
    bindEvents() {
      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
    }
    bindUserEvents() {
      const e = this._listeners,
        t = this.platform,
        n = (n, r) => {
          t.addEventListener(this, n, r), e[n] = r
        },
        r = (e, t, n) => {
          e.offsetX = t, e.offsetY = n, this._eventHandler(e)
        };
      ee(this.options.events, e => n(e, r))
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {});
      const e = this._responsiveListeners,
        t = this.platform,
        n = (n, r) => {
          t.addEventListener(this, n, r), e[n] = r
        },
        r = (n, r) => {
          e[n] && (t.removeEventListener(this, n, r), delete e[n])
        },
        i = (e, t) => {
          this.canvas && this.resize(e, t)
        };
      let s;
      const o = () => {
        r("attach", o), this.attached = !0, this.resize(), n("resize", i), n("detach", s)
      };
      s = () => {
        this.attached = !1, r("resize", i), this._stop(), this._resize(0, 0), n("attach", o)
      }, t.isAttached(this.canvas) ? o() : s()
    }
    unbindEvents() {
      ee(this._listeners, (e, t) => {
        this.platform.removeEventListener(this, t, e)
      }), this._listeners = {}, ee(this._responsiveListeners, (e, t) => {
        this.platform.removeEventListener(this, t, e)
      }), this._responsiveListeners = void 0
    }
    updateHoverStyle(e, t, n) {
      const r = n ? "set" : "remove";
      let i, s, o, a;
      for ("dataset" === t && (i = this.getDatasetMeta(e[0].datasetIndex), i.controller["_" + r + "DatasetHoverStyle"]()), o = 0, a = e.length; o < a; ++o) {
        s = e[o];
        const t = s && this.getDatasetMeta(s.datasetIndex).controller;
        t && t[r + "HoverStyle"](s.element, s.datasetIndex, s.index)
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(e) {
      const t = this._active || [],
        n = e.map(e => {
          let {
            datasetIndex: t,
            index: n
          } = e;
          const r = this.getDatasetMeta(t);
          if (!r) throw new Error("No dataset found at index " + t);
          return {
            datasetIndex: t,
            element: r.data[n],
            index: n
          }
        });
      !te(n, t) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, t))
    }
    notifyPlugins(e, t, n) {
      return this._plugins.notify(this, e, t, n)
    }
    isPluginEnabled(e) {
      return 1 === this._plugins._cache.filter(t => t.plugin.id === e).length
    }
    _updateHoverStyles(e, t, n) {
      const r = this.options.hover,
        i = (e, t) => e.filter(e => !t.some(t => e.datasetIndex === t.datasetIndex && e.index === t.index)),
        s = i(t, e),
        o = n ? e : i(e, t);
      s.length && this.updateHoverStyle(s, r.mode, !1), o.length && r.mode && this.updateHoverStyle(o, r.mode, !0)
    }
    _eventHandler(e, t) {
      const n = {
          event: e,
          replay: t,
          cancelable: !0,
          inChartArea: this.isPointInArea(e)
        },
        r = t => (t.options.events || this.options.events).includes(e.native.type);
      if (!1 === this.notifyPlugins("beforeEvent", n, r)) return;
      const i = this._handleEvent(e, t, n.inChartArea);
      return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (i || n.changed) && this.render(), this
    }
    _handleEvent(e, t, n) {
      const {
        _active: r = [],
        options: i
      } = this, s = t, o = this._getActiveElements(e, r, n, s), a = function(e) {
        return "mouseup" === e.type || "click" === e.type || "contextmenu" === e.type
      }(e), l = function(e, t, n, r) {
        return n && "mouseout" !== e.type ? r ? t : e : null
      }(e, this._lastEvent, n, a);
      n && (this._lastEvent = null, Z(i.onHover, [e, o, this], this), a && Z(i.onClick, [e, o, this], this));
      const c = !te(o, r);
      return (c || t) && (this._active = o, this._updateHoverStyles(o, r, t)), this._lastEvent = l, c
    }
    _getActiveElements(e, t, n, r) {
      if ("mouseout" === e.type) return [];
      if (!n) return t;
      const i = this.options.hover;
      return this.getElementsAtEventForMode(e, i.mode, i, r)
    }
  }

  function Vi() {
    return ee(Hi.instances, e => e._plugins.invalidate())
  }

  function qi(e, t, n, r) {
    const i = function(e) {
        return jt(e, ["outerStart", "outerEnd", "innerStart", "innerEnd"])
      }(e.options.borderRadius),
      s = (n - t) / 2,
      o = Math.min(s, r * t / 2),
      a = e => {
        const t = (n - Math.min(s, e)) * r / 2;
        return Ie(e, 0, Math.min(s, t))
      };
    return {
      outerStart: a(i.outerStart),
      outerEnd: a(i.outerEnd),
      innerStart: Ie(i.innerStart, 0, o),
      innerEnd: Ie(i.innerEnd, 0, o)
    }
  }

  function Ki(e, t, n, r) {
    return {
      x: n + e * Math.cos(t),
      y: r + e * Math.sin(t)
    }
  }

  function $i(e, t, n, r, i, s) {
    const {
      x: o,
      y: a,
      startAngle: l,
      pixelMargin: c,
      innerRadius: u
    } = t, h = Math.max(t.outerRadius + r + n - c, 0), d = u > 0 ? u + r + n + c : 0;
    let f = 0;
    const p = i - l;
    if (r) {
      const e = ((u > 0 ? u - r : 0) + (h > 0 ? h - r : 0)) / 2;
      f = (p - (0 !== e ? p * e / (e + r) : p)) / 2
    }
    const g = (p - Math.max(.001, p * h - n / pe) / h) / 2,
      m = l + g + f,
      y = i - g - f,
      {
        outerStart: v,
        outerEnd: b,
        innerStart: w,
        innerEnd: _
      } = qi(t, d, h, y - m),
      x = h - v,
      k = h - b,
      S = m + v / x,
      E = y - b / k,
      T = d + w,
      C = d + _,
      O = m + w / T,
      P = y - _ / C;
    if (e.beginPath(), s) {
      const t = (S + E) / 2;
      if (e.arc(o, a, h, S, t), e.arc(o, a, h, t, E), b > 0) {
        const t = Ki(k, E, o, a);
        e.arc(t.x, t.y, b, E, y + be)
      }
      const n = Ki(C, y, o, a);
      if (e.lineTo(n.x, n.y), _ > 0) {
        const t = Ki(C, P, o, a);
        e.arc(t.x, t.y, _, y + be, P + Math.PI)
      }
      const r = (y - _ / d + (m + w / d)) / 2;
      if (e.arc(o, a, d, y - _ / d, r, !0), e.arc(o, a, d, r, m + w / d, !0), w > 0) {
        const t = Ki(T, O, o, a);
        e.arc(t.x, t.y, w, O + Math.PI, m - be)
      }
      const i = Ki(x, m, o, a);
      if (e.lineTo(i.x, i.y), v > 0) {
        const t = Ki(x, S, o, a);
        e.arc(t.x, t.y, v, m - be, S)
      }
    } else {
      e.moveTo(o, a);
      const t = Math.cos(S) * h + o,
        n = Math.sin(S) * h + a;
      e.lineTo(t, n);
      const r = Math.cos(E) * h + o,
        i = Math.sin(E) * h + a;
      e.lineTo(r, i)
    }
    e.closePath()
  }

  function Yi(e, t, n, r, i) {
    const {
      fullCircles: s,
      startAngle: o,
      circumference: a,
      options: l
    } = t, {
      borderWidth: c,
      borderJoinStyle: u,
      borderDash: h,
      borderDashOffset: d,
      borderRadius: f
    } = l, p = "inner" === l.borderAlign;
    if (!c) return;
    e.setLineDash(h || []), e.lineDashOffset = d, p ? (e.lineWidth = 2 * c, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel");
    let g = t.endAngle;
    if (s) {
      $i(e, t, n, r, g, i);
      for (let t = 0; t < s; ++t) e.stroke();
      isNaN(a) || (g = o + (a % ge || ge))
    }
    p && function(e, t, n) {
      const {
        startAngle: r,
        pixelMargin: i,
        x: s,
        y: o,
        outerRadius: a,
        innerRadius: l
      } = t;
      let c = i / a;
      e.beginPath(), e.arc(s, o, a, r - c, n + c), l > i ? (c = i / l, e.arc(s, o, l, n + c, r - c, !0)) : e.arc(s, o, i, n + be, r - be), e.closePath(), e.clip()
    }(e, t, g), l.selfJoin && g - o >= pe && 0 === f && "miter" !== u && function(e, t, n) {
      const {
        startAngle: r,
        x: i,
        y: s,
        outerRadius: o,
        innerRadius: a,
        options: l
      } = t, {
        borderWidth: c,
        borderJoinStyle: u
      } = l, h = Math.min(c / o, je(r - n));
      if (e.beginPath(), e.arc(i, s, o - c / 2, r + h / 2, n - h / 2), a > 0) {
        const t = Math.min(c / a, je(r - n));
        e.arc(i, s, a + c / 2, n - t / 2, r + t / 2, !0)
      } else {
        const t = Math.min(c / 2, o * je(r - n));
        if ("round" === u) e.arc(i, s, t, n - pe / 2, r + pe / 2, !0);
        else if ("bevel" === u) {
          const o = 2 * t * t,
            a = -o * Math.cos(n + pe / 2) + i,
            l = -o * Math.sin(n + pe / 2) + s,
            c = o * Math.cos(r + pe / 2) + i,
            u = o * Math.sin(r + pe / 2) + s;
          e.lineTo(a, l), e.lineTo(c, u)
        }
      }
      e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd")
    }(e, t, g), s || ($i(e, t, n, r, g, i), e.stroke())
  }
  l(Hi, "defaults", pt), l(Hi, "instances", Bi), l(Hi, "overrides", ct), l(Hi, "registry", gi), l(Hi, "version", "4.5.1"), l(Hi, "getChart", Ui);
  class Ji extends ni {
    constructor(e) {
      super(), l(this, "circumference", void 0), l(this, "endAngle", void 0), l(this, "fullCircles", void 0), l(this, "innerRadius", void 0), l(this, "outerRadius", void 0), l(this, "pixelMargin", void 0), l(this, "startAngle", void 0), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, e && Object.assign(this, e)
    }
    inRange(e, t, n) {
      const r = this.getProps(["x", "y"], n),
        {
          angle: i,
          distance: s
        } = Re(r, {
          x: e,
          y: t
        }),
        {
          startAngle: o,
          endAngle: a,
          innerRadius: l,
          outerRadius: c,
          circumference: u
        } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], n),
        h = (this.options.spacing + this.options.borderWidth) / 2,
        d = Q(u, a - o),
        f = Ne(i, o, a) && o !== a,
        p = d >= ge || f,
        g = De(s, l + h, c + h);
      return p && g
    }
    getCenterPoint(e) {
      const {
        x: t,
        y: n,
        startAngle: r,
        endAngle: i,
        innerRadius: s,
        outerRadius: o
      } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], e), {
        offset: a,
        spacing: l
      } = this.options, c = (r + i) / 2, u = (s + o + l + a) / 2;
      return {
        x: t + Math.cos(c) * u,
        y: n + Math.sin(c) * u
      }
    }
    tooltipPosition(e) {
      return this.getCenterPoint(e)
    }
    draw(e) {
      const {
        options: t,
        circumference: n
      } = this, r = (t.offset || 0) / 4, i = (t.spacing || 0) / 2, s = t.circular;
      if (this.pixelMargin = "inner" === t.borderAlign ? .33 : 0, this.fullCircles = n > ge ? Math.floor(n / ge) : 0, 0 === n || this.innerRadius < 0 || this.outerRadius < 0) return;
      e.save();
      const o = (this.startAngle + this.endAngle) / 2;
      e.translate(Math.cos(o) * r, Math.sin(o) * r);
      const a = r * (1 - Math.sin(Math.min(pe, n || 0)));
      e.fillStyle = t.backgroundColor, e.strokeStyle = t.borderColor,
        function(e, t, n, r, i) {
          const {
            fullCircles: s,
            startAngle: o,
            circumference: a
          } = t;
          let l = t.endAngle;
          if (s) {
            $i(e, t, n, r, l, i);
            for (let t = 0; t < s; ++t) e.fill();
            isNaN(a) || (l = o + (a % ge || ge))
          }
          $i(e, t, n, r, l, i), e.fill()
        }(e, this, a, i, s), Yi(e, this, a, i, s), e.restore()
    }
  }

  function Gi(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t;
    e.lineCap = Q(n.borderCapStyle, t.borderCapStyle), e.setLineDash(Q(n.borderDash, t.borderDash)), e.lineDashOffset = Q(n.borderDashOffset, t.borderDashOffset), e.lineJoin = Q(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = Q(n.borderWidth, t.borderWidth), e.strokeStyle = Q(n.borderColor, t.borderColor)
  }

  function Qi(e, t, n) {
    e.lineTo(n.x, n.y)
  }

  function Xi(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const r = e.length,
      {
        start: i = 0,
        end: s = r - 1
      } = n,
      {
        start: o,
        end: a
      } = t,
      l = Math.max(i, o),
      c = Math.min(s, a),
      u = i < o && s < o || i > a && s > a;
    return {
      count: r,
      start: l,
      loop: t.loop,
      ilen: c < l && !u ? r + c - l : c - l
    }
  }

  function Zi(e, t, n, r) {
    const {
      points: i,
      options: s
    } = t, {
      count: o,
      start: a,
      loop: l,
      ilen: c
    } = Xi(i, n, r), u = function(e) {
      return e.stepped ? St : e.tension || "monotone" === e.cubicInterpolationMode ? Et : Qi
    }(s);
    let h, d, f, {
      move: p = !0,
      reverse: g
    } = r || {};
    for (h = 0; h <= c; ++h) d = i[(a + (g ? c - h : h)) % o], d.skip || (p ? (e.moveTo(d.x, d.y), p = !1) : u(e, f, d, g, s.stepped), f = d);
    return l && (d = i[(a + (g ? c : 0)) % o], u(e, f, d, g, s.stepped)), !!l
  }

  function es(e, t, n, r) {
    const i = t.points,
      {
        count: s,
        start: o,
        ilen: a
      } = Xi(i, n, r),
      {
        move: l = !0,
        reverse: c
      } = r || {};
    let u, h, d, f, p, g, m = 0,
      y = 0;
    const v = e => (o + (c ? a - e : e)) % s,
      b = () => {
        f !== p && (e.lineTo(m, p), e.lineTo(m, f), e.lineTo(m, g))
      };
    for (l && (h = i[v(0)], e.moveTo(h.x, h.y)), u = 0; u <= a; ++u) {
      if (h = i[v(u)], h.skip) continue;
      const t = h.x,
        n = h.y,
        r = 0 | t;
      r === d ? (n < f ? f = n : n > p && (p = n), m = (y * m + t) / ++y) : (b(), e.lineTo(t, n), d = r, y = 0, f = p = n), g = n
    }
    b()
  }

  function ts(e) {
    const t = e.options,
      n = t.borderDash && t.borderDash.length;
    return !e._decimated && !e._loop && !t.tension && "monotone" !== t.cubicInterpolationMode && !t.stepped && !n ? es : Zi
  }
  l(Ji, "id", "arc"), l(Ji, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  }), l(Ji, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  }), l(Ji, "descriptors", {
    _scriptable: !0,
    _indexable: e => "borderDash" !== e
  });
  const ns = "function" === typeof Path2D;

  function rs(e, t, n, r) {
    ns && !t.options.segment ? function(e, t, n, r) {
      let i = t._path;
      i || (i = t._path = new Path2D, t.path(i, n, r) && i.closePath()), Gi(e, t.options), e.stroke(i)
    }(e, t, n, r) : function(e, t, n, r) {
      const {
        segments: i,
        options: s
      } = t, o = ts(t);
      for (const a of i) Gi(e, s, a.style), e.beginPath(), o(e, t, a, {
        start: n,
        end: n + r - 1
      }) && e.closePath(), e.stroke()
    }(e, t, n, r)
  }
  class is extends ni {
    constructor(e) {
      super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e)
    }
    updateControlPoints(e, t) {
      const n = this.options;
      if ((n.tension || "monotone" === n.cubicInterpolationMode) && !n.stepped && !this._pointsUpdated) {
        const r = n.spanGaps ? this._loop : this._fullLoop;
        ln(this._points, n, e, r, t), this._pointsUpdated = !0
      }
    }
    set points(e) {
      this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1
    }
    get points() {
      return this._points
    }
    get segments() {
      return this._segments || (this._segments = function(e, t) {
        const n = e.points,
          r = e.options.spanGaps,
          i = n.length;
        if (!i) return [];
        const s = !!e._loop,
          {
            start: o,
            end: a
          } = function(e, t, n, r) {
            let i = 0,
              s = t - 1;
            if (n && !r)
              for (; i < t && !e[i].skip;) i++;
            for (; i < t && e[i].skip;) i++;
            for (i %= t, n && (s += i); s > i && e[s % t].skip;) s--;
            return s %= t, {
              start: i,
              end: s
            }
          }(n, i, s, r);
        return Rn(e, !0 === r ? [{
          start: o,
          end: a,
          loop: s
        }] : function(e, t, n, r) {
          const i = e.length,
            s = [];
          let o, a = t,
            l = e[t];
          for (o = t + 1; o <= n; ++o) {
            const n = e[o % i];
            n.skip || n.stop ? l.skip || (r = !1, s.push({
              start: t % i,
              end: (o - 1) % i,
              loop: r
            }), t = a = n.stop ? o : null) : (a = o, l.skip && (t = o)), l = n
          }
          return null !== a && s.push({
            start: t % i,
            end: a % i,
            loop: r
          }), s
        }(n, o, a < o ? a + i : a, !!e._fullLoop && 0 === o && a === i - 1), n, t)
      }(this, this.options.segment))
    }
    first() {
      const e = this.segments,
        t = this.points;
      return e.length && t[e[0].start]
    }
    last() {
      const e = this.segments,
        t = this.points,
        n = e.length;
      return n && t[e[n - 1].end]
    }
    interpolate(e, t) {
      const n = this.options,
        r = e[t],
        i = this.points,
        s = An(this, {
          property: t,
          start: r,
          end: r
        });
      if (!s.length) return;
      const o = [],
        a = function(e) {
          return e.stepped ? xn : e.tension || "monotone" === e.cubicInterpolationMode ? kn : _n
        }(n);
      let l, c;
      for (l = 0, c = s.length; l < c; ++l) {
        const {
          start: c,
          end: u
        } = s[l], h = i[c], d = i[u];
        if (h === d) {
          o.push(h);
          continue
        }
        const f = a(h, d, Math.abs((r - h[t]) / (d[t] - h[t])), n.stepped);
        f[t] = e[t], o.push(f)
      }
      return 1 === o.length ? o[0] : o
    }
    pathSegment(e, t, n) {
      return ts(this)(e, this, t, n)
    }
    path(e, t, n) {
      const r = this.segments,
        i = ts(this);
      let s = this._loop;
      t = t || 0, n = n || this.points.length - t;
      for (const o of r) s &= i(e, this, o, {
        start: t,
        end: t + n - 1
      });
      return !!s
    }
    draw(e, t, n, r) {
      const i = this.options || {};
      (this.points || []).length && i.borderWidth && (e.save(), rs(e, this, n, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
    }
  }

  function ss(e, t, n, r) {
    const i = e.options,
      {
        [n]: s
      } = e.getProps([n], r);
    return Math.abs(t - s) < i.radius + i.hitRadius
  }
  l(is, "id", "line"), l(is, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  }), l(is, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  }), l(is, "descriptors", {
    _scriptable: !0,
    _indexable: e => "borderDash" !== e && "fill" !== e
  });
  class os extends ni {
    constructor(e) {
      super(), l(this, "parsed", void 0), l(this, "skip", void 0), l(this, "stop", void 0), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e)
    }
    inRange(e, t, n) {
      const r = this.options,
        {
          x: i,
          y: s
        } = this.getProps(["x", "y"], n);
      return Math.pow(e - i, 2) + Math.pow(t - s, 2) < Math.pow(r.hitRadius + r.radius, 2)
    }
    inXRange(e, t) {
      return ss(this, e, "x", t)
    }
    inYRange(e, t) {
      return ss(this, e, "y", t)
    }
    getCenterPoint(e) {
      const {
        x: t,
        y: n
      } = this.getProps(["x", "y"], e);
      return {
        x: t,
        y: n
      }
    }
    size(e) {
      let t = (e = e || this.options || {}).radius || 0;
      t = Math.max(t, t && e.hoverRadius || 0);
      return 2 * (t + (t && e.borderWidth || 0))
    }
    draw(e, t) {
      const n = this.options;
      this.skip || n.radius < .1 || !_t(this, t, this.size(n) / 2) || (e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.fillStyle = n.backgroundColor, bt(e, n, this.x, this.y))
    }
    getRange() {
      const e = this.options || {};
      return e.radius + e.hitRadius
    }
  }

  function as(e, t) {
    const {
      x: n,
      y: r,
      base: i,
      width: s,
      height: o
    } = e.getProps(["x", "y", "base", "width", "height"], t);
    let a, l, c, u, h;
    return e.horizontal ? (h = o / 2, a = Math.min(n, i), l = Math.max(n, i), c = r - h, u = r + h) : (h = s / 2, a = n - h, l = n + h, c = Math.min(r, i), u = Math.max(r, i)), {
      left: a,
      top: c,
      right: l,
      bottom: u
    }
  }

  function ls(e, t, n, r) {
    return e ? 0 : Ie(t, n, r)
  }

  function cs(e) {
    const t = as(e),
      n = t.right - t.left,
      r = t.bottom - t.top,
      i = function(e, t, n) {
        const r = e.options.borderWidth,
          i = e.borderSkipped,
          s = Nt(r);
        return {
          t: ls(i.top, s.top, 0, n),
          r: ls(i.right, s.right, 0, t),
          b: ls(i.bottom, s.bottom, 0, n),
          l: ls(i.left, s.left, 0, t)
        }
      }(e, n / 2, r / 2),
      s = function(e, t, n) {
        const {
          enableBorderRadius: r
        } = e.getProps(["enableBorderRadius"]), i = e.options.borderRadius, s = It(i), o = Math.min(t, n), a = e.borderSkipped, l = r || Y(i);
        return {
          topLeft: ls(!l || a.top || a.left, s.topLeft, 0, o),
          topRight: ls(!l || a.top || a.right, s.topRight, 0, o),
          bottomLeft: ls(!l || a.bottom || a.left, s.bottomLeft, 0, o),
          bottomRight: ls(!l || a.bottom || a.right, s.bottomRight, 0, o)
        }
      }(e, n / 2, r / 2);
    return {
      outer: {
        x: t.left,
        y: t.top,
        w: n,
        h: r,
        radius: s
      },
      inner: {
        x: t.left + i.l,
        y: t.top + i.t,
        w: n - i.l - i.r,
        h: r - i.t - i.b,
        radius: {
          topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)),
          topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)),
          bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)),
          bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r))
        }
      }
    }
  }

  function us(e, t, n, r) {
    const i = null === t,
      s = null === n,
      o = e && !(i && s) && as(e, r);
    return o && (i || De(t, o.left, o.right)) && (s || De(n, o.top, o.bottom))
  }

  function hs(e, t) {
    e.rect(t.x, t.y, t.w, t.h)
  }

  function ds(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const r = e.x !== n.x ? -t : 0,
      i = e.y !== n.y ? -t : 0,
      s = (e.x + e.w !== n.x + n.w ? t : 0) - r,
      o = (e.y + e.h !== n.y + n.h ? t : 0) - i;
    return {
      x: e.x + r,
      y: e.y + i,
      w: e.w + s,
      h: e.h + o,
      radius: e.radius
    }
  }
  l(os, "id", "point"), l(os, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  }), l(os, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  class fs extends ni {
    constructor(e) {
      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e)
    }
    draw(e) {
      const {
        inflateAmount: t,
        options: {
          borderColor: n,
          backgroundColor: r
        }
      } = this, {
        inner: i,
        outer: s
      } = cs(this), o = (a = s.radius).topLeft || a.topRight || a.bottomLeft || a.bottomRight ? Pt : hs;
      var a;
      e.save(), s.w === i.w && s.h === i.h || (e.beginPath(), o(e, ds(s, t, i)), e.clip(), o(e, ds(i, -t, s)), e.fillStyle = n, e.fill("evenodd")), e.beginPath(), o(e, ds(i, t)), e.fillStyle = r, e.fill(), e.restore()
    }
    inRange(e, t, n) {
      return us(this, e, t, n)
    }
    inXRange(e, t) {
      return us(this, e, null, t)
    }
    inYRange(e, t) {
      return us(this, null, e, t)
    }
    getCenterPoint(e) {
      const {
        x: t,
        y: n,
        base: r,
        horizontal: i
      } = this.getProps(["x", "y", "base", "horizontal"], e);
      return {
        x: i ? (t + r) / 2 : t,
        y: i ? n : (n + r) / 2
      }
    }
    getRange(e) {
      return "x" === e ? this.width / 2 : this.height / 2
    }
  }
  l(fs, "id", "bar"), l(fs, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  }), l(fs, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  const ps = (e, t) => {
    let {
      boxHeight: n = t,
      boxWidth: r = t
    } = e;
    return e.usePointStyle && (n = Math.min(n, t), r = e.pointStyleWidth || Math.min(r, t)), {
      boxWidth: r,
      boxHeight: n,
      itemHeight: Math.max(t, n)
    }
  };
  class gs extends ni {
    constructor(e) {
      super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(e, t, n) {
      this.maxWidth = e, this.maxHeight = t, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit()
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
    }
    buildLabels() {
      const e = this.options.labels || {};
      let t = Z(e.generateLabels, [this.chart], this) || [];
      e.filter && (t = t.filter(t => e.filter(t, this.chart.data))), e.sort && (t = t.sort((t, n) => e.sort(t, n, this.chart.data))), this.options.reverse && t.reverse(), this.legendItems = t
    }
    fit() {
      const {
        options: e,
        ctx: t
      } = this;
      if (!e.display) return void(this.width = this.height = 0);
      const n = e.labels,
        r = zt(n.font),
        i = r.size,
        s = this._computeTitleHeight(),
        {
          boxWidth: o,
          itemHeight: a
        } = ps(n, i);
      let l, c;
      t.font = r.string, this.isHorizontal() ? (l = this.maxWidth, c = this._fitRows(s, i, o, a) + 10) : (c = this.maxHeight, l = this._fitCols(s, r, o, a) + 10), this.width = Math.min(l, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight)
    }
    _fitRows(e, t, n, r) {
      const {
        ctx: i,
        maxWidth: s,
        options: {
          labels: {
            padding: o
          }
        }
      } = this, a = this.legendHitBoxes = [], l = this.lineWidths = [0], c = r + o;
      let u = e;
      i.textAlign = "left", i.textBaseline = "middle";
      let h = -1,
        d = -c;
      return this.legendItems.forEach((e, f) => {
        const p = n + t / 2 + i.measureText(e.text).width;
        (0 === f || l[l.length - 1] + p + 2 * o > s) && (u += c, l[l.length - (f > 0 ? 0 : 1)] = 0, d += c, h++), a[f] = {
          left: 0,
          top: d,
          row: h,
          width: p,
          height: r
        }, l[l.length - 1] += p + o
      }), u
    }
    _fitCols(e, t, n, r) {
      const {
        ctx: i,
        maxHeight: s,
        options: {
          labels: {
            padding: o
          }
        }
      } = this, a = this.legendHitBoxes = [], l = this.columnSizes = [], c = s - e;
      let u = o,
        h = 0,
        d = 0,
        f = 0,
        p = 0;
      return this.legendItems.forEach((e, s) => {
        const {
          itemWidth: g,
          itemHeight: m
        } = function(e, t, n, r, i) {
          const s = function(e, t, n, r) {
              let i = e.text;
              i && "string" !== typeof i && (i = i.reduce((e, t) => e.length > t.length ? e : t));
              return t + n.size / 2 + r.measureText(i).width
            }(r, e, t, n),
            o = function(e, t, n) {
              let r = e;
              "string" !== typeof t.text && (r = ms(t, n));
              return r
            }(i, r, t.lineHeight);
          return {
            itemWidth: s,
            itemHeight: o
          }
        }(n, t, i, e, r);
        s > 0 && d + m + 2 * o > c && (u += h + o, l.push({
          width: h,
          height: d
        }), f += h + o, p++, h = d = 0), a[s] = {
          left: f,
          top: d,
          col: p,
          width: g,
          height: m
        }, h = Math.max(h, g), d += m + o
      }), u += h, l.push({
        width: h,
        height: d
      }), u
    }
    adjustHitBoxes() {
      if (!this.options.display) return;
      const e = this._computeTitleHeight(),
        {
          legendHitBoxes: t,
          options: {
            align: n,
            labels: {
              padding: r
            },
            rtl: i
          }
        } = this,
        s = Sn(i, this.left, this.width);
      if (this.isHorizontal()) {
        let i = 0,
          o = $e(n, this.left + r, this.right - this.lineWidths[i]);
        for (const a of t) i !== a.row && (i = a.row, o = $e(n, this.left + r, this.right - this.lineWidths[i])), a.top += this.top + e + r, a.left = s.leftForLtr(s.x(o), a.width), o += a.width + r
      } else {
        let i = 0,
          o = $e(n, this.top + e + r, this.bottom - this.columnSizes[i].height);
        for (const a of t) a.col !== i && (i = a.col, o = $e(n, this.top + e + r, this.bottom - this.columnSizes[i].height)), a.top = o, a.left += this.left + r, a.left = s.leftForLtr(s.x(a.left), a.width), o += a.height + r
      }
    }
    isHorizontal() {
      return "top" === this.options.position || "bottom" === this.options.position
    }
    draw() {
      if (this.options.display) {
        const e = this.ctx;
        xt(e, this), this._draw(), kt(e)
      }
    }
    _draw() {
      const {
        options: e,
        columnSizes: t,
        lineWidths: n,
        ctx: r
      } = this, {
        align: i,
        labels: s
      } = e, o = pt.color, a = Sn(e.rtl, this.left, this.width), l = zt(s.font), {
        padding: c
      } = s, u = l.size, h = u / 2;
      let d;
      this.drawTitle(), r.textAlign = a.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = l.string;
      const {
        boxWidth: f,
        boxHeight: p,
        itemHeight: g
      } = ps(s, u), m = this.isHorizontal(), y = this._computeTitleHeight();
      d = m ? {
        x: $e(i, this.left + c, this.right - n[0]),
        y: this.top + c + y,
        line: 0
      } : {
        x: this.left + c,
        y: $e(i, this.top + y + c, this.bottom - t[0].height),
        line: 0
      }, En(this.ctx, e.textDirection);
      const v = g + c;
      this.legendItems.forEach((b, w) => {
        r.strokeStyle = b.fontColor, r.fillStyle = b.fontColor;
        const _ = r.measureText(b.text).width,
          x = a.textAlign(b.textAlign || (b.textAlign = s.textAlign)),
          k = f + h + _;
        let S = d.x,
          E = d.y;
        a.setWidth(this.width), m ? w > 0 && S + k + c > this.right && (E = d.y += v, d.line++, S = d.x = $e(i, this.left + c, this.right - n[d.line])) : w > 0 && E + v > this.bottom && (S = d.x = S + t[d.line].width + c, d.line++, E = d.y = $e(i, this.top + y + c, this.bottom - t[d.line].height));
        if (function(e, t, n) {
            if (isNaN(f) || f <= 0 || isNaN(p) || p < 0) return;
            r.save();
            const i = Q(n.lineWidth, 1);
            if (r.fillStyle = Q(n.fillStyle, o), r.lineCap = Q(n.lineCap, "butt"), r.lineDashOffset = Q(n.lineDashOffset, 0), r.lineJoin = Q(n.lineJoin, "miter"), r.lineWidth = i, r.strokeStyle = Q(n.strokeStyle, o), r.setLineDash(Q(n.lineDash, [])), s.usePointStyle) {
              const o = {
                  radius: p * Math.SQRT2 / 2,
                  pointStyle: n.pointStyle,
                  rotation: n.rotation,
                  borderWidth: i
                },
                l = a.xPlus(e, f / 2);
              wt(r, o, l, t + h, s.pointStyleWidth && f)
            } else {
              const s = t + Math.max((u - p) / 2, 0),
                o = a.leftForLtr(e, f),
                l = It(n.borderRadius);
              r.beginPath(), Object.values(l).some(e => 0 !== e) ? Pt(r, {
                x: o,
                y: s,
                w: f,
                h: p,
                radius: l
              }) : r.rect(o, s, f, p), r.fill(), 0 !== i && r.stroke()
            }
            r.restore()
          }(a.x(S), E, b), S = ((e, t, n, r) => e === (r ? "left" : "right") ? n : "center" === e ? (t + n) / 2 : t)(x, S + f + h, m ? S + k : this.right, e.rtl), function(e, t, n) {
            Ot(r, n.text, e, t + g / 2, l, {
              strikethrough: n.hidden,
              textAlign: a.textAlign(n.textAlign)
            })
          }(a.x(S), E, b), m) d.x += k + c;
        else if ("string" !== typeof b.text) {
          const e = l.lineHeight;
          d.y += ms(b, e) + c
        } else d.y += v
      }), Tn(this.ctx, e.textDirection)
    }
    drawTitle() {
      const e = this.options,
        t = e.title,
        n = zt(t.font),
        r = Dt(t.padding);
      if (!t.display) return;
      const i = Sn(e.rtl, this.left, this.width),
        s = this.ctx,
        o = t.position,
        a = n.size / 2,
        l = r.top + a;
      let c, u = this.left,
        h = this.width;
      if (this.isHorizontal()) h = Math.max(...this.lineWidths), c = this.top + l, u = $e(e.align, u, this.right - h);
      else {
        const t = this.columnSizes.reduce((e, t) => Math.max(e, t.height), 0);
        c = l + $e(e.align, this.top, this.bottom - t - e.labels.padding - this._computeTitleHeight())
      }
      const d = $e(o, u, u + h);
      s.textAlign = i.textAlign(Ke(o)), s.textBaseline = "middle", s.strokeStyle = t.color, s.fillStyle = t.color, s.font = n.string, Ot(s, t.text, d, c, n)
    }
    _computeTitleHeight() {
      const e = this.options.title,
        t = zt(e.font),
        n = Dt(e.padding);
      return e.display ? t.lineHeight + n.height : 0
    }
    _getLegendItemAt(e, t) {
      let n, r, i;
      if (De(e, this.left, this.right) && De(t, this.top, this.bottom))
        for (i = this.legendHitBoxes, n = 0; n < i.length; ++n)
          if (r = i[n], De(e, r.left, r.left + r.width) && De(t, r.top, r.top + r.height)) return this.legendItems[n];
      return null
    }
    handleEvent(e) {
      const t = this.options;
      if (! function(e, t) {
          if (("mousemove" === e || "mouseout" === e) && (t.onHover || t.onLeave)) return !0;
          if (t.onClick && ("click" === e || "mouseup" === e)) return !0;
          return !1
        }(e.type, t)) return;
      const n = this._getLegendItemAt(e.x, e.y);
      if ("mousemove" === e.type || "mouseout" === e.type) {
        const s = this._hoveredItem,
          o = (i = n, null !== (r = s) && null !== i && r.datasetIndex === i.datasetIndex && r.index === i.index);
        s && !o && Z(t.onLeave, [e, s, this], this), this._hoveredItem = n, n && !o && Z(t.onHover, [e, n, this], this)
      } else n && Z(t.onClick, [e, n, this], this);
      var r, i
    }
  }

  function ms(e, t) {
    return t * (e.text ? e.text.length : 0)
  }
  var ys = {
    id: "legend",
    _element: gs,
    start(e, t, n) {
      const r = e.legend = new gs({
        ctx: e.ctx,
        options: n,
        chart: e
      });
      zr.configure(e, r, n), zr.addBox(e, r)
    },
    stop(e) {
      zr.removeBox(e, e.legend), delete e.legend
    },
    beforeUpdate(e, t, n) {
      const r = e.legend;
      zr.configure(e, r, n), r.options = n
    },
    afterUpdate(e) {
      const t = e.legend;
      t.buildLabels(), t.adjustHitBoxes()
    },
    afterEvent(e, t) {
      t.replay || e.legend.handleEvent(t.event)
    },
    defaults: {
      display: !0,
      position: "top",
      align: "center",
      fullSize: !0,
      reverse: !1,
      weight: 1e3,
      onClick(e, t, n) {
        const r = t.datasetIndex,
          i = n.chart;
        i.isDatasetVisible(r) ? (i.hide(r), t.hidden = !0) : (i.show(r), t.hidden = !1)
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: e => e.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(e) {
          const t = e.data.datasets,
            {
              labels: {
                usePointStyle: n,
                pointStyle: r,
                textAlign: i,
                color: s,
                useBorderRadius: o,
                borderRadius: a
              }
            } = e.legend.options;
          return e._getSortedDatasetMetas().map(e => {
            const l = e.controller.getStyle(n ? 0 : void 0),
              c = Dt(l.borderWidth);
            return {
              text: t[e.index].label,
              fillStyle: l.backgroundColor,
              fontColor: s,
              hidden: !e.visible,
              lineCap: l.borderCapStyle,
              lineDash: l.borderDash,
              lineDashOffset: l.borderDashOffset,
              lineJoin: l.borderJoinStyle,
              lineWidth: (c.width + c.height) / 4,
              strokeStyle: l.borderColor,
              pointStyle: r || l.pointStyle,
              rotation: l.rotation,
              textAlign: i || l.textAlign,
              borderRadius: o && (a || l.borderRadius),
              datasetIndex: e.index
            }
          }, this)
        }
      },
      title: {
        color: e => e.chart.options.color,
        display: !1,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: e => !e.startsWith("on"),
      labels: {
        _scriptable: e => !["generateLabels", "filter", "sort"].includes(e)
      }
    }
  };
  class vs extends ni {
    constructor(e) {
      super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(e, t) {
      const n = this.options;
      if (this.left = 0, this.top = 0, !n.display) return void(this.width = this.height = this.right = this.bottom = 0);
      this.width = this.right = e, this.height = this.bottom = t;
      const r = $(n.text) ? n.text.length : 1;
      this._padding = Dt(n.padding);
      const i = r * zt(n.font).lineHeight + this._padding.height;
      this.isHorizontal() ? this.height = i : this.width = i
    }
    isHorizontal() {
      const e = this.options.position;
      return "top" === e || "bottom" === e
    }
    _drawArgs(e) {
      const {
        top: t,
        left: n,
        bottom: r,
        right: i,
        options: s
      } = this, o = s.align;
      let a, l, c, u = 0;
      return this.isHorizontal() ? (l = $e(o, n, i), c = t + e, a = i - n) : ("left" === s.position ? (l = n + e, c = $e(o, r, t), u = -.5 * pe) : (l = i - e, c = $e(o, t, r), u = .5 * pe), a = r - t), {
        titleX: l,
        titleY: c,
        maxWidth: a,
        rotation: u
      }
    }
    draw() {
      const e = this.ctx,
        t = this.options;
      if (!t.display) return;
      const n = zt(t.font),
        r = n.lineHeight / 2 + this._padding.top,
        {
          titleX: i,
          titleY: s,
          maxWidth: o,
          rotation: a
        } = this._drawArgs(r);
      Ot(e, t.text, 0, 0, n, {
        color: t.color,
        maxWidth: o,
        rotation: a,
        textAlign: Ke(t.align),
        textBaseline: "middle",
        translation: [i, s]
      })
    }
  }
  var bs = {
    id: "title",
    _element: vs,
    start(e, t, n) {
      ! function(e, t) {
        const n = new vs({
          ctx: e.ctx,
          options: t,
          chart: e
        });
        zr.configure(e, n, t), zr.addBox(e, n), e.titleBlock = n
      }(e, n)
    },
    stop(e) {
      const t = e.titleBlock;
      zr.removeBox(e, t), delete e.titleBlock
    },
    beforeUpdate(e, t, n) {
      const r = e.titleBlock;
      zr.configure(e, r, n), r.options = n
    },
    defaults: {
      align: "center",
      display: !1,
      font: {
        weight: "bold"
      },
      fullSize: !0,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: !0,
      _indexable: !1
    }
  };
  new WeakMap;
  const ws = {
    average(e) {
      if (!e.length) return !1;
      let t, n, r = new Set,
        i = 0,
        s = 0;
      for (t = 0, n = e.length; t < n; ++t) {
        const n = e[t].element;
        if (n && n.hasValue()) {
          const e = n.tooltipPosition();
          r.add(e.x), i += e.y, ++s
        }
      }
      if (0 === s || 0 === r.size) return !1;
      return {
        x: [...r].reduce((e, t) => e + t) / r.size,
        y: i / s
      }
    },
    nearest(e, t) {
      if (!e.length) return !1;
      let n, r, i, s = t.x,
        o = t.y,
        a = Number.POSITIVE_INFINITY;
      for (n = 0, r = e.length; n < r; ++n) {
        const r = e[n].element;
        if (r && r.hasValue()) {
          const e = Me(t, r.getCenterPoint());
          e < a && (a = e, i = r)
        }
      }
      if (i) {
        const e = i.tooltipPosition();
        s = e.x, o = e.y
      }
      return {
        x: s,
        y: o
      }
    }
  };

  function _s(e, t) {
    return t && ($(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e
  }

  function xs(e) {
    return ("string" === typeof e || e instanceof String) && e.indexOf("\n") > -1 ? e.split("\n") : e
  }

  function ks(e, t) {
    const {
      element: n,
      datasetIndex: r,
      index: i
    } = t, s = e.getDatasetMeta(r).controller, {
      label: o,
      value: a
    } = s.getLabelAndValue(i);
    return {
      chart: e,
      label: o,
      parsed: s.getParsed(i),
      raw: e.data.datasets[r].data[i],
      formattedValue: a,
      dataset: s.getDataset(),
      dataIndex: i,
      datasetIndex: r,
      element: n
    }
  }

  function Ss(e, t) {
    const n = e.chart.ctx,
      {
        body: r,
        footer: i,
        title: s
      } = e,
      {
        boxWidth: o,
        boxHeight: a
      } = t,
      l = zt(t.bodyFont),
      c = zt(t.titleFont),
      u = zt(t.footerFont),
      h = s.length,
      d = i.length,
      f = r.length,
      p = Dt(t.padding);
    let g = p.height,
      m = 0,
      y = r.reduce((e, t) => e + t.before.length + t.lines.length + t.after.length, 0);
    if (y += e.beforeBody.length + e.afterBody.length, h && (g += h * c.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), y) {
      g += f * (t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight) + (y - f) * l.lineHeight + (y - 1) * t.bodySpacing
    }
    d && (g += t.footerMarginTop + d * u.lineHeight + (d - 1) * t.footerSpacing);
    let v = 0;
    const b = function(e) {
      m = Math.max(m, n.measureText(e).width + v)
    };
    return n.save(), n.font = c.string, ee(e.title, b), n.font = l.string, ee(e.beforeBody.concat(e.afterBody), b), v = t.displayColors ? o + 2 + t.boxPadding : 0, ee(r, e => {
      ee(e.before, b), ee(e.lines, b), ee(e.after, b)
    }), v = 0, n.font = u.string, ee(e.footer, b), n.restore(), m += p.width, {
      width: m,
      height: g
    }
  }

  function Es(e, t, n, r) {
    const {
      x: i,
      width: s
    } = n, {
      width: o,
      chartArea: {
        left: a,
        right: l
      }
    } = e;
    let c = "center";
    return "center" === r ? c = i <= (a + l) / 2 ? "left" : "right" : i <= s / 2 ? c = "left" : i >= o - s / 2 && (c = "right"),
      function(e, t, n, r) {
        const {
          x: i,
          width: s
        } = r, o = n.caretSize + n.caretPadding;
        return "left" === e && i + s + o > t.width || "right" === e && i - s - o < 0 || void 0
      }(c, e, t, n) && (c = "center"), c
  }

  function Ts(e, t, n) {
    const r = n.yAlign || t.yAlign || function(e, t) {
      const {
        y: n,
        height: r
      } = t;
      return n < r / 2 ? "top" : n > e.height - r / 2 ? "bottom" : "center"
    }(e, n);
    return {
      xAlign: n.xAlign || t.xAlign || Es(e, t, n, r),
      yAlign: r
    }
  }

  function Cs(e, t, n, r) {
    const {
      caretSize: i,
      caretPadding: s,
      cornerRadius: o
    } = e, {
      xAlign: a,
      yAlign: l
    } = n, c = i + s, {
      topLeft: u,
      topRight: h,
      bottomLeft: d,
      bottomRight: f
    } = It(o);
    let p = function(e, t) {
      let {
        x: n,
        width: r
      } = e;
      return "right" === t ? n -= r : "center" === t && (n -= r / 2), n
    }(t, a);
    const g = function(e, t, n) {
      let {
        y: r,
        height: i
      } = e;
      return "top" === t ? r += n : r -= "bottom" === t ? i + n : i / 2, r
    }(t, l, c);
    return "center" === l ? "left" === a ? p += c : "right" === a && (p -= c) : "left" === a ? p -= Math.max(u, d) + i : "right" === a && (p += Math.max(h, f) + i), {
      x: Ie(p, 0, r.width - t.width),
      y: Ie(g, 0, r.height - t.height)
    }
  }

  function Os(e, t, n) {
    const r = Dt(n.padding);
    return "center" === t ? e.x + e.width / 2 : "right" === t ? e.x + e.width - r.right : e.x + r.left
  }

  function Ps(e) {
    return _s([], xs(e))
  }

  function As(e, t) {
    const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
    return n ? e.override(n) : e
  }
  const Rs = {
    beforeTitle: V,
    title(e) {
      if (e.length > 0) {
        const t = e[0],
          n = t.chart.data.labels,
          r = n ? n.length : 0;
        if (this && this.options && "dataset" === this.options.mode) return t.dataset.label || "";
        if (t.label) return t.label;
        if (r > 0 && t.dataIndex < r) return n[t.dataIndex]
      }
      return ""
    },
    afterTitle: V,
    beforeBody: V,
    beforeLabel: V,
    label(e) {
      if (this && this.options && "dataset" === this.options.mode) return e.label + ": " + e.formattedValue || e.formattedValue;
      let t = e.dataset.label || "";
      t && (t += ": ");
      const n = e.formattedValue;
      return K(n) || (t += n), t
    },
    labelColor(e) {
      const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
      return {
        borderColor: t.borderColor,
        backgroundColor: t.backgroundColor,
        borderWidth: t.borderWidth,
        borderDash: t.borderDash,
        borderDashOffset: t.borderDashOffset,
        borderRadius: 0
      }
    },
    labelTextColor() {
      return this.options.bodyColor
    },
    labelPointStyle(e) {
      const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
      return {
        pointStyle: t.pointStyle,
        rotation: t.rotation
      }
    },
    afterLabel: V,
    afterBody: V,
    beforeFooter: V,
    footer: V,
    afterFooter: V
  };

  function Ms(e, t, n, r) {
    const i = e[t].call(n, r);
    return "undefined" === typeof i ? Rs[t].call(n, r) : i
  }
  class Ls extends ni {
    constructor(e) {
      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
    }
    initialize(e) {
      this.options = e, this._cachedAnimations = void 0, this.$context = void 0
    }
    _resolveAnimations() {
      const e = this._cachedAnimations;
      if (e) return e;
      const t = this.chart,
        n = this.options.setContext(this.getContext()),
        r = n.enabled && t.options.animation && n.animations,
        i = new Un(this.chart, r);
      return r._cacheable && (this._cachedAnimations = Object.freeze(i)), i
    }
    getContext() {
      return this.$context || (this.$context = (e = this.chart.getContext(), t = this, n = this._tooltipItems, Bt(e, {
        tooltip: t,
        tooltipItems: n,
        type: "tooltip"
      })));
      var e, t, n
    }
    getTitle(e, t) {
      const {
        callbacks: n
      } = t, r = Ms(n, "beforeTitle", this, e), i = Ms(n, "title", this, e), s = Ms(n, "afterTitle", this, e);
      let o = [];
      return o = _s(o, xs(r)), o = _s(o, xs(i)), o = _s(o, xs(s)), o
    }
    getBeforeBody(e, t) {
      return Ps(Ms(t.callbacks, "beforeBody", this, e))
    }
    getBody(e, t) {
      const {
        callbacks: n
      } = t, r = [];
      return ee(e, e => {
        const t = {
            before: [],
            lines: [],
            after: []
          },
          i = As(n, e);
        _s(t.before, xs(Ms(i, "beforeLabel", this, e))), _s(t.lines, Ms(i, "label", this, e)), _s(t.after, xs(Ms(i, "afterLabel", this, e))), r.push(t)
      }), r
    }
    getAfterBody(e, t) {
      return Ps(Ms(t.callbacks, "afterBody", this, e))
    }
    getFooter(e, t) {
      const {
        callbacks: n
      } = t, r = Ms(n, "beforeFooter", this, e), i = Ms(n, "footer", this, e), s = Ms(n, "afterFooter", this, e);
      let o = [];
      return o = _s(o, xs(r)), o = _s(o, xs(i)), o = _s(o, xs(s)), o
    }
    _createItems(e) {
      const t = this._active,
        n = this.chart.data,
        r = [],
        i = [],
        s = [];
      let o, a, l = [];
      for (o = 0, a = t.length; o < a; ++o) l.push(ks(this.chart, t[o]));
      return e.filter && (l = l.filter((t, r, i) => e.filter(t, r, i, n))), e.itemSort && (l = l.sort((t, r) => e.itemSort(t, r, n))), ee(l, t => {
        const n = As(e.callbacks, t);
        r.push(Ms(n, "labelColor", this, t)), i.push(Ms(n, "labelPointStyle", this, t)), s.push(Ms(n, "labelTextColor", this, t))
      }), this.labelColors = r, this.labelPointStyles = i, this.labelTextColors = s, this.dataPoints = l, l
    }
    update(e, t) {
      const n = this.options.setContext(this.getContext()),
        r = this._active;
      let i, s = [];
      if (r.length) {
        const e = ws[n.position].call(this, r, this._eventPosition);
        s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
        const t = this._size = Ss(this, n),
          o = Object.assign({}, e, t),
          a = Ts(this.chart, n, o),
          l = Cs(n, o, a, this.chart);
        this.xAlign = a.xAlign, this.yAlign = a.yAlign, i = {
          opacity: 1,
          x: l.x,
          y: l.y,
          width: t.width,
          height: t.height,
          caretX: e.x,
          caretY: e.y
        }
      } else 0 !== this.opacity && (i = {
        opacity: 0
      });
      this._tooltipItems = s, this.$context = void 0, i && this._resolveAnimations().update(this, i), e && n.external && n.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay: t
      })
    }
    drawCaret(e, t, n, r) {
      const i = this.getCaretPosition(e, n, r);
      t.lineTo(i.x1, i.y1), t.lineTo(i.x2, i.y2), t.lineTo(i.x3, i.y3)
    }
    getCaretPosition(e, t, n) {
      const {
        xAlign: r,
        yAlign: i
      } = this, {
        caretSize: s,
        cornerRadius: o
      } = n, {
        topLeft: a,
        topRight: l,
        bottomLeft: c,
        bottomRight: u
      } = It(o), {
        x: h,
        y: d
      } = e, {
        width: f,
        height: p
      } = t;
      let g, m, y, v, b, w;
      return "center" === i ? (b = d + p / 2, "left" === r ? (g = h, m = g - s, v = b + s, w = b - s) : (g = h + f, m = g + s, v = b - s, w = b + s), y = g) : (m = "left" === r ? h + Math.max(a, c) + s : "right" === r ? h + f - Math.max(l, u) - s : this.caretX, "top" === i ? (v = d, b = v - s, g = m - s, y = m + s) : (v = d + p, b = v + s, g = m + s, y = m - s), w = v), {
        x1: g,
        x2: m,
        x3: y,
        y1: v,
        y2: b,
        y3: w
      }
    }
    drawTitle(e, t, n) {
      const r = this.title,
        i = r.length;
      let s, o, a;
      if (i) {
        const l = Sn(n.rtl, this.x, this.width);
        for (e.x = Os(this, n.titleAlign, n), t.textAlign = l.textAlign(n.titleAlign), t.textBaseline = "middle", s = zt(n.titleFont), o = n.titleSpacing, t.fillStyle = n.titleColor, t.font = s.string, a = 0; a < i; ++a) t.fillText(r[a], l.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + o, a + 1 === i && (e.y += n.titleMarginBottom - o)
      }
    }
    _drawColorBox(e, t, n, r, i) {
      const s = this.labelColors[n],
        o = this.labelPointStyles[n],
        {
          boxHeight: a,
          boxWidth: l
        } = i,
        c = zt(i.bodyFont),
        u = Os(this, "left", i),
        h = r.x(u),
        d = a < c.lineHeight ? (c.lineHeight - a) / 2 : 0,
        f = t.y + d;
      if (i.usePointStyle) {
        const t = {
            radius: Math.min(l, a) / 2,
            pointStyle: o.pointStyle,
            rotation: o.rotation,
            borderWidth: 1
          },
          n = r.leftForLtr(h, l) + l / 2,
          c = f + a / 2;
        e.strokeStyle = i.multiKeyBackground, e.fillStyle = i.multiKeyBackground, bt(e, t, n, c), e.strokeStyle = s.borderColor, e.fillStyle = s.backgroundColor, bt(e, t, n, c)
      } else {
        e.lineWidth = Y(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, e.strokeStyle = s.borderColor, e.setLineDash(s.borderDash || []), e.lineDashOffset = s.borderDashOffset || 0;
        const t = r.leftForLtr(h, l),
          n = r.leftForLtr(r.xPlus(h, 1), l - 2),
          o = It(s.borderRadius);
        Object.values(o).some(e => 0 !== e) ? (e.beginPath(), e.fillStyle = i.multiKeyBackground, Pt(e, {
          x: t,
          y: f,
          w: l,
          h: a,
          radius: o
        }), e.fill(), e.stroke(), e.fillStyle = s.backgroundColor, e.beginPath(), Pt(e, {
          x: n,
          y: f + 1,
          w: l - 2,
          h: a - 2,
          radius: o
        }), e.fill()) : (e.fillStyle = i.multiKeyBackground, e.fillRect(t, f, l, a), e.strokeRect(t, f, l, a), e.fillStyle = s.backgroundColor, e.fillRect(n, f + 1, l - 2, a - 2))
      }
      e.fillStyle = this.labelTextColors[n]
    }
    drawBody(e, t, n) {
      const {
        body: r
      } = this, {
        bodySpacing: i,
        bodyAlign: s,
        displayColors: o,
        boxHeight: a,
        boxWidth: l,
        boxPadding: c
      } = n, u = zt(n.bodyFont);
      let h = u.lineHeight,
        d = 0;
      const f = Sn(n.rtl, this.x, this.width),
        p = function(n) {
          t.fillText(n, f.x(e.x + d), e.y + h / 2), e.y += h + i
        },
        g = f.textAlign(s);
      let m, y, v, b, w, _, x;
      for (t.textAlign = s, t.textBaseline = "middle", t.font = u.string, e.x = Os(this, g, n), t.fillStyle = n.bodyColor, ee(this.beforeBody, p), d = o && "right" !== g ? "center" === s ? l / 2 + c : l + 2 + c : 0, b = 0, _ = r.length; b < _; ++b) {
        for (m = r[b], y = this.labelTextColors[b], t.fillStyle = y, ee(m.before, p), v = m.lines, o && v.length && (this._drawColorBox(t, e, b, f, n), h = Math.max(u.lineHeight, a)), w = 0, x = v.length; w < x; ++w) p(v[w]), h = u.lineHeight;
        ee(m.after, p)
      }
      d = 0, h = u.lineHeight, ee(this.afterBody, p), e.y -= i
    }
    drawFooter(e, t, n) {
      const r = this.footer,
        i = r.length;
      let s, o;
      if (i) {
        const a = Sn(n.rtl, this.x, this.width);
        for (e.x = Os(this, n.footerAlign, n), e.y += n.footerMarginTop, t.textAlign = a.textAlign(n.footerAlign), t.textBaseline = "middle", s = zt(n.footerFont), t.fillStyle = n.footerColor, t.font = s.string, o = 0; o < i; ++o) t.fillText(r[o], a.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + n.footerSpacing
      }
    }
    drawBackground(e, t, n, r) {
      const {
        xAlign: i,
        yAlign: s
      } = this, {
        x: o,
        y: a
      } = e, {
        width: l,
        height: c
      } = n, {
        topLeft: u,
        topRight: h,
        bottomLeft: d,
        bottomRight: f
      } = It(r.cornerRadius);
      t.fillStyle = r.backgroundColor, t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.beginPath(), t.moveTo(o + u, a), "top" === s && this.drawCaret(e, t, n, r), t.lineTo(o + l - h, a), t.quadraticCurveTo(o + l, a, o + l, a + h), "center" === s && "right" === i && this.drawCaret(e, t, n, r), t.lineTo(o + l, a + c - f), t.quadraticCurveTo(o + l, a + c, o + l - f, a + c), "bottom" === s && this.drawCaret(e, t, n, r), t.lineTo(o + d, a + c), t.quadraticCurveTo(o, a + c, o, a + c - d), "center" === s && "left" === i && this.drawCaret(e, t, n, r), t.lineTo(o, a + u), t.quadraticCurveTo(o, a, o + u, a), t.closePath(), t.fill(), r.borderWidth > 0 && t.stroke()
    }
    _updateAnimationTarget(e) {
      const t = this.chart,
        n = this.$animations,
        r = n && n.x,
        i = n && n.y;
      if (r || i) {
        const n = ws[e.position].call(this, this._active, this._eventPosition);
        if (!n) return;
        const s = this._size = Ss(this, e),
          o = Object.assign({}, n, this._size),
          a = Ts(t, e, o),
          l = Cs(e, o, a, t);
        r._to === l.x && i._to === l.y || (this.xAlign = a.xAlign, this.yAlign = a.yAlign, this.width = s.width, this.height = s.height, this.caretX = n.x, this.caretY = n.y, this._resolveAnimations().update(this, l))
      }
    }
    _willRender() {
      return !!this.opacity
    }
    draw(e) {
      const t = this.options.setContext(this.getContext());
      let n = this.opacity;
      if (!n) return;
      this._updateAnimationTarget(t);
      const r = {
          width: this.width,
          height: this.height
        },
        i = {
          x: this.x,
          y: this.y
        };
      n = Math.abs(n) < .001 ? 0 : n;
      const s = Dt(t.padding),
        o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      t.enabled && o && (e.save(), e.globalAlpha = n, this.drawBackground(i, e, r, t), En(e, t.textDirection), i.y += s.top, this.drawTitle(i, e, t), this.drawBody(i, e, t), this.drawFooter(i, e, t), Tn(e, t.textDirection), e.restore())
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(e, t) {
      const n = this._active,
        r = e.map(e => {
          let {
            datasetIndex: t,
            index: n
          } = e;
          const r = this.chart.getDatasetMeta(t);
          if (!r) throw new Error("Cannot find a dataset at index " + t);
          return {
            datasetIndex: t,
            element: r.data[n],
            index: n
          }
        }),
        i = !te(n, r),
        s = this._positionChanged(r, t);
      (i || s) && (this._active = r, this._eventPosition = t, this._ignoreReplayEvents = !0, this.update(!0))
    }
    handleEvent(e, t) {
      let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      if (t && this._ignoreReplayEvents) return !1;
      this._ignoreReplayEvents = !1;
      const r = this.options,
        i = this._active || [],
        s = this._getActiveElements(e, i, t, n),
        o = this._positionChanged(s, e),
        a = t || !te(s, i) || o;
      return a && (this._active = s, (r.enabled || r.external) && (this._eventPosition = {
        x: e.x,
        y: e.y
      }, this.update(!0, t))), a
    }
    _getActiveElements(e, t, n, r) {
      const i = this.options;
      if ("mouseout" === e.type) return [];
      if (!r) return t.filter(e => this.chart.data.datasets[e.datasetIndex] && void 0 !== this.chart.getDatasetMeta(e.datasetIndex).controller.getParsed(e.index));
      const s = this.chart.getElementsAtEventForMode(e, i.mode, i, n);
      return i.reverse && s.reverse(), s
    }
    _positionChanged(e, t) {
      const {
        caretX: n,
        caretY: r,
        options: i
      } = this, s = ws[i.position].call(this, e, t);
      return !1 !== s && (n !== s.x || r !== s.y)
    }
  }
  l(Ls, "positioners", ws);
  var js = {
    id: "tooltip",
    _element: Ls,
    positioners: ws,
    afterInit(e, t, n) {
      n && (e.tooltip = new Ls({
        chart: e,
        options: n
      }))
    },
    beforeUpdate(e, t, n) {
      e.tooltip && e.tooltip.initialize(n)
    },
    reset(e, t, n) {
      e.tooltip && e.tooltip.initialize(n)
    },
    afterDraw(e) {
      const t = e.tooltip;
      if (t && t._willRender()) {
        const n = {
          tooltip: t
        };
        if (!1 === e.notifyPlugins("beforeTooltipDraw", u(u({}, n), {}, {
            cancelable: !0
          }))) return;
        t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n)
      }
    },
    afterEvent(e, t) {
      if (e.tooltip) {
        const n = t.replay;
        e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0)
      }
    },
    defaults: {
      enabled: !0,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (e, t) => t.bodyFont.size,
      boxWidth: (e, t) => t.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: !0,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "width", "height", "caretX", "caretY"]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: Rs
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: e => "filter" !== e && "itemSort" !== e && "external" !== e,
      _indexable: !1,
      callbacks: {
        _scriptable: !1,
        _indexable: !1
      },
      animation: {
        _fallback: !1
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: ["interaction"]
  };

  function Ns(e, t, n, r) {
    const i = e.indexOf(t);
    if (-1 === i) return ((e, t, n, r) => ("string" === typeof t ? (n = e.push(t) - 1, r.unshift({
      index: n,
      label: t
    })) : isNaN(t) && (n = null), n))(e, t, n, r);
    return i !== e.lastIndexOf(t) ? n : i
  }

  function Is(e) {
    const t = this.getLabels();
    return e >= 0 && e < t.length ? t[e] : e
  }
  class Ds extends di {
    constructor(e) {
      super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
    }
    init(e) {
      const t = this._addedLabels;
      if (t.length) {
        const e = this.getLabels();
        for (const {
            index: n,
            label: r
          }
          of t) e[n] === r && e.splice(n, 1);
        this._addedLabels = []
      }
      super.init(e)
    }
    parse(e, t) {
      if (K(e)) return null;
      const n = this.getLabels();
      return ((e, t) => null === e ? null : Ie(Math.round(e), 0, t))(t = isFinite(t) && n[t] === e ? t : Ns(n, e, Q(t, e), this._addedLabels), n.length - 1)
    }
    determineDataLimits() {
      const {
        minDefined: e,
        maxDefined: t
      } = this.getUserBounds();
      let {
        min: n,
        max: r
      } = this.getMinMax(!0);
      "ticks" === this.options.bounds && (e || (n = 0), t || (r = this.getLabels().length - 1)), this.min = n, this.max = r
    }
    buildTicks() {
      const e = this.min,
        t = this.max,
        n = this.options.offset,
        r = [];
      let i = this.getLabels();
      i = 0 === e && t === i.length - 1 ? i : i.slice(e, t + 1), this._valueRange = Math.max(i.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? .5 : 0);
      for (let s = e; s <= t; s++) r.push({
        value: s
      });
      return r
    }
    getLabelForValue(e) {
      return Is.call(this, e)
    }
    configure() {
      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(e) {
      return "number" !== typeof e && (e = this.parse(e)), null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
    }
    getPixelForTick(e) {
      const t = this.ticks;
      return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value)
    }
    getValueForPixel(e) {
      return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange)
    }
    getBasePixel() {
      return this.bottom
    }
  }

  function zs(e, t) {
    const n = [],
      {
        bounds: r,
        step: i,
        min: s,
        max: o,
        precision: a,
        count: l,
        maxTicks: c,
        maxDigits: u,
        includeBounds: h
      } = e,
      d = i || 1,
      f = c - 1,
      {
        min: p,
        max: g
      } = t,
      m = !K(s),
      y = !K(o),
      v = !K(l),
      b = (g - p) / (u + 1);
    let w, _, x, k, S = Ee((g - p) / f / d) * d;
    if (S < 1e-14 && !m && !y) return [{
      value: p
    }, {
      value: g
    }];
    k = Math.ceil(g / S) - Math.floor(p / S), k > f && (S = Ee(k * S / f / d) * d), K(a) || (w = Math.pow(10, a), S = Math.ceil(S * w) / w), "ticks" === r ? (_ = Math.floor(p / S) * S, x = Math.ceil(g / S) * S) : (_ = p, x = g), m && y && i && function(e, t) {
      const n = Math.round(e);
      return n - t <= e && n + t >= e
    }((o - s) / i, S / 1e3) ? (k = Math.round(Math.min((o - s) / S, c)), S = (o - s) / k, _ = s, x = o) : v ? (_ = m ? s : _, x = y ? o : x, k = l - 1, S = (x - _) / k) : (k = (x - _) / S, k = Se(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));
    const E = Math.max(Ae(S), Ae(_));
    w = Math.pow(10, K(a) ? E : a), _ = Math.round(_ * w) / w, x = Math.round(x * w) / w;
    let T = 0;
    for (m && (h && _ !== s ? (n.push({
        value: s
      }), _ < s && T++, Se(Math.round((_ + T * S) * w) / w, s, Fs(s, b, e)) && T++) : _ < s && T++); T < k; ++T) {
      const e = Math.round((_ + T * S) * w) / w;
      if (y && e > o) break;
      n.push({
        value: e
      })
    }
    return y && h && x !== o ? n.length && Se(n[n.length - 1].value, o, Fs(o, b, e)) ? n[n.length - 1].value = o : n.push({
      value: o
    }) : y && x !== o || n.push({
      value: x
    }), n
  }

  function Fs(e, t, n) {
    let {
      horizontal: r,
      minRotation: i
    } = n;
    const s = Oe(i),
      o = (r ? Math.sin(s) : Math.cos(s)) || .001,
      a = .75 * t * ("" + e).length;
    return Math.min(t / o, a)
  }
  l(Ds, "id", "category"), l(Ds, "defaults", {
    ticks: {
      callback: Is
    }
  });
  class Bs extends di {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
    }
    parse(e, t) {
      return K(e) || ("number" === typeof e || e instanceof Number) && !isFinite(+e) ? null : +e
    }
    handleTickRangeOptions() {
      const {
        beginAtZero: e
      } = this.options, {
        minDefined: t,
        maxDefined: n
      } = this.getUserBounds();
      let {
        min: r,
        max: i
      } = this;
      const s = e => r = t ? r : e,
        o = e => i = n ? i : e;
      if (e) {
        const e = ke(r),
          t = ke(i);
        e < 0 && t < 0 ? o(0) : e > 0 && t > 0 && s(0)
      }
      if (r === i) {
        let t = 0 === i ? 1 : Math.abs(.05 * i);
        o(i + t), e || s(r - t)
      }
      this.min = r, this.max = i
    }
    getTickLimit() {
      const e = this.options.ticks;
      let t, {
        maxTicksLimit: n,
        stepSize: r
      } = e;
      return r ? (t = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, t > 1e3 && (console.warn("scales.".concat(this.id, ".ticks.stepSize: ").concat(r, " would result generating up to ").concat(t, " ticks. Limiting to 1000.")), t = 1e3)) : (t = this.computeTickLimit(), n = n || 11), n && (t = Math.min(n, t)), t
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY
    }
    buildTicks() {
      const e = this.options,
        t = e.ticks;
      let n = this.getTickLimit();
      n = Math.max(2, n);
      const r = zs({
        maxTicks: n,
        bounds: e.bounds,
        min: e.min,
        max: e.max,
        precision: t.precision,
        step: t.stepSize,
        count: t.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: t.minRotation || 0,
        includeBounds: !1 !== t.includeBounds
      }, this._range || this);
      return "ticks" === e.bounds && Ce(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r
    }
    configure() {
      const e = this.ticks;
      let t = this.min,
        n = this.max;
      if (super.configure(), this.options.offset && e.length) {
        const r = (n - t) / Math.max(e.length - 1, 1) / 2;
        t -= r, n += r
      }
      this._startValue = t, this._endValue = n, this._valueRange = n - t
    }
    getLabelForValue(e) {
      return ot(e, this.chart.options.locale, this.options.ticks.format)
    }
  }
  class Us extends Bs {
    determineDataLimits() {
      const {
        min: e,
        max: t
      } = this.getMinMax(!0);
      this.min = J(e) ? e : 0, this.max = J(t) ? t : 1, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      const e = this.isHorizontal(),
        t = e ? this.width : this.height,
        n = Oe(this.options.ticks.minRotation),
        r = (e ? Math.sin(n) : Math.cos(n)) || .001,
        i = this._resolveTickFontOptions(0);
      return Math.ceil(t / Math.min(40, i.lineHeight / r))
    }
    getPixelForValue(e) {
      return null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange)
    }
    getValueForPixel(e) {
      return this._startValue + this.getDecimalForPixel(e) * this._valueRange
    }
  }
  l(Us, "id", "linear"), l(Us, "defaults", {
    ticks: {
      callback: lt.formatters.numeric
    }
  });
  const Ws = e => Math.floor(xe(e)),
    Hs = (e, t) => Math.pow(10, Ws(e) + t);

  function Vs(e) {
    return 1 === e / Math.pow(10, Ws(e))
  }

  function qs(e, t, n) {
    const r = Math.pow(10, n),
      i = Math.floor(e / r);
    return Math.ceil(t / r) - i
  }

  function Ks(e, t) {
    let {
      min: n,
      max: r
    } = t;
    n = G(e.min, n);
    const i = [],
      s = Ws(n);
    let o = function(e, t) {
        let n = Ws(t - e);
        for (; qs(e, t, n) > 10;) n++;
        for (; qs(e, t, n) < 10;) n--;
        return Math.min(n, Ws(e))
      }(n, r),
      a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
    const l = Math.pow(10, o),
      c = s > o ? Math.pow(10, s) : 0,
      u = Math.round((n - c) * a) / a,
      h = Math.floor((n - c) / l / 10) * l * 10;
    let d = Math.floor((u - h) / Math.pow(10, o)),
      f = G(e.min, Math.round((c + h + d * Math.pow(10, o)) * a) / a);
    for (; f < r;) i.push({
      value: f,
      major: Vs(f),
      significand: d
    }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (o++, d = 2, a = o >= 0 ? 1 : a), f = Math.round((c + h + d * Math.pow(10, o)) * a) / a;
    const p = G(e.max, f);
    return i.push({
      value: p,
      major: Vs(p),
      significand: d
    }), i
  }
  class $s extends di {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
    }
    parse(e, t) {
      const n = Bs.prototype.parse.apply(this, [e, t]);
      if (0 !== n) return J(n) && n > 0 ? n : null;
      this._zero = !0
    }
    determineDataLimits() {
      const {
        min: e,
        max: t
      } = this.getMinMax(!0);
      this.min = J(e) ? Math.max(0, e) : null, this.max = J(t) ? Math.max(0, t) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !J(this._userMin) && (this.min = e === Hs(this.min, 0) ? Hs(this.min, -1) : Hs(this.min, 0)), this.handleTickRangeOptions()
    }
    handleTickRangeOptions() {
      const {
        minDefined: e,
        maxDefined: t
      } = this.getUserBounds();
      let n = this.min,
        r = this.max;
      const i = t => n = e ? n : t,
        s = e => r = t ? r : e;
      n === r && (n <= 0 ? (i(1), s(10)) : (i(Hs(n, -1)), s(Hs(r, 1)))), n <= 0 && i(Hs(r, -1)), r <= 0 && s(Hs(n, 1)), this.min = n, this.max = r
    }
    buildTicks() {
      const e = this.options,
        t = Ks({
          min: this._userMin,
          max: this._userMax
        }, this);
      return "ticks" === e.bounds && Ce(t, this, "value"), e.reverse ? (t.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), t
    }
    getLabelForValue(e) {
      return void 0 === e ? "0" : ot(e, this.chart.options.locale, this.options.ticks.format)
    }
    configure() {
      const e = this.min;
      super.configure(), this._startValue = xe(e), this._valueRange = xe(this.max) - xe(e)
    }
    getPixelForValue(e) {
      return void 0 !== e && 0 !== e || (e = this.min), null === e || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (xe(e) - this._startValue) / this._valueRange)
    }
    getValueForPixel(e) {
      const t = this.getDecimalForPixel(e);
      return Math.pow(10, this._startValue + t * this._valueRange)
    }
  }

  function Ys(e) {
    const t = e.ticks;
    if (t.display && e.display) {
      const e = Dt(t.backdropPadding);
      return Q(t.font && t.font.size, pt.font.size) + e.height
    }
    return 0
  }

  function Js(e, t, n) {
    return n = $(n) ? n : [n], {
      w: mt(e, t.string, n),
      h: n.length * t.lineHeight
    }
  }

  function Gs(e, t, n, r, i) {
    return e === r || e === i ? {
      start: t - n / 2,
      end: t + n / 2
    } : e < r || e > i ? {
      start: t - n,
      end: t
    } : {
      start: t,
      end: t + n
    }
  }

  function Qs(e) {
    const t = {
        l: e.left + e._padding.left,
        r: e.right - e._padding.right,
        t: e.top + e._padding.top,
        b: e.bottom - e._padding.bottom
      },
      n = Object.assign({}, t),
      r = [],
      i = [],
      s = e._pointLabels.length,
      o = e.options.pointLabels,
      a = o.centerPointLabels ? pe / s : 0;
    for (let l = 0; l < s; l++) {
      const s = o.setContext(e.getPointLabelContext(l));
      i[l] = s.padding;
      const c = e.getPointPosition(l, e.drawingArea + i[l], a),
        u = zt(s.font),
        h = Js(e.ctx, u, e._pointLabels[l]);
      r[l] = h;
      const d = je(e.getIndexAngle(l) + a),
        f = Math.round(Pe(d));
      Xs(n, t, d, Gs(f, c.x, h.w, 0, 180), Gs(f, c.y, h.h, 90, 270))
    }
    e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), e._pointLabelItems = function(e, t, n) {
      const r = [],
        i = e._pointLabels.length,
        s = e.options,
        {
          centerPointLabels: o,
          display: a
        } = s.pointLabels,
        l = {
          extra: Ys(s) / 2,
          additionalAngle: o ? pe / i : 0
        };
      let c;
      for (let u = 0; u < i; u++) {
        l.padding = n[u], l.size = t[u];
        const i = Zs(e, u, l);
        r.push(i), "auto" === a && (i.visible = eo(i, c), i.visible && (c = i))
      }
      return r
    }(e, r, i)
  }

  function Xs(e, t, n, r, i) {
    const s = Math.abs(Math.sin(n)),
      o = Math.abs(Math.cos(n));
    let a = 0,
      l = 0;
    r.start < t.l ? (a = (t.l - r.start) / s, e.l = Math.min(e.l, t.l - a)) : r.end > t.r && (a = (r.end - t.r) / s, e.r = Math.max(e.r, t.r + a)), i.start < t.t ? (l = (t.t - i.start) / o, e.t = Math.min(e.t, t.t - l)) : i.end > t.b && (l = (i.end - t.b) / o, e.b = Math.max(e.b, t.b + l))
  }

  function Zs(e, t, n) {
    const r = e.drawingArea,
      {
        extra: i,
        additionalAngle: s,
        padding: o,
        size: a
      } = n,
      l = e.getPointPosition(t, r + i + o, s),
      c = Math.round(Pe(je(l.angle + be))),
      u = function(e, t, n) {
        90 === n || 270 === n ? e -= t / 2 : (n > 270 || n < 90) && (e -= t);
        return e
      }(l.y, a.h, c),
      h = function(e) {
        if (0 === e || 180 === e) return "center";
        if (e < 180) return "left";
        return "right"
      }(c),
      d = function(e, t, n) {
        "right" === n ? e -= t : "center" === n && (e -= t / 2);
        return e
      }(l.x, a.w, h);
    return {
      visible: !0,
      x: l.x,
      y: u,
      textAlign: h,
      left: d,
      top: u,
      right: d + a.w,
      bottom: u + a.h
    }
  }

  function eo(e, t) {
    if (!t) return !0;
    const {
      left: n,
      top: r,
      right: i,
      bottom: s
    } = e;
    return !(_t({
      x: n,
      y: r
    }, t) || _t({
      x: n,
      y: s
    }, t) || _t({
      x: i,
      y: r
    }, t) || _t({
      x: i,
      y: s
    }, t))
  }

  function to(e, t, n) {
    const {
      left: r,
      top: i,
      right: s,
      bottom: o
    } = n, {
      backdropColor: a
    } = t;
    if (!K(a)) {
      const n = It(t.borderRadius),
        l = Dt(t.backdropPadding);
      e.fillStyle = a;
      const c = r - l.left,
        u = i - l.top,
        h = s - r + l.width,
        d = o - i + l.height;
      Object.values(n).some(e => 0 !== e) ? (e.beginPath(), Pt(e, {
        x: c,
        y: u,
        w: h,
        h: d,
        radius: n
      }), e.fill()) : e.fillRect(c, u, h, d)
    }
  }

  function no(e, t, n, r) {
    const {
      ctx: i
    } = e;
    if (n) i.arc(e.xCenter, e.yCenter, t, 0, ge);
    else {
      let n = e.getPointPosition(0, t);
      i.moveTo(n.x, n.y);
      for (let s = 1; s < r; s++) n = e.getPointPosition(s, t), i.lineTo(n.x, n.y)
    }
  }
  l($s, "id", "logarithmic"), l($s, "defaults", {
    ticks: {
      callback: lt.formatters.logarithmic,
      major: {
        enabled: !0
      }
    }
  });
  class ro extends Bs {
    constructor(e) {
      super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
    }
    setDimensions() {
      const e = this._padding = Dt(Ys(this.options) / 2),
        t = this.width = this.maxWidth - e.width,
        n = this.height = this.maxHeight - e.height;
      this.xCenter = Math.floor(this.left + t / 2 + e.left), this.yCenter = Math.floor(this.top + n / 2 + e.top), this.drawingArea = Math.floor(Math.min(t, n) / 2)
    }
    determineDataLimits() {
      const {
        min: e,
        max: t
      } = this.getMinMax(!1);
      this.min = J(e) && !isNaN(e) ? e : 0, this.max = J(t) && !isNaN(t) ? t : 0, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / Ys(this.options))
    }
    generateTickLabels(e) {
      Bs.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((e, t) => {
        const n = Z(this.options.pointLabels.callback, [e, t], this);
        return n || 0 === n ? n : ""
      }).filter((e, t) => this.chart.getDataVisibility(t))
    }
    fit() {
      const e = this.options;
      e.display && e.pointLabels.display ? Qs(this) : this.setCenterPoint(0, 0, 0, 0)
    }
    setCenterPoint(e, t, n, r) {
      this.xCenter += Math.floor((e - t) / 2), this.yCenter += Math.floor((n - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, t, n, r))
    }
    getIndexAngle(e) {
      return je(e * (ge / (this._pointLabels.length || 1)) + Oe(this.options.startAngle || 0))
    }
    getDistanceFromCenterForValue(e) {
      if (K(e)) return NaN;
      const t = this.drawingArea / (this.max - this.min);
      return this.options.reverse ? (this.max - e) * t : (e - this.min) * t
    }
    getValueForDistanceFromCenter(e) {
      if (K(e)) return NaN;
      const t = e / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - t : this.min + t
    }
    getPointLabelContext(e) {
      const t = this._pointLabels || [];
      if (e >= 0 && e < t.length) {
        const n = t[e];
        return function(e, t, n) {
          return Bt(e, {
            label: n,
            index: t,
            type: "pointLabel"
          })
        }(this.getContext(), e, n)
      }
    }
    getPointPosition(e, t) {
      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      const r = this.getIndexAngle(e) - be + n;
      return {
        x: Math.cos(r) * t + this.xCenter,
        y: Math.sin(r) * t + this.yCenter,
        angle: r
      }
    }
    getPointPositionForValue(e, t) {
      return this.getPointPosition(e, this.getDistanceFromCenterForValue(t))
    }
    getBasePosition(e) {
      return this.getPointPositionForValue(e || 0, this.getBaseValue())
    }
    getPointLabelPosition(e) {
      const {
        left: t,
        top: n,
        right: r,
        bottom: i
      } = this._pointLabelItems[e];
      return {
        left: t,
        top: n,
        right: r,
        bottom: i
      }
    }
    drawBackground() {
      const {
        backgroundColor: e,
        grid: {
          circular: t
        }
      } = this.options;
      if (e) {
        const n = this.ctx;
        n.save(), n.beginPath(), no(this, this.getDistanceFromCenterForValue(this._endValue), t, this._pointLabels.length), n.closePath(), n.fillStyle = e, n.fill(), n.restore()
      }
    }
    drawGrid() {
      const e = this.ctx,
        t = this.options,
        {
          angleLines: n,
          grid: r,
          border: i
        } = t,
        s = this._pointLabels.length;
      let o, a, l;
      if (t.pointLabels.display && function(e, t) {
          const {
            ctx: n,
            options: {
              pointLabels: r
            }
          } = e;
          for (let i = t - 1; i >= 0; i--) {
            const t = e._pointLabelItems[i];
            if (!t.visible) continue;
            const s = r.setContext(e.getPointLabelContext(i));
            to(n, s, t);
            const o = zt(s.font),
              {
                x: a,
                y: l,
                textAlign: c
              } = t;
            Ot(n, e._pointLabels[i], a, l + o.lineHeight / 2, o, {
              color: s.color,
              textAlign: c,
              textBaseline: "middle"
            })
          }
        }(this, s), r.display && this.ticks.forEach((e, t) => {
          if (0 !== t || 0 === t && this.min < 0) {
            a = this.getDistanceFromCenterForValue(e.value);
            const n = this.getContext(t),
              o = r.setContext(n),
              l = i.setContext(n);
            ! function(e, t, n, r, i) {
              const s = e.ctx,
                o = t.circular,
                {
                  color: a,
                  lineWidth: l
                } = t;
              !o && !r || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(i.dash || []), s.lineDashOffset = i.dashOffset, s.beginPath(), no(e, n, o, r), s.closePath(), s.stroke(), s.restore())
            }(this, o, a, s, l)
          }
        }), n.display) {
        for (e.save(), o = s - 1; o >= 0; o--) {
          const r = n.setContext(this.getPointLabelContext(o)),
            {
              color: i,
              lineWidth: s
            } = r;
          s && i && (e.lineWidth = s, e.strokeStyle = i, e.setLineDash(r.borderDash), e.lineDashOffset = r.borderDashOffset, a = this.getDistanceFromCenterForValue(t.reverse ? this.min : this.max), l = this.getPointPosition(o, a), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(l.x, l.y), e.stroke())
        }
        e.restore()
      }
    }
    drawBorder() {}
    drawLabels() {
      const e = this.ctx,
        t = this.options,
        n = t.ticks;
      if (!n.display) return;
      const r = this.getIndexAngle(0);
      let i, s;
      e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((r, o) => {
        if (0 === o && this.min >= 0 && !t.reverse) return;
        const a = n.setContext(this.getContext(o)),
          l = zt(a.font);
        if (i = this.getDistanceFromCenterForValue(this.ticks[o].value), a.showLabelBackdrop) {
          e.font = l.string, s = e.measureText(r.label).width, e.fillStyle = a.backdropColor;
          const t = Dt(a.backdropPadding);
          e.fillRect(-s / 2 - t.left, -i - l.size / 2 - t.top, s + t.width, l.size + t.height)
        }
        Ot(e, r.label, 0, -i, l, {
          color: a.color,
          strokeColor: a.textStrokeColor,
          strokeWidth: a.textStrokeWidth
        })
      }), e.restore()
    }
    drawTitle() {}
  }
  l(ro, "id", "radialLinear"), l(ro, "defaults", {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
      display: !0,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: !1
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: !0,
      callback: lt.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: {
        size: 10
      },
      callback: e => e,
      padding: 5,
      centerPointLabels: !1
    }
  }), l(ro, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  }), l(ro, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  const io = {
      millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
      },
      second: {
        common: !0,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: !0,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: !0,
        size: 36e5,
        steps: 24
      },
      day: {
        common: !0,
        size: 864e5,
        steps: 30
      },
      week: {
        common: !1,
        size: 6048e5,
        steps: 4
      },
      month: {
        common: !0,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: !0,
        size: 3154e7
      }
    },
    so = Object.keys(io);

  function oo(e, t) {
    return e - t
  }

  function ao(e, t) {
    if (K(t)) return null;
    const n = e._adapter,
      {
        parser: r,
        round: i,
        isoWeekday: s
      } = e._parseOpts;
    let o = t;
    return "function" === typeof r && (o = r(o)), J(o) || (o = "string" === typeof r ? n.parse(o, r) : n.parse(o)), null === o ? null : (i && (o = "week" !== i || !Te(s) && !0 !== s ? n.startOf(o, i) : n.startOf(o, "isoWeek", s)), +o)
  }

  function lo(e, t, n, r) {
    const i = so.length;
    for (let s = so.indexOf(e); s < i - 1; ++s) {
      const e = io[so[s]],
        i = e.steps ? e.steps : Number.MAX_SAFE_INTEGER;
      if (e.common && Math.ceil((n - t) / (i * e.size)) <= r) return so[s]
    }
    return so[i - 1]
  }

  function co(e, t, n) {
    if (n) {
      if (n.length) {
        const {
          lo: r,
          hi: i
        } = ze(n, t);
        e[n[r] >= t ? n[r] : n[i]] = !0
      }
    } else e[t] = !0
  }

  function uo(e, t, n) {
    const r = [],
      i = {},
      s = t.length;
    let o, a;
    for (o = 0; o < s; ++o) a = t[o], i[a] = o, r.push({
      value: a,
      major: !1
    });
    return 0 !== s && n ? function(e, t, n, r) {
      const i = e._adapter,
        s = +i.startOf(t[0].value, r),
        o = t[t.length - 1].value;
      let a, l;
      for (a = s; a <= o; a = +i.add(a, 1, r)) l = n[a], l >= 0 && (t[l].major = !0);
      return t
    }(e, r, i, n) : r
  }
  class ho extends di {
    constructor(e) {
      super(e), this._cache = {
        data: [],
        labels: [],
        all: []
      }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
    }
    init(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const n = e.time || (e.time = {}),
        r = this._adapter = new vr(e.adapters.date);
      r.init(t), oe(n.displayFormats, r.formats()), this._parseOpts = {
        parser: n.parser,
        round: n.round,
        isoWeekday: n.isoWeekday
      }, super.init(e), this._normalized = t.normalized
    }
    parse(e, t) {
      return void 0 === e ? null : ao(this, e)
    }
    beforeLayout() {
      super.beforeLayout(), this._cache = {
        data: [],
        labels: [],
        all: []
      }
    }
    determineDataLimits() {
      const e = this.options,
        t = this._adapter,
        n = e.time.unit || "day";
      let {
        min: r,
        max: i,
        minDefined: s,
        maxDefined: o
      } = this.getUserBounds();

      function a(e) {
        s || isNaN(e.min) || (r = Math.min(r, e.min)), o || isNaN(e.max) || (i = Math.max(i, e.max))
      }
      s && o || (a(this._getLabelBounds()), "ticks" === e.bounds && "labels" === e.ticks.source || a(this.getMinMax(!1))), r = J(r) && !isNaN(r) ? r : +t.startOf(Date.now(), n), i = J(i) && !isNaN(i) ? i : +t.endOf(Date.now(), n) + 1, this.min = Math.min(r, i - 1), this.max = Math.max(r + 1, i)
    }
    _getLabelBounds() {
      const e = this.getLabelTimestamps();
      let t = Number.POSITIVE_INFINITY,
        n = Number.NEGATIVE_INFINITY;
      return e.length && (t = e[0], n = e[e.length - 1]), {
        min: t,
        max: n
      }
    }
    buildTicks() {
      const e = this.options,
        t = e.time,
        n = e.ticks,
        r = "labels" === n.source ? this.getLabelTimestamps() : this._generate();
      "ticks" === e.bounds && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
      const i = this.min,
        s = function(e, t, n) {
          let r = 0,
            i = e.length;
          for (; r < i && e[r] < t;) r++;
          for (; i > r && e[i - 1] > n;) i--;
          return r > 0 || i < e.length ? e.slice(r, i) : e
        }(r, i, this.max);
      return this._unit = t.unit || (n.autoSkip ? lo(t.minUnit, this.min, this.max, this._getLabelCapacity(i)) : function(e, t, n, r, i) {
        for (let s = so.length - 1; s >= so.indexOf(n); s--) {
          const n = so[s];
          if (io[n].common && e._adapter.diff(i, r, n) >= t - 1) return n
        }
        return so[n ? so.indexOf(n) : 0]
      }(this, s.length, t.minUnit, this.min, this.max)), this._majorUnit = n.major.enabled && "year" !== this._unit ? function(e) {
        for (let t = so.indexOf(e) + 1, n = so.length; t < n; ++t)
          if (io[so[t]].common) return so[t]
      }(this._unit) : void 0, this.initOffsets(r), e.reverse && s.reverse(), uo(this, s, this._majorUnit)
    }
    afterAutoSkip() {
      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value))
    }
    initOffsets() {
      let e, t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
        r = 0,
        i = 0;
      this.options.offset && n.length && (e = this.getDecimalForValue(n[0]), r = 1 === n.length ? 1 - e : (this.getDecimalForValue(n[1]) - e) / 2, t = this.getDecimalForValue(n[n.length - 1]), i = 1 === n.length ? t : (t - this.getDecimalForValue(n[n.length - 2])) / 2);
      const s = n.length < 3 ? .5 : .25;
      r = Ie(r, 0, s), i = Ie(i, 0, s), this._offsets = {
        start: r,
        end: i,
        factor: 1 / (r + 1 + i)
      }
    }
    _generate() {
      const e = this._adapter,
        t = this.min,
        n = this.max,
        r = this.options,
        i = r.time,
        s = i.unit || lo(i.minUnit, t, n, this._getLabelCapacity(t)),
        o = Q(r.ticks.stepSize, 1),
        a = "week" === s && i.isoWeekday,
        l = Te(a) || !0 === a,
        c = {};
      let u, h, d = t;
      if (l && (d = +e.startOf(d, "isoWeek", a)), d = +e.startOf(d, l ? "day" : s), e.diff(n, t, s) > 1e5 * o) throw new Error(t + " and " + n + " are too far apart with stepSize of " + o + " " + s);
      const f = "data" === r.ticks.source && this.getDataTimestamps();
      for (u = d, h = 0; u < n; u = +e.add(u, o, s), h++) co(c, u, f);
      return u !== n && "ticks" !== r.bounds && 1 !== h || co(c, u, f), Object.keys(c).sort(oo).map(e => +e)
    }
    getLabelForValue(e) {
      const t = this._adapter,
        n = this.options.time;
      return n.tooltipFormat ? t.format(e, n.tooltipFormat) : t.format(e, n.displayFormats.datetime)
    }
    format(e, t) {
      const n = this.options.time.displayFormats,
        r = this._unit,
        i = t || n[r];
      return this._adapter.format(e, i)
    }
    _tickFormatFunction(e, t, n, r) {
      const i = this.options,
        s = i.ticks.callback;
      if (s) return Z(s, [e, t, n], this);
      const o = i.time.displayFormats,
        a = this._unit,
        l = this._majorUnit,
        c = a && o[a],
        u = l && o[l],
        h = n[t],
        d = l && u && h && h.major;
      return this._adapter.format(e, r || (d ? u : c))
    }
    generateTickLabels(e) {
      let t, n, r;
      for (t = 0, n = e.length; t < n; ++t) r = e[t], r.label = this._tickFormatFunction(r.value, t, e)
    }
    getDecimalForValue(e) {
      return null === e ? NaN : (e - this.min) / (this.max - this.min)
    }
    getPixelForValue(e) {
      const t = this._offsets,
        n = this.getDecimalForValue(e);
      return this.getPixelForDecimal((t.start + n) * t.factor)
    }
    getValueForPixel(e) {
      const t = this._offsets,
        n = this.getDecimalForPixel(e) / t.factor - t.end;
      return this.min + n * (this.max - this.min)
    }
    _getLabelSize(e) {
      const t = this.options.ticks,
        n = this.ctx.measureText(e).width,
        r = Oe(this.isHorizontal() ? t.maxRotation : t.minRotation),
        i = Math.cos(r),
        s = Math.sin(r),
        o = this._resolveTickFontOptions(0).size;
      return {
        w: n * i + o * s,
        h: n * s + o * i
      }
    }
    _getLabelCapacity(e) {
      const t = this.options.time,
        n = t.displayFormats,
        r = n[t.unit] || n.millisecond,
        i = this._tickFormatFunction(e, 0, uo(this, [e], this._majorUnit), r),
        s = this._getLabelSize(i),
        o = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
      return o > 0 ? o : 1
    }
    getDataTimestamps() {
      let e, t, n = this._cache.data || [];
      if (n.length) return n;
      const r = this.getMatchingVisibleMetas();
      if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this);
      for (e = 0, t = r.length; e < t; ++e) n = n.concat(r[e].controller.getAllParsedValues(this));
      return this._cache.data = this.normalize(n)
    }
    getLabelTimestamps() {
      const e = this._cache.labels || [];
      let t, n;
      if (e.length) return e;
      const r = this.getLabels();
      for (t = 0, n = r.length; t < n; ++t) e.push(ao(this, r[t]));
      return this._cache.labels = this._normalized ? e : this.normalize(e)
    }
    normalize(e) {
      return He(e.sort(oo))
    }
  }

  function fo(e, t, n) {
    let r, i, s, o, a = 0,
      l = e.length - 1;
    n ? (t >= e[a].pos && t <= e[l].pos && ({
      lo: a,
      hi: l
    } = Fe(e, "pos", t)), ({
      pos: r,
      time: s
    } = e[a]), ({
      pos: i,
      time: o
    } = e[l])) : (t >= e[a].time && t <= e[l].time && ({
      lo: a,
      hi: l
    } = Fe(e, "time", t)), ({
      time: r,
      pos: s
    } = e[a]), ({
      time: i,
      pos: o
    } = e[l]));
    const c = i - r;
    return c ? s + (o - s) * (t - r) / c : s
  }
  l(ho, "id", "time"), l(ho, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  });
  class po extends ho {
    constructor(e) {
      super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0
    }
    initOffsets() {
      const e = this._getTimestampsForTable(),
        t = this._table = this.buildLookupTable(e);
      this._minPos = fo(t, this.min), this._tableRange = fo(t, this.max) - this._minPos, super.initOffsets(e)
    }
    buildLookupTable(e) {
      const {
        min: t,
        max: n
      } = this, r = [], i = [];
      let s, o, a, l, c;
      for (s = 0, o = e.length; s < o; ++s) l = e[s], l >= t && l <= n && r.push(l);
      if (r.length < 2) return [{
        time: t,
        pos: 0
      }, {
        time: n,
        pos: 1
      }];
      for (s = 0, o = r.length; s < o; ++s) c = r[s + 1], a = r[s - 1], l = r[s], Math.round((c + a) / 2) !== l && i.push({
        time: l,
        pos: s / (o - 1)
      });
      return i
    }
    _generate() {
      const e = this.min,
        t = this.max;
      let n = super.getDataTimestamps();
      return n.includes(e) && n.length || n.splice(0, 0, e), n.includes(t) && 1 !== n.length || n.push(t), n.sort((e, t) => e - t)
    }
    _getTimestampsForTable() {
      let e = this._cache.all || [];
      if (e.length) return e;
      const t = this.getDataTimestamps(),
        n = this.getLabelTimestamps();
      return e = t.length && n.length ? this.normalize(t.concat(n)) : t.length ? t : n, e = this._cache.all = e, e
    }
    getDecimalForValue(e) {
      return (fo(this._table, e) - this._minPos) / this._tableRange
    }
    getValueForPixel(e) {
      const t = this._offsets,
        n = this.getDecimalForPixel(e) / t.factor - t.end;
      return fo(this._table, n * this._tableRange + this._minPos, !0)
    }
  }
  l(po, "id", "timeseries"), l(po, "defaults", ho.defaults);

  function go(e, t) {
    if (null == e) return {};
    var n, r, i = function(e, t) {
      if (null == e) return {};
      var n = {};
      for (var r in e)
        if ({}.hasOwnProperty.call(e, r)) {
          if (-1 !== t.indexOf(r)) continue;
          n[r] = e[r]
        } return n
    }(e, t);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(e);
      for (r = 0; r < s.length; r++) n = s[r], -1 === t.indexOf(n) && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
    }
    return i
  }
  const mo = ["height", "width", "redraw", "datasetIdKey", "type", "data", "options", "plugins", "fallbackContent", "updateMode"],
    yo = "label";

  function vo(e, t) {
    "function" === typeof e ? e(t) : e && (e.current = t)
  }

  function bo(e, t) {
    e.labels = t
  }

  function wo(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : yo;
    const r = [];
    e.datasets = t.map(t => {
      const i = e.datasets.find(e => e[n] === t[n]);
      return i && t.data && !r.includes(i) ? (r.push(i), Object.assign(i, t), i) : u({}, t)
    })
  }

  function _o(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yo;
    const n = {
      labels: [],
      datasets: []
    };
    return bo(n, e.labels), wo(n, e.datasets, t), n
  }

  function xo(e, t) {
    const {
      height: n = 150,
      width: r = 300,
      redraw: s = !1,
      datasetIdKey: o,
      type: a,
      data: l,
      options: c,
      plugins: h = [],
      fallbackContent: d,
      updateMode: f
    } = e, p = go(e, mo), g = (0, i.useRef)(null), m = (0, i.useRef)(null), y = () => {
      g.current && (m.current = new Hi(g.current, {
        type: a,
        data: _o(l, o),
        options: c && u({}, c),
        plugins: h
      }), vo(t, m.current))
    }, v = () => {
      vo(t, null), m.current && (m.current.destroy(), m.current = null)
    };
    return (0, i.useEffect)(() => {
      !s && m.current && c && function(e, t) {
        const n = e.options;
        n && t && Object.assign(n, t)
      }(m.current, c)
    }, [s, c]), (0, i.useEffect)(() => {
      !s && m.current && bo(m.current.config.data, l.labels)
    }, [s, l.labels]), (0, i.useEffect)(() => {
      !s && m.current && l.datasets && wo(m.current.config.data, l.datasets, o)
    }, [s, l.datasets]), (0, i.useEffect)(() => {
      m.current && (s ? (v(), setTimeout(y)) : m.current.update(f))
    }, [s, c, l.labels, l.datasets, f]), (0, i.useEffect)(() => {
      m.current && (v(), setTimeout(y))
    }, [a]), (0, i.useEffect)(() => (y(), () => v()), []), i.createElement("canvas", u({
      ref: g,
      role: "img",
      height: n,
      width: r
    }, p), d)
  }
  const ko = (0, i.forwardRef)(xo);

  function So(e, t) {
    return Hi.register(t), (0, i.forwardRef)((t, n) => i.createElement(ko, u(u({}, t), {}, {
      ref: n,
      type: e
    })))
  }
  const Eo = So("line", hr),
    To = ["sri"],
    Co = ["page"],
    Oo = ["page", "matches"],
    Po = ["onClick", "discover", "prefetch", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"],
    Ao = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"],
    Ro = ["discover", "fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
  var Mo = "popstate";

  function Lo() {
    return Bo(function(e, t) {
      let {
        pathname: n,
        search: r,
        hash: i
      } = e.location;
      return Do("", {
        pathname: n,
        search: r,
        hash: i
      }, t.state && t.state.usr || null, t.state && t.state.key || "default")
    }, function(e, t) {
      return "string" === typeof t ? t : zo(t)
    }, null, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
  }

  function jo(e, t) {
    if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t)
  }

  function No(e, t) {
    if (!e) {
      "undefined" !== typeof console && console.warn(t);
      try {
        throw new Error(t)
      } catch (n) {}
    }
  }

  function Io(e, t) {
    return {
      usr: e.state,
      key: e.key,
      idx: t
    }
  }

  function Do(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
      r = arguments.length > 3 ? arguments[3] : void 0;
    return u(u({
      pathname: "string" === typeof e ? e : e.pathname,
      search: "",
      hash: ""
    }, "string" === typeof t ? Fo(t) : t), {}, {
      state: n,
      key: t && t.key || r || Math.random().toString(36).substring(2, 10)
    })
  }

  function zo(e) {
    let {
      pathname: t = "/",
      search: n = "",
      hash: r = ""
    } = e;
    return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t
  }

  function Fo(e) {
    let t = {};
    if (e) {
      let n = e.indexOf("#");
      n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
      let r = e.indexOf("?");
      r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e)
    }
    return t
  }

  function Bo(e, t, n) {
    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
      {
        window: i = document.defaultView,
        v5Compat: s = !1
      } = r,
      o = i.history,
      a = "POP",
      l = null,
      c = h();

    function h() {
      return (o.state || {
        idx: null
      }).idx
    }

    function d() {
      a = "POP";
      let e = h(),
        t = null == e ? null : e - c;
      c = e, l && l({
        action: a,
        location: p.location,
        delta: t
      })
    }

    function f(e) {
      return Uo(e)
    }
    null == c && (c = 0, o.replaceState(u(u({}, o.state), {}, {
      idx: c
    }), ""));
    let p = {
      get action() {
        return a
      },
      get location() {
        return e(i, o)
      },
      listen(e) {
        if (l) throw new Error("A history only accepts one active listener");
        return i.addEventListener(Mo, d), l = e, () => {
          i.removeEventListener(Mo, d), l = null
        }
      },
      createHref: e => t(i, e),
      createURL: f,
      encodeLocation(e) {
        let t = f(e);
        return {
          pathname: t.pathname,
          search: t.search,
          hash: t.hash
        }
      },
      push: function(e, t) {
        a = "PUSH";
        let r = Do(p.location, e, t);
        n && n(r, e), c = h() + 1;
        let u = Io(r, c),
          d = p.createHref(r);
        try {
          o.pushState(u, "", d)
        } catch (f) {
          if (f instanceof DOMException && "DataCloneError" === f.name) throw f;
          i.location.assign(d)
        }
        s && l && l({
          action: a,
          location: p.location,
          delta: 1
        })
      },
      replace: function(e, t) {
        a = "REPLACE";
        let r = Do(p.location, e, t);
        n && n(r, e), c = h();
        let i = Io(r, c),
          u = p.createHref(r);
        o.replaceState(i, "", u), s && l && l({
          action: a,
          location: p.location,
          delta: 0
        })
      },
      go: e => o.go(e)
    };
    return p
  }

  function Uo(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
      n = "http://localhost";
    "undefined" !== typeof window && (n = "null" !== window.location.origin ? window.location.origin : window.location.href), jo(n, "No window.location.(origin|href) available to create URL");
    let r = "string" === typeof e ? e : zo(e);
    return r = r.replace(/ $/, "%20"), !t && r.startsWith("//") && (r = n + r), new URL(r, n)
  }
  new WeakMap;

  function Wo(e, t) {
    return Ho(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "/", !1)
  }

  function Ho(e, t, n, r) {
    let i = ia(("string" === typeof t ? Fo(t) : t).pathname || "/", n);
    if (null == i) return null;
    let s = Vo(e);
    ! function(e) {
      e.sort((e, t) => e.score !== t.score ? t.score - e.score : function(e, t) {
        let n = e.length === t.length && e.slice(0, -1).every((e, n) => e === t[n]);
        return n ? e[e.length - 1] - t[t.length - 1] : 0
      }(e.routesMeta.map(e => e.childrenIndex), t.routesMeta.map(e => e.childrenIndex)))
    }(s);
    let o = null;
    for (let a = 0; null == o && a < s.length; ++a) {
      let e = ra(i);
      o = ea(s[a], e, r)
    }
    return o
  }

  function Vo(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
      r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "",
      i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
      s = function(e, s) {
        let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i,
          a = arguments.length > 3 ? arguments[3] : void 0,
          l = {
            relativePath: void 0 === a ? e.path || "" : a,
            caseSensitive: !0 === e.caseSensitive,
            childrenIndex: s,
            route: e
          };
        if (l.relativePath.startsWith("/")) {
          if (!l.relativePath.startsWith(r) && o) return;
          jo(l.relativePath.startsWith(r), 'Absolute route path "'.concat(l.relativePath, '" nested under path "').concat(r, '" is not valid. An absolute child route path must start with the combined path of all its parent routes.')), l.relativePath = l.relativePath.slice(r.length)
        }
        let c = ca([r, l.relativePath]),
          u = n.concat(l);
        e.children && e.children.length > 0 && (jo(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "'.concat(c, '".')), Vo(e.children, t, u, c, o)), (null != e.path || e.index) && t.push({
          path: c,
          score: Zo(c, e.index),
          routesMeta: u
        })
      };
    return e.forEach((e, t) => {
      var n;
      if ("" !== e.path && null !== (n = e.path) && void 0 !== n && n.includes("?"))
        for (let r of qo(e.path)) s(e, t, !0, r);
      else s(e, t)
    }), t
  }

  function qo(e) {
    let t = e.split("/");
    if (0 === t.length) return [];
    let [n, ...r] = t, i = n.endsWith("?"), s = n.replace(/\?$/, "");
    if (0 === r.length) return i ? [s, ""] : [s];
    let o = qo(r.join("/")),
      a = [];
    return a.push(...o.map(e => "" === e ? s : [s, e].join("/"))), i && a.push(...o), a.map(t => e.startsWith("/") && "" === t ? "/" : t)
  }
  var Ko = /^:[\w-]+$/,
    $o = 3,
    Yo = 2,
    Jo = 1,
    Go = 10,
    Qo = -2,
    Xo = e => "*" === e;

  function Zo(e, t) {
    let n = e.split("/"),
      r = n.length;
    return n.some(Xo) && (r += Qo), t && (r += Yo), n.filter(e => !Xo(e)).reduce((e, t) => e + (Ko.test(t) ? $o : "" === t ? Jo : Go), r)
  }

  function ea(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
      {
        routesMeta: r
      } = e,
      i = {},
      s = "/",
      o = [];
    for (let a = 0; a < r.length; ++a) {
      let e = r[a],
        l = a === r.length - 1,
        c = "/" === s ? t : t.slice(s.length) || "/",
        u = ta({
          path: e.relativePath,
          caseSensitive: e.caseSensitive,
          end: l
        }, c),
        h = e.route;
      if (!u && l && n && !r[r.length - 1].route.index && (u = ta({
          path: e.relativePath,
          caseSensitive: e.caseSensitive,
          end: !1
        }, c)), !u) return null;
      Object.assign(i, u.params), o.push({
        params: i,
        pathname: ca([s, u.pathname]),
        pathnameBase: ua(ca([s, u.pathnameBase])),
        route: h
      }), "/" !== u.pathnameBase && (s = ca([s, u.pathnameBase]))
    }
    return o
  }

  function ta(e, t) {
    "string" === typeof e && (e = {
      path: e,
      caseSensitive: !1,
      end: !0
    });
    let [n, r] = na(e.path, e.caseSensitive, e.end), i = t.match(n);
    if (!i) return null;
    let s = i[0],
      o = s.replace(/(.)\/+$/, "$1"),
      a = i.slice(1),
      l = r.reduce((e, t, n) => {
        let {
          paramName: r,
          isOptional: i
        } = t;
        if ("*" === r) {
          let e = a[n] || "";
          o = s.slice(0, s.length - e.length).replace(/(.)\/+$/, "$1")
        }
        const l = a[n];
        return e[r] = i && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e
      }, {});
    return {
      params: l,
      pathname: s,
      pathnameBase: o,
      pattern: e
    }
  }

  function na(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
      n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    No("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "'.concat(e, '" will be treated as if it were "').concat(e.replace(/\*$/, "/*"), '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "').concat(e.replace(/\*$/, "/*"), '".'));
    let r = [],
      i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (e, t, n) => (r.push({
        paramName: t,
        isOptional: null != n
      }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return e.endsWith("*") ? (r.push({
      paramName: "*"
    }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r]
  }

  function ra(e) {
    try {
      return e.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (t) {
      return No(!1, 'The URL path "'.concat(e, '" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (').concat(t, ").")), e
    }
  }

  function ia(e, t) {
    if ("/" === t) return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
    let n = t.endsWith("/") ? t.length - 1 : t.length,
      r = e.charAt(n);
    return r && "/" !== r ? null : e.slice(n) || "/"
  }

  function sa(e, t, n, r) {
    return "Cannot include a '".concat(e, "' character in a manually specified `to.").concat(t, "` field [").concat(JSON.stringify(r), "].  Please separate it out to the `to.").concat(n, '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.')
  }

  function oa(e) {
    return e.filter((e, t) => 0 === t || e.route.path && e.route.path.length > 0)
  }

  function aa(e) {
    let t = oa(e);
    return t.map((e, n) => n === t.length - 1 ? e.pathname : e.pathnameBase)
  }

  function la(e, t, n) {
    let r, i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    "string" === typeof e ? r = Fo(e) : (r = u({}, e), jo(!r.pathname || !r.pathname.includes("?"), sa("?", "pathname", "search", r)), jo(!r.pathname || !r.pathname.includes("#"), sa("#", "pathname", "hash", r)), jo(!r.search || !r.search.includes("#"), sa("#", "search", "hash", r)));
    let s, o = "" === e || "" === r.pathname,
      a = o ? "/" : r.pathname;
    if (null == a) s = n;
    else {
      let e = t.length - 1;
      if (!i && a.startsWith("..")) {
        let t = a.split("/");
        for (;
          ".." === t[0];) t.shift(), e -= 1;
        r.pathname = t.join("/")
      }
      s = e >= 0 ? t[e] : "/"
    }
    let l = function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/",
          {
            pathname: n,
            search: r = "",
            hash: i = ""
          } = "string" === typeof e ? Fo(e) : e,
          s = n ? n.startsWith("/") ? n : function(e, t) {
            let n = t.replace(/\/+$/, "").split("/");
            return e.split("/").forEach(e => {
              ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e)
            }), n.length > 1 ? n.join("/") : "/"
          }(n, t) : t;
        return {
          pathname: s,
          search: ha(r),
          hash: da(i)
        }
      }(r, s),
      c = a && "/" !== a && a.endsWith("/"),
      h = (o || "." === a) && n.endsWith("/");
    return l.pathname.endsWith("/") || !c && !h || (l.pathname += "/"), l
  }
  var ca = e => e.join("/").replace(/\/\/+/g, "/"),
    ua = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
    ha = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "",
    da = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : "";

  function fa(e) {
    return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e
  }
  var pa = ["POST", "PUT", "PATCH", "DELETE"],
    ga = (new Set(pa), ["GET", ...pa]);
  new Set(ga), Symbol("ResetLoaderData");
  var ma = i.createContext(null);
  ma.displayName = "DataRouter";
  var ya = i.createContext(null);
  ya.displayName = "DataRouterState";
  var va = i.createContext(!1);
  var ba = i.createContext({
    isTransitioning: !1
  });
  ba.displayName = "ViewTransition";
  var wa = i.createContext(new Map);
  wa.displayName = "Fetchers";
  var _a = i.createContext(null);
  _a.displayName = "Await";
  var xa = i.createContext(null);
  xa.displayName = "Navigation";
  var ka = i.createContext(null);
  ka.displayName = "Location";
  var Sa = i.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
  });
  Sa.displayName = "Route";
  var Ea = i.createContext(null);
  Ea.displayName = "RouteError";

  function Ta() {
    return null != i.useContext(ka)
  }

  function Ca() {
    return jo(Ta(), "useLocation() may be used only in the context of a <Router> component."), i.useContext(ka).location
  }
  var Oa = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";

  function Pa(e) {
    i.useContext(xa).static || i.useLayoutEffect(e)
  }

  function Aa() {
    let {
      isDataRoute: e
    } = i.useContext(Sa);
    return e ? function() {
      let {
        router: e
      } = Fa("useNavigate"), t = Ua("useNavigate"), n = i.useRef(!1);
      Pa(() => {
        n.current = !0
      });
      let r = i.useCallback(async function(r) {
        let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        No(n.current, Oa), n.current && ("number" === typeof r ? e.navigate(r) : await e.navigate(r, u({
          fromRouteId: t
        }, i)))
      }, [e, t]);
      return r
    }() : function() {
      jo(Ta(), "useNavigate() may be used only in the context of a <Router> component.");
      let e = i.useContext(ma),
        {
          basename: t,
          navigator: n
        } = i.useContext(xa),
        {
          matches: r
        } = i.useContext(Sa),
        {
          pathname: s
        } = Ca(),
        o = JSON.stringify(aa(r)),
        a = i.useRef(!1);
      Pa(() => {
        a.current = !0
      });
      let l = i.useCallback(function(r) {
        let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (No(a.current, Oa), !a.current) return;
        if ("number" === typeof r) return void n.go(r);
        let l = la(r, JSON.parse(o), s, "path" === i.relative);
        null == e && "/" !== t && (l.pathname = "/" === l.pathname ? t : ca([t, l.pathname])), (i.replace ? n.replace : n.push)(l, i.state, i)
      }, [t, n, o, s, e]);
      return l
    }()
  }
  i.createContext(null);

  function Ra(e) {
    let {
      relative: t
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {
      matches: n
    } = i.useContext(Sa), {
      pathname: r
    } = Ca(), s = JSON.stringify(aa(n));
    return i.useMemo(() => la(e, JSON.parse(s), r, "path" === t), [e, s, r, t])
  }

  function Ma(e, t, n, r, s) {
    jo(Ta(), "useRoutes() may be used only in the context of a <Router> component.");
    let {
      navigator: o
    } = i.useContext(xa), {
      matches: a
    } = i.useContext(Sa), l = a[a.length - 1], c = l ? l.params : {}, h = l ? l.pathname : "/", d = l ? l.pathnameBase : "/", f = l && l.route;
    {
      let e = f && f.path || "";
      Va(h, !f || e.endsWith("*") || e.endsWith("*?"), 'You rendered descendant <Routes> (or called `useRoutes()`) at "'.concat(h, '" (under <Route path="').concat(e, '">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="').concat(e, '"> to <Route path="').concat("/" === e ? "*" : "".concat(e, "/*"), '">.'))
    }
    let p, g = Ca();
    if (t) {
      var m;
      let e = "string" === typeof t ? Fo(t) : t;
      jo("/" === d || (null === (m = e.pathname) || void 0 === m ? void 0 : m.startsWith(d)), 'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'.concat(d, '" but pathname "').concat(e.pathname, '" was given in the `location` prop.')), p = e
    } else p = g;
    let y = p.pathname || "/",
      v = y;
    if ("/" !== d) {
      let e = d.replace(/^\//, "").split("/");
      v = "/" + y.replace(/^\//, "").split("/").slice(e.length).join("/")
    }
    let b = Wo(e, {
      pathname: v
    });
    No(f || null != b, 'No routes matched location "'.concat(p.pathname).concat(p.search).concat(p.hash, '" ')), No(null == b || void 0 !== b[b.length - 1].route.element || void 0 !== b[b.length - 1].route.Component || void 0 !== b[b.length - 1].route.lazy, 'Matched leaf route at location "'.concat(p.pathname).concat(p.search).concat(p.hash, '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
    let w = Da(b && b.map(e => Object.assign({}, e, {
      params: Object.assign({}, c, e.params),
      pathname: ca([d, o.encodeLocation ? o.encodeLocation(e.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : e.pathname]),
      pathnameBase: "/" === e.pathnameBase ? d : ca([d, o.encodeLocation ? o.encodeLocation(e.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : e.pathnameBase])
    })), a, n, r, s);
    return t && w ? i.createElement(ka.Provider, {
      value: {
        location: u({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, p),
        navigationType: "POP"
      }
    }, w) : w
  }

  function La() {
    let e = Wa(),
      t = fa(e) ? "".concat(e.status, " ").concat(e.statusText) : e instanceof Error ? e.message : JSON.stringify(e),
      n = e instanceof Error ? e.stack : null,
      r = "rgba(200,200,200, 0.5)",
      s = {
        padding: "0.5rem",
        backgroundColor: r
      },
      o = {
        padding: "2px 4px",
        backgroundColor: r
      },
      a = null;
    return console.error("Error handled by React Router default ErrorBoundary:", e), a = i.createElement(i.Fragment, null, i.createElement("p", null, "\ud83d\udcbf Hey developer \ud83d\udc4b"), i.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", i.createElement("code", {
      style: o
    }, "ErrorBoundary"), " or", " ", i.createElement("code", {
      style: o
    }, "errorElement"), " prop on your route.")), i.createElement(i.Fragment, null, i.createElement("h2", null, "Unexpected Application Error!"), i.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, t), n ? i.createElement("pre", {
      style: s
    }, n) : null, a)
  }
  var ja = i.createElement(La, null),
    Na = class extends i.Component {
      constructor(e) {
        super(e), this.state = {
          location: e.location,
          revalidation: e.revalidation,
          error: e.error
        }
      }
      static getDerivedStateFromError(e) {
        return {
          error: e
        }
      }
      static getDerivedStateFromProps(e, t) {
        return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? {
          error: e.error,
          location: e.location,
          revalidation: e.revalidation
        } : {
          error: void 0 !== e.error ? e.error : t.error,
          location: t.location,
          revalidation: e.revalidation || t.revalidation
        }
      }
      componentDidCatch(e, t) {
        this.props.unstable_onError ? this.props.unstable_onError(e, t) : console.error("React Router caught the following error during render", e)
      }
      render() {
        return void 0 !== this.state.error ? i.createElement(Sa.Provider, {
          value: this.props.routeContext
        }, i.createElement(Ea.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children
      }
    };

  function Ia(e) {
    let {
      routeContext: t,
      match: n,
      children: r
    } = e, s = i.useContext(ma);
    return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), i.createElement(Sa.Provider, {
      value: t
    }, r)
  }

  function Da(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
      r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    if (null == e) {
      if (!n) return null;
      if (n.errors) e = n.matches;
      else {
        if (0 !== t.length || n.initialized || !(n.matches.length > 0)) return null;
        e = n.matches
      }
    }
    let s = e,
      o = null === n || void 0 === n ? void 0 : n.errors;
    if (null != o) {
      let e = s.findIndex(e => e.route.id && void 0 !== (null === o || void 0 === o ? void 0 : o[e.route.id]));
      jo(e >= 0, "Could not find a matching route for errors on route IDs: ".concat(Object.keys(o).join(","))), s = s.slice(0, Math.min(s.length, e + 1))
    }
    let a = !1,
      l = -1;
    if (n)
      for (let i = 0; i < s.length; i++) {
        let e = s[i];
        if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (l = i), e.route.id) {
          let {
            loaderData: t,
            errors: r
          } = n, i = e.route.loader && !t.hasOwnProperty(e.route.id) && (!r || void 0 === r[e.route.id]);
          if (e.route.lazy || i) {
            a = !0, s = l >= 0 ? s.slice(0, l + 1) : [s[0]];
            break
          }
        }
      }
    return s.reduceRight((e, c, u) => {
      let h, d = !1,
        f = null,
        p = null;
      n && (h = o && c.route.id ? o[c.route.id] : void 0, f = c.route.errorElement || ja, a && (l < 0 && 0 === u ? (Va("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), d = !0, p = null) : l === u && (d = !0, p = c.route.hydrateFallbackElement || null)));
      let g = t.concat(s.slice(0, u + 1)),
        m = () => {
          let t;
          return t = h ? f : d ? p : c.route.Component ? i.createElement(c.route.Component, null) : c.route.element ? c.route.element : e, i.createElement(Ia, {
            match: c,
            routeContext: {
              outlet: e,
              matches: g,
              isDataRoute: null != n
            },
            children: t
          })
        };
      return n && (c.route.ErrorBoundary || c.route.errorElement || 0 === u) ? i.createElement(Na, {
        location: n.location,
        revalidation: n.revalidation,
        component: f,
        error: h,
        children: m(),
        routeContext: {
          outlet: null,
          matches: g,
          isDataRoute: !0
        },
        unstable_onError: r
      }) : m()
    }, null)
  }

  function za(e) {
    return "".concat(e, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")
  }

  function Fa(e) {
    let t = i.useContext(ma);
    return jo(t, za(e)), t
  }

  function Ba(e) {
    let t = i.useContext(ya);
    return jo(t, za(e)), t
  }

  function Ua(e) {
    let t = function(e) {
        let t = i.useContext(Sa);
        return jo(t, za(e)), t
      }(e),
      n = t.matches[t.matches.length - 1];
    return jo(n.route.id, "".concat(e, ' can only be used on routes that contain a unique "id"')), n.route.id
  }

  function Wa() {
    var e;
    let t = i.useContext(Ea),
      n = Ba("useRouteError"),
      r = Ua("useRouteError");
    return void 0 !== t ? t : null === (e = n.errors) || void 0 === e ? void 0 : e[r]
  }
  var Ha = {};

  function Va(e, t, n) {
    t || Ha[e] || (Ha[e] = !0, No(!1, n))
  }
  var qa = {};

  function Ka(e, t) {
    e || qa[t] || (qa[t] = !0, console.warn(t))
  }
  i.memo(function(e) {
    let {
      routes: t,
      future: n,
      state: r,
      unstable_onError: i
    } = e;
    return Ma(t, void 0, r, i, n)
  });

  function $a(e) {
    jo(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
  }

  function Ya(e) {
    let {
      basename: t = "/",
      children: n = null,
      location: r,
      navigationType: s = "POP",
      navigator: o,
      static: a = !1
    } = e;
    jo(!Ta(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let l = t.replace(/^\/*/, "/"),
      c = i.useMemo(() => ({
        basename: l,
        navigator: o,
        static: a,
        future: {}
      }), [l, o, a]);
    "string" === typeof r && (r = Fo(r));
    let {
      pathname: u = "/",
      search: h = "",
      hash: d = "",
      state: f = null,
      key: p = "default"
    } = r, g = i.useMemo(() => {
      let e = ia(u, l);
      return null == e ? null : {
        location: {
          pathname: e,
          search: h,
          hash: d,
          state: f,
          key: p
        },
        navigationType: s
      }
    }, [l, u, h, d, f, p, s]);
    return No(null != g, '<Router basename="'.concat(l, '"> is not able to match the URL "').concat(u).concat(h).concat(d, "\" because it does not start with the basename, so the <Router> won't render anything.")), null == g ? null : i.createElement(xa.Provider, {
      value: c
    }, i.createElement(ka.Provider, {
      children: n,
      value: g
    }))
  }

  function Ja(e) {
    let {
      children: t,
      location: n
    } = e;
    return Ma(Ga(t), n)
  }
  i.Component;

  function Ga(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
      n = [];
    return i.Children.forEach(e, (e, r) => {
      if (!i.isValidElement(e)) return;
      let s = [...t, r];
      if (e.type === i.Fragment) return void n.push.apply(n, Ga(e.props.children, s));
      jo(e.type === $a, "[".concat("string" === typeof e.type ? e.type : e.type.name, "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>")), jo(!e.props.index || !e.props.children, "An index route cannot have child routes.");
      let o = {
        id: e.props.id || s.join("-"),
        caseSensitive: e.props.caseSensitive,
        element: e.props.element,
        Component: e.props.Component,
        index: e.props.index,
        path: e.props.path,
        middleware: e.props.middleware,
        loader: e.props.loader,
        action: e.props.action,
        hydrateFallbackElement: e.props.hydrateFallbackElement,
        HydrateFallback: e.props.HydrateFallback,
        errorElement: e.props.errorElement,
        ErrorBoundary: e.props.ErrorBoundary,
        hasErrorBoundary: !0 === e.props.hasErrorBoundary || null != e.props.ErrorBoundary || null != e.props.errorElement,
        shouldRevalidate: e.props.shouldRevalidate,
        handle: e.props.handle,
        lazy: e.props.lazy
      };
      e.props.children && (o.children = Ga(e.props.children, s)), n.push(o)
    }), n
  }
  var Qa = "get",
    Xa = "application/x-www-form-urlencoded";

  function Za(e) {
    return null != e && "string" === typeof e.tagName
  }
  var el = null;
  var tl = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);

  function nl(e) {
    return null == e || tl.has(e) ? e : (No(!1, '"'.concat(e, '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` and will default to "').concat(Xa, '"')), null)
  }

  function rl(e, t) {
    let n, r, i, s, o;
    if (Za(a = e) && "form" === a.tagName.toLowerCase()) {
      let o = e.getAttribute("action");
      r = o ? ia(o, t) : null, n = e.getAttribute("method") || Qa, i = nl(e.getAttribute("enctype")) || Xa, s = new FormData(e)
    } else if (function(e) {
        return Za(e) && "button" === e.tagName.toLowerCase()
      }(e) || function(e) {
        return Za(e) && "input" === e.tagName.toLowerCase()
      }(e) && ("submit" === e.type || "image" === e.type)) {
      let o = e.form;
      if (null == o) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
      let a = e.getAttribute("formaction") || o.getAttribute("action");
      if (r = a ? ia(a, t) : null, n = e.getAttribute("formmethod") || o.getAttribute("method") || Qa, i = nl(e.getAttribute("formenctype")) || nl(o.getAttribute("enctype")) || Xa, s = new FormData(o, e), ! function() {
          if (null === el) try {
            new FormData(document.createElement("form"), 0), el = !1
          } catch (e) {
            el = !0
          }
          return el
        }()) {
        let {
          name: t,
          type: n,
          value: r
        } = e;
        if ("image" === n) {
          let e = t ? "".concat(t, ".") : "";
          s.append("".concat(e, "x"), "0"), s.append("".concat(e, "y"), "0")
        } else t && s.append(t, r)
      }
    } else {
      if (Za(e)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
      n = Qa, r = null, i = Xa, o = e
    }
    var a;
    return s && "text/plain" === i && (o = s, s = void 0), {
      action: r,
      method: n.toLowerCase(),
      encType: i,
      formData: s,
      body: o
    }
  }
  Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
  "undefined" !== typeof window ? window : "undefined" !== typeof globalThis && globalThis;

  function il(e, t) {
    if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t)
  }
  Symbol("SingleFetchRedirect");

  function sl(e, t, n) {
    let r = "string" === typeof e ? new URL(e, "undefined" === typeof window ? "server://singlefetch/" : window.location.origin) : e;
    return "/" === r.pathname ? r.pathname = "_root.".concat(n) : t && "/" === ia(r.pathname, t) ? r.pathname = "".concat(t.replace(/\/$/, ""), "/_root.").concat(n) : r.pathname = "".concat(r.pathname.replace(/\/$/, ""), ".").concat(n), r
  }
  async function ol(e, t) {
    if (e.id in t) return t[e.id];
    try {
      let n = await import(e.module);
      return t[e.id] = n, n
    } catch (n) {
      return console.error("Error loading route module `".concat(e.module, "`, reloading page...")), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {})
    }
  }

  function al(e) {
    return null != e && "string" === typeof e.page
  }

  function ll(e) {
    return null != e && (null == e.href ? "preload" === e.rel && "string" === typeof e.imageSrcSet && "string" === typeof e.imageSizes : "string" === typeof e.rel && "string" === typeof e.href)
  }

  function cl(e, t, n, r, i, s) {
    let o = (e, t) => !n[t] || e.route.id !== n[t].route.id,
      a = (e, t) => {
        var r;
        return n[t].pathname !== e.pathname || (null === (r = n[t].route.path) || void 0 === r ? void 0 : r.endsWith("*")) && n[t].params["*"] !== e.params["*"]
      };
    return "assets" === s ? t.filter((e, t) => o(e, t) || a(e, t)) : "data" === s ? t.filter((t, s) => {
      let l = r.routes[t.route.id];
      if (!l || !l.hasLoader) return !1;
      if (o(t, s) || a(t, s)) return !0;
      if (t.route.shouldRevalidate) {
        var c;
        let r = t.route.shouldRevalidate({
          currentUrl: new URL(i.pathname + i.search + i.hash, window.origin),
          currentParams: (null === (c = n[0]) || void 0 === c ? void 0 : c.params) || {},
          nextUrl: new URL(e, window.origin),
          nextParams: t.params,
          defaultShouldRevalidate: !0
        });
        if ("boolean" === typeof r) return r
      }
      return !0
    }) : []
  }

  function ul(e, t) {
    let {
      includeHydrateFallback: n
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return r = e.map(e => {
      let r = t.routes[e.route.id];
      if (!r) return [];
      let i = [r.module];
      return r.clientActionModule && (i = i.concat(r.clientActionModule)), r.clientLoaderModule && (i = i.concat(r.clientLoaderModule)), n && r.hydrateFallbackModule && (i = i.concat(r.hydrateFallbackModule)), r.imports && (i = i.concat(r.imports)), i
    }).flat(1), [...new Set(r)];
    var r
  }

  function hl(e, t) {
    let n = new Set,
      r = new Set(t);
    return e.reduce((e, i) => {
      if (t && !al(i) && "script" === i.as && i.href && r.has(i.href)) return e;
      let s = JSON.stringify(function(e) {
        let t = {},
          n = Object.keys(e).sort();
        for (let r of n) t[r] = e[r];
        return t
      }(i));
      return n.has(s) || (n.add(s), e.push({
        key: s,
        link: i
      })), e
    }, [])
  }

  function dl(e, t) {
    return "lazy" === e.mode && !0 === t
  }

  function fl() {
    let e = i.useContext(ma);
    return il(e, "You must render this element inside a <DataRouterContext.Provider> element"), e
  }

  function pl() {
    let e = i.useContext(ya);
    return il(e, "You must render this element inside a <DataRouterStateContext.Provider> element"), e
  }
  var gl = i.createContext(void 0);

  function ml() {
    let e = i.useContext(gl);
    return il(e, "You must render this element inside a <HydratedRouter> element"), e
  }

  function yl(e, t) {
    return n => {
      e && e(n), n.defaultPrevented || t(n)
    }
  }

  function vl(e, t, n) {
    if (n && !xl) return [e[0]];
    if (t) {
      let n = e.findIndex(e => void 0 !== t[e.route.id]);
      return e.slice(0, n + 1)
    }
    return e
  }
  gl.displayName = "FrameworkContext";

  function bl(e) {
    let {
      page: t
    } = e, n = go(e, Co), {
      router: r
    } = fl(), s = i.useMemo(() => Wo(r.routes, t, r.basename), [r.routes, t, r.basename]);
    return s ? i.createElement(_l, u({
      page: t,
      matches: s
    }, n)) : null
  }

  function wl(e) {
    let {
      manifest: t,
      routeModules: n
    } = ml(), [r, s] = i.useState([]);
    return i.useEffect(() => {
      let r = !1;
      return async function(e, t, n) {
        return hl((await Promise.all(e.map(async e => {
          let r = t.routes[e.route.id];
          if (r) {
            let e = await ol(r, n);
            return e.links ? e.links() : []
          }
          return []
        }))).flat(1).filter(ll).filter(e => "stylesheet" === e.rel || "preload" === e.rel).map(e => "stylesheet" === e.rel ? u(u({}, e), {}, {
          rel: "prefetch",
          as: "style"
        }) : u(u({}, e), {}, {
          rel: "prefetch"
        })))
      }(e, t, n).then(e => {
        r || s(e)
      }), () => {
        r = !0
      }
    }, [e, t, n]), r
  }

  function _l(e) {
    let {
      page: t,
      matches: n
    } = e, r = go(e, Oo), s = Ca(), {
      manifest: o,
      routeModules: a
    } = ml(), {
      basename: l
    } = fl(), {
      loaderData: c,
      matches: h
    } = pl(), d = i.useMemo(() => cl(t, n, h, o, s, "data"), [t, n, h, o, s]), f = i.useMemo(() => cl(t, n, h, o, s, "assets"), [t, n, h, o, s]), p = i.useMemo(() => {
      if (t === s.pathname + s.search + s.hash) return [];
      let e = new Set,
        r = !1;
      if (n.forEach(t => {
          var n;
          let i = o.routes[t.route.id];
          i && i.hasLoader && (!d.some(e => e.route.id === t.route.id) && t.route.id in c && null !== (n = a[t.route.id]) && void 0 !== n && n.shouldRevalidate || i.hasClientLoader ? r = !0 : e.add(t.route.id))
        }), 0 === e.size) return [];
      let i = sl(t, l, "data");
      return r && e.size > 0 && i.searchParams.set("_routes", n.filter(t => e.has(t.route.id)).map(e => e.route.id).join(",")), [i.pathname + i.search]
    }, [l, c, s, o, d, n, t, a]), g = i.useMemo(() => ul(f, o), [f, o]), m = wl(f);
    return i.createElement(i.Fragment, null, p.map(e => i.createElement("link", u({
      key: e,
      rel: "prefetch",
      as: "fetch",
      href: e
    }, r))), g.map(e => i.createElement("link", u({
      key: e,
      rel: "modulepreload",
      href: e
    }, r))), m.map(e => {
      let {
        key: t,
        link: n
      } = e;
      return i.createElement("link", u({
        key: t,
        nonce: r.nonce
      }, n))
    }))
  }
  var xl = !1;

  function kl(e) {
    let {
      manifest: t,
      serverHandoffString: n,
      isSpaMode: r,
      renderMeta: s,
      routeDiscovery: o,
      ssr: a
    } = ml(), {
      router: l,
      static: c,
      staticContext: h
    } = fl(), {
      matches: d
    } = pl(), f = i.useContext(va), p = dl(o, a);
    s && (s.didRenderScripts = !0);
    let g = vl(d, null, r);
    i.useEffect(() => {
      xl = !0
    }, []);
    let m = i.useMemo(() => {
        var r;
        if (f) return null;
        let s = h ? "window.__reactRouterContext = ".concat(n, ";").concat("window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());") : " ",
          o = c ? "".concat(null !== (r = t.hmr) && void 0 !== r && r.runtime ? "import ".concat(JSON.stringify(t.hmr.runtime), ";") : "").concat(p ? "" : "import ".concat(JSON.stringify(t.url)), ";\n").concat(g.map((e, n) => {
            let r = "route".concat(n),
              i = t.routes[e.route.id];
            il(i, "Route ".concat(e.route.id, " not found in manifest"));
            let {
              clientActionModule: s,
              clientLoaderModule: o,
              clientMiddlewareModule: a,
              hydrateFallbackModule: l,
              module: c
            } = i, u = [...s ? [{
              module: s,
              varName: "".concat(r, "_clientAction")
            }] : [], ...o ? [{
              module: o,
              varName: "".concat(r, "_clientLoader")
            }] : [], ...a ? [{
              module: a,
              varName: "".concat(r, "_clientMiddleware")
            }] : [], ...l ? [{
              module: l,
              varName: "".concat(r, "_HydrateFallback")
            }] : [], {
              module: c,
              varName: "".concat(r, "_main")
            }];
            return 1 === u.length ? "import * as ".concat(r, " from ").concat(JSON.stringify(c), ";") : [u.map(e => "import * as ".concat(e.varName, ' from "').concat(e.module, '";')).join("\n"), "const ".concat(r, " = {").concat(u.map(e => "...".concat(e.varName)).join(","), "};")].join("\n")
          }).join("\n"), "\n  ").concat(p ? "window.__reactRouterManifest = ".concat(JSON.stringify(function(e, t) {
            let {
              sri: n
            } = e, r = go(e, To), i = new Set(t.state.matches.map(e => e.route.id)), s = t.state.location.pathname.split("/").filter(Boolean), o = ["/"];
            for (s.pop(); s.length > 0;) o.push("/".concat(s.join("/"))), s.pop();
            o.forEach(e => {
              let n = Wo(t.routes, e, t.basename);
              n && n.forEach(e => i.add(e.route.id))
            });
            let a = [...i].reduce((e, t) => Object.assign(e, {
              [t]: r.routes[t]
            }), {});
            return u(u({}, r), {}, {
              routes: a,
              sri: !!n || void 0
            })
          }(t, l), null, 2), ";") : "", "\n  window.__reactRouterRouteModules = {").concat(g.map((e, t) => "".concat(JSON.stringify(e.route.id), ":route").concat(t)).join(","), "};\n\nimport(").concat(JSON.stringify(t.entry.module), ");") : " ";
        return i.createElement(i.Fragment, null, i.createElement("script", u(u({}, e), {}, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: s
          },
          type: void 0
        })), i.createElement("script", u(u({}, e), {}, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: o
          },
          type: "module",
          async: !0
        })))
      }, []),
      y = xl || f ? [] : (v = t.entry.imports.concat(ul(g, t, {
        includeHydrateFallback: !0
      })), [...new Set(v)]);
    var v;
    let b = "object" === typeof t.sri ? t.sri : {};
    return Ka(!f, "The <Scripts /> element is a no-op when using RSC and can be safely removed."), xl || f ? null : i.createElement(i.Fragment, null, "object" === typeof t.sri ? i.createElement("script", {
      "rr-importmap": "",
      type: "importmap",
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: JSON.stringify({
          integrity: b
        })
      }
    }) : null, p ? null : i.createElement("link", {
      rel: "modulepreload",
      href: t.url,
      crossOrigin: e.crossOrigin,
      integrity: b[t.url],
      suppressHydrationWarning: !0
    }), i.createElement("link", {
      rel: "modulepreload",
      href: t.entry.module,
      crossOrigin: e.crossOrigin,
      integrity: b[t.entry.module],
      suppressHydrationWarning: !0
    }), y.map(t => i.createElement("link", {
      key: t,
      rel: "modulepreload",
      href: t,
      crossOrigin: e.crossOrigin,
      integrity: b[t],
      suppressHydrationWarning: !0
    })), m)
  }

  function Sl() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return e => {
      t.forEach(t => {
        "function" === typeof t ? t(e) : null != t && (t.current = e)
      })
    }
  }
  i.Component;

  function El(e) {
    let {
      error: t,
      isOutsideRemixApp: n
    } = e;
    console.error(t);
    let r, s = i.createElement("script", {
      dangerouslySetInnerHTML: {
        __html: '\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."\n        );\n      '
      }
    });
    if (fa(t)) return i.createElement(Tl, {
      title: "Unhandled Thrown Response!"
    }, i.createElement("h1", {
      style: {
        fontSize: "24px"
      }
    }, t.status, " ", t.statusText), s);
    if (t instanceof Error) r = t;
    else {
      let e = null == t ? "Unknown Error" : "object" === typeof t && "toString" in t ? t.toString() : JSON.stringify(t);
      r = new Error(e)
    }
    return i.createElement(Tl, {
      title: "Application Error!",
      isOutsideRemixApp: n
    }, i.createElement("h1", {
      style: {
        fontSize: "24px"
      }
    }, "Application Error"), i.createElement("pre", {
      style: {
        padding: "2rem",
        background: "hsla(10, 50%, 50%, 0.1)",
        color: "red",
        overflow: "auto"
      }
    }, r.stack), s)
  }

  function Tl(e) {
    var t;
    let {
      title: n,
      renderScripts: r,
      isOutsideRemixApp: s,
      children: o
    } = e, {
      routeModules: a
    } = ml();
    return null !== (t = a.root) && void 0 !== t && t.Layout && !s ? o : i.createElement("html", {
      lang: "en"
    }, i.createElement("head", null, i.createElement("meta", {
      charSet: "utf-8"
    }), i.createElement("meta", {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }), i.createElement("title", null, n)), i.createElement("body", null, i.createElement("main", {
      style: {
        fontFamily: "system-ui, sans-serif",
        padding: "2rem"
      }
    }, o, r ? i.createElement(kl, null) : null)))
  }
  var Cl = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement;
  try {
    Cl && (window.__reactRouterVersion = "7.9.4")
  } catch (Lf) {}

  function Ol(e) {
    let {
      basename: t,
      children: n,
      window: r
    } = e, s = i.useRef();
    null == s.current && (s.current = Lo({
      window: r,
      v5Compat: !0
    }));
    let o = s.current,
      [a, l] = i.useState({
        action: o.action,
        location: o.location
      }),
      c = i.useCallback(e => {
        i.startTransition(() => l(e))
      }, [l]);
    return i.useLayoutEffect(() => o.listen(c), [o, c]), i.createElement(Ya, {
      basename: t,
      children: n,
      location: a.location,
      navigationType: a.action,
      navigator: o
    })
  }
  var Pl = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    Al = i.forwardRef(function(e, t) {
      let n, {
          onClick: r,
          discover: s = "render",
          prefetch: o = "none",
          relative: a,
          reloadDocument: l,
          replace: c,
          state: h,
          target: d,
          to: f,
          preventScrollReset: p,
          viewTransition: g
        } = e,
        m = go(e, Po),
        {
          basename: y
        } = i.useContext(xa),
        v = "string" === typeof f && Pl.test(f),
        b = !1;
      if ("string" === typeof f && v && (n = f, Cl)) try {
        let e = new URL(window.location.href),
          t = f.startsWith("//") ? new URL(e.protocol + f) : new URL(f),
          n = ia(t.pathname, y);
        t.origin === e.origin && null != n ? f = n + t.search + t.hash : b = !0
      } catch (Lf) {
        No(!1, '<Link to="'.concat(f, '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.'))
      }
      let w = function(e) {
          let {
            relative: t
          } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          jo(Ta(), "useHref() may be used only in the context of a <Router> component.");
          let {
            basename: n,
            navigator: r
          } = i.useContext(xa), {
            hash: s,
            pathname: o,
            search: a
          } = Ra(e, {
            relative: t
          }), l = o;
          return "/" !== n && (l = "/" === o ? n : ca([n, o])), r.createHref({
            pathname: l,
            search: a,
            hash: s
          })
        }(f, {
          relative: a
        }),
        [_, x, k] = function(e, t) {
          let n = i.useContext(gl),
            [r, s] = i.useState(!1),
            [o, a] = i.useState(!1),
            {
              onFocus: l,
              onBlur: c,
              onMouseEnter: u,
              onMouseLeave: h,
              onTouchStart: d
            } = t,
            f = i.useRef(null);
          i.useEffect(() => {
            if ("render" === e && a(!0), "viewport" === e) {
              let e = new IntersectionObserver(e => {
                e.forEach(e => {
                  a(e.isIntersecting)
                })
              }, {
                threshold: .5
              });
              return f.current && e.observe(f.current), () => {
                e.disconnect()
              }
            }
          }, [e]), i.useEffect(() => {
            if (r) {
              let e = setTimeout(() => {
                a(!0)
              }, 100);
              return () => {
                clearTimeout(e)
              }
            }
          }, [r]);
          let p = () => {
              s(!0)
            },
            g = () => {
              s(!1), a(!1)
            };
          return n ? "intent" !== e ? [o, f, {}] : [o, f, {
            onFocus: yl(l, p),
            onBlur: yl(c, g),
            onMouseEnter: yl(u, p),
            onMouseLeave: yl(h, g),
            onTouchStart: yl(d, p)
          }] : [!1, f, {}]
        }(o, m),
        S = function(e) {
          let {
            target: t,
            replace: n,
            state: r,
            preventScrollReset: s,
            relative: o,
            viewTransition: a
          } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, l = Aa(), c = Ca(), u = Ra(e, {
            relative: o
          });
          return i.useCallback(i => {
            if (function(e, t) {
                return 0 === e.button && (!t || "_self" === t) && ! function(e) {
                  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
                }(e)
              }(i, t)) {
              i.preventDefault();
              let t = void 0 !== n ? n : zo(c) === zo(u);
              l(e, {
                replace: t,
                state: r,
                preventScrollReset: s,
                relative: o,
                viewTransition: a
              })
            }
          }, [c, l, u, n, r, t, e, s, o, a])
        }(f, {
          replace: c,
          state: h,
          target: d,
          preventScrollReset: p,
          relative: a,
          viewTransition: g
        });
      let E = i.createElement("a", u(u(u({}, m), k), {}, {
        href: n || w,
        onClick: b || l ? r : function(e) {
          r && r(e), e.defaultPrevented || S(e)
        },
        ref: Sl(t, x),
        target: d,
        "data-discover": v || "render" !== s ? void 0 : "true"
      }));
      return _ && !v ? i.createElement(i.Fragment, null, E, i.createElement(bl, {
        page: w
      })) : E
    });
  Al.displayName = "Link";
  var Rl = i.forwardRef(function(e, t) {
    let {
      "aria-current": n = "page",
      caseSensitive: r = !1,
      className: s = "",
      end: o = !1,
      style: a,
      to: l,
      viewTransition: c,
      children: h
    } = e, d = go(e, Ao), f = Ra(l, {
      relative: d.relative
    }), p = Ca(), g = i.useContext(ya), {
      navigator: m,
      basename: y
    } = i.useContext(xa), v = null != g && function(e) {
      let {
        relative: t
      } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = i.useContext(ba);
      jo(null != n, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
      let {
        basename: r
      } = jl("useViewTransitionState"), s = Ra(e, {
        relative: t
      });
      if (!n.isTransitioning) return !1;
      let o = ia(n.currentLocation.pathname, r) || n.currentLocation.pathname,
        a = ia(n.nextLocation.pathname, r) || n.nextLocation.pathname;
      return null != ta(s.pathname, a) || null != ta(s.pathname, o)
    }(f) && !0 === c, b = m.encodeLocation ? m.encodeLocation(f).pathname : f.pathname, w = p.pathname, _ = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    r || (w = w.toLowerCase(), _ = _ ? _.toLowerCase() : null, b = b.toLowerCase()), _ && y && (_ = ia(_, y) || _);
    const x = "/" !== b && b.endsWith("/") ? b.length - 1 : b.length;
    let k, S = w === b || !o && w.startsWith(b) && "/" === w.charAt(x),
      E = null != _ && (_ === b || !o && _.startsWith(b) && "/" === _.charAt(b.length)),
      T = {
        isActive: S,
        isPending: E,
        isTransitioning: v
      },
      C = S ? n : void 0;
    k = "function" === typeof s ? s(T) : [s, S ? "active" : null, E ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
    let O = "function" === typeof a ? a(T) : a;
    return i.createElement(Al, u(u({}, d), {}, {
      "aria-current": C,
      className: k,
      ref: t,
      style: O,
      to: l,
      viewTransition: c
    }), "function" === typeof h ? h(T) : h)
  });
  Rl.displayName = "NavLink";
  var Ml = i.forwardRef((e, t) => {
    let {
      discover: n = "render",
      fetcherKey: r,
      navigate: s,
      reloadDocument: o,
      replace: a,
      state: l,
      method: c = Qa,
      action: h,
      onSubmit: d,
      relative: f,
      preventScrollReset: p,
      viewTransition: g
    } = e, m = go(e, Ro), y = Dl(), v = function(e) {
      let {
        relative: t
      } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {
        basename: n
      } = i.useContext(xa), r = i.useContext(Sa);
      jo(r, "useFormAction must be used inside a RouteContext");
      let [s] = r.matches.slice(-1), o = u({}, Ra(e || ".", {
        relative: t
      })), a = Ca();
      if (null == e) {
        o.search = a.search;
        let e = new URLSearchParams(o.search),
          t = e.getAll("index");
        if (t.some(e => "" === e)) {
          e.delete("index"), t.filter(e => e).forEach(t => e.append("index", t));
          let n = e.toString();
          o.search = n ? "?".concat(n) : ""
        }
      }
      e && "." !== e || !s.route.index || (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index");
      "/" !== n && (o.pathname = "/" === o.pathname ? n : ca([n, o.pathname]));
      return zo(o)
    }(h, {
      relative: f
    }), b = "get" === c.toLowerCase() ? "get" : "post", w = "string" === typeof h && Pl.test(h);
    return i.createElement("form", u(u({
      ref: t,
      method: b,
      action: v,
      onSubmit: o ? d : e => {
        if (d && d(e), e.defaultPrevented) return;
        e.preventDefault();
        let t = e.nativeEvent.submitter,
          n = (null === t || void 0 === t ? void 0 : t.getAttribute("formmethod")) || c;
        y(t || e.currentTarget, {
          fetcherKey: r,
          method: n,
          navigate: s,
          replace: a,
          state: l,
          relative: f,
          preventScrollReset: p,
          viewTransition: g
        })
      }
    }, m), {}, {
      "data-discover": w || "render" !== n ? void 0 : "true"
    }))
  });

  function Ll(e) {
    return "".concat(e, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")
  }

  function jl(e) {
    let t = i.useContext(ma);
    return jo(t, Ll(e)), t
  }
  Ml.displayName = "Form";
  var Nl = 0,
    Il = () => "__".concat(String(++Nl), "__");

  function Dl() {
    let {
      router: e
    } = jl("useSubmit"), {
      basename: t
    } = i.useContext(xa), n = Ua("useRouteId");
    return i.useCallback(async function(r) {
      let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        {
          action: s,
          method: o,
          encType: a,
          formData: l,
          body: c
        } = rl(r, t);
      if (!1 === i.navigate) {
        let t = i.fetcherKey || Il();
        await e.fetch(t, n, i.action || s, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: c,
          formMethod: i.method || o,
          formEncType: i.encType || a,
          flushSync: i.flushSync
        })
      } else await e.navigate(i.action || s, {
        preventScrollReset: i.preventScrollReset,
        formData: l,
        body: c,
        formMethod: i.method || o,
        formEncType: i.encType || a,
        replace: i.replace,
        state: i.state,
        fromRouteId: n,
        flushSync: i.flushSync,
        viewTransition: i.viewTransition
      })
    }, [e, t, n])
  }
  class zl extends Error {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "FunctionsError",
        n = arguments.length > 2 ? arguments[2] : void 0;
      super(e), this.name = t, this.context = n
    }
  }
  class Fl extends zl {
    constructor(e) {
      super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
  }
  class Bl extends zl {
    constructor(e) {
      super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
  }
  class Ul extends zl {
    constructor(e) {
      super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
  }
  var Wl;
  ! function(e) {
    e.Any = "any", e.ApNortheast1 = "ap-northeast-1", e.ApNortheast2 = "ap-northeast-2", e.ApSouth1 = "ap-south-1", e.ApSoutheast1 = "ap-southeast-1", e.ApSoutheast2 = "ap-southeast-2", e.CaCentral1 = "ca-central-1", e.EuCentral1 = "eu-central-1", e.EuWest1 = "eu-west-1", e.EuWest2 = "eu-west-2", e.EuWest3 = "eu-west-3", e.SaEast1 = "sa-east-1", e.UsEast1 = "us-east-1", e.UsWest1 = "us-west-1", e.UsWest2 = "us-west-2"
  }(Wl || (Wl = {}));
  var Hl = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  class Vl {
    constructor(e) {
      let {
        headers: t = {},
        customFetch: r,
        region: i = Wl.Any
      } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.url = e, this.headers = t, this.region = i, this.fetch = (e => {
        let t;
        return t = e || ("undefined" === typeof fetch ? function() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
            return Promise.resolve().then(n.bind(n, 630)).then(e => {
              let {
                default: n
              } = e;
              return n(...t)
            })
          } : fetch),
          function() {
            return t(...arguments)
          }
      })(r)
    }
    setAuth(e) {
      this.headers.Authorization = "Bearer ".concat(e)
    }
    invoke(e) {
      return Hl(this, arguments, void 0, function(e) {
        var t = this;
        let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return function*() {
          var r;
          try {
            const {
              headers: i,
              method: s,
              body: o,
              signal: a
            } = n;
            let l = {},
              {
                region: c
              } = n;
            c || (c = t.region);
            const u = new URL("".concat(t.url, "/").concat(e));
            let h;
            c && "any" !== c && (l["x-region"] = c, u.searchParams.set("forceFunctionRegion", c)), o && (i && !Object.prototype.hasOwnProperty.call(i, "Content-Type") || !i) && ("undefined" !== typeof Blob && o instanceof Blob || o instanceof ArrayBuffer ? (l["Content-Type"] = "application/octet-stream", h = o) : "string" === typeof o ? (l["Content-Type"] = "text/plain", h = o) : "undefined" !== typeof FormData && o instanceof FormData ? h = o : (l["Content-Type"] = "application/json", h = JSON.stringify(o)));
            const d = yield t.fetch(u.toString(), {
              method: s || "POST",
              headers: Object.assign(Object.assign(Object.assign({}, l), t.headers), i),
              body: h,
              signal: a
            }).catch(e => {
              if ("AbortError" === e.name) throw e;
              throw new Fl(e)
            }), f = d.headers.get("x-relay-error");
            if (f && "true" === f) throw new Bl(d);
            if (!d.ok) throw new Ul(d);
            let p, g = (null !== (r = d.headers.get("Content-Type")) && void 0 !== r ? r : "text/plain").split(";")[0].trim();
            return p = "application/json" === g ? yield d.json(): "application/octet-stream" === g ? yield d.blob(): "text/event-stream" === g ? d : "multipart/form-data" === g ? yield d.formData(): yield d.text(), {
              data: p,
              error: null,
              response: d
            }
          } catch (i) {
            return i instanceof Error && "AbortError" === i.name ? {
              data: null,
              error: new Fl(i)
            } : {
              data: null,
              error: i,
              response: i instanceof Ul || i instanceof Bl ? i.context : void 0
            }
          }
        }()
      })
    }
  }
  var ql = n(980);
  const {
    PostgrestClient: Kl,
    PostgrestQueryBuilder: $l,
    PostgrestFilterBuilder: Yl,
    PostgrestTransformBuilder: Jl,
    PostgrestBuilder: Gl,
    PostgrestError: Ql
  } = ql;
  const Xl = class {
      static detectEnvironment() {
        var e;
        if ("undefined" !== typeof WebSocket) return {
          type: "native",
          constructor: WebSocket
        };
        if ("undefined" !== typeof globalThis && "undefined" !== typeof globalThis.WebSocket) return {
          type: "native",
          constructor: globalThis.WebSocket
        };
        if ("undefined" !== typeof n.g && "undefined" !== typeof n.g.WebSocket) return {
          type: "native",
          constructor: n.g.WebSocket
        };
        if ("undefined" !== typeof globalThis && "undefined" !== typeof globalThis.WebSocketPair && "undefined" === typeof globalThis.WebSocket) return {
          type: "cloudflare",
          error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
          workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
        };
        if ("undefined" !== typeof globalThis && globalThis.EdgeRuntime || "undefined" !== typeof navigator && (null === (e = navigator.userAgent) || void 0 === e ? void 0 : e.includes("Vercel-Edge"))) return {
          type: "unsupported",
          error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
          workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
        };
        if ("undefined" !== typeof process) {
          const e = process.versions;
          if (e && e.node) {
            const t = e.node,
              n = parseInt(t.replace(/^v/, "").split(".")[0]);
            return n >= 22 ? "undefined" !== typeof globalThis.WebSocket ? {
              type: "native",
              constructor: globalThis.WebSocket
            } : {
              type: "unsupported",
              error: "Node.js ".concat(n, " detected but native WebSocket not found."),
              workaround: "Provide a WebSocket implementation via the transport option."
            } : {
              type: "unsupported",
              error: "Node.js ".concat(n, " detected without native WebSocket support."),
              workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
            }
          }
        }
        return {
          type: "unsupported",
          error: "Unknown JavaScript runtime without WebSocket support.",
          workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
      }
      static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor) return e.constructor;
        let t = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (t += "\n\nSuggested solution: ".concat(e.workaround)), new Error(t)
      }
      static createWebSocket(e, t) {
        return new(this.getWebSocketConstructor())(e, t)
      }
      static isWebSocketSupported() {
        try {
          const e = this.detectEnvironment();
          return "native" === e.type || "ws" === e.type
        } catch (Gc) {
          return !1
        }
      }
    },
    Zl = "realtime-js/".concat("2.75.1"),
    ec = 1e4;
  var tc, nc, rc, ic, sc, oc;
  ! function(e) {
    e[e.connecting = 0] = "connecting", e[e.open = 1] = "open", e[e.closing = 2] = "closing", e[e.closed = 3] = "closed"
  }(tc || (tc = {})),
  function(e) {
    e.closed = "closed", e.errored = "errored", e.joined = "joined", e.joining = "joining", e.leaving = "leaving"
  }(nc || (nc = {})),
  function(e) {
    e.close = "phx_close", e.error = "phx_error", e.join = "phx_join", e.reply = "phx_reply", e.leave = "phx_leave", e.access_token = "access_token"
  }(rc || (rc = {})),
  function(e) {
    e.websocket = "websocket"
  }(ic || (ic = {})),
  function(e) {
    e.Connecting = "connecting", e.Open = "open", e.Closing = "closing", e.Closed = "closed"
  }(sc || (sc = {}));
  class ac {
    constructor() {
      this.HEADER_LENGTH = 1
    }
    decode(e, t) {
      return e.constructor === ArrayBuffer ? t(this._binaryDecode(e)) : t("string" === typeof e ? JSON.parse(e) : {})
    }
    _binaryDecode(e) {
      const t = new DataView(e),
        n = new TextDecoder;
      return this._decodeBroadcast(e, t, n)
    }
    _decodeBroadcast(e, t, n) {
      const r = t.getUint8(1),
        i = t.getUint8(2);
      let s = this.HEADER_LENGTH + 2;
      const o = n.decode(e.slice(s, s + r));
      s += r;
      const a = n.decode(e.slice(s, s + i));
      s += i;
      return {
        ref: null,
        topic: o,
        event: a,
        payload: JSON.parse(n.decode(e.slice(s, e.byteLength)))
      }
    }
  }
  class lc {
    constructor(e, t) {
      this.callback = e, this.timerCalc = t, this.timer = void 0, this.tries = 0, this.callback = e, this.timerCalc = t
    }
    reset() {
      this.tries = 0, clearTimeout(this.timer), this.timer = void 0
    }
    scheduleTimeout() {
      clearTimeout(this.timer), this.timer = setTimeout(() => {
        this.tries = this.tries + 1, this.callback()
      }, this.timerCalc(this.tries + 1))
    }
  }! function(e) {
    e.abstime = "abstime", e.bool = "bool", e.date = "date", e.daterange = "daterange", e.float4 = "float4", e.float8 = "float8", e.int2 = "int2", e.int4 = "int4", e.int4range = "int4range", e.int8 = "int8", e.int8range = "int8range", e.json = "json", e.jsonb = "jsonb", e.money = "money", e.numeric = "numeric", e.oid = "oid", e.reltime = "reltime", e.text = "text", e.time = "time", e.timestamp = "timestamp", e.timestamptz = "timestamptz", e.timetz = "timetz", e.tsrange = "tsrange", e.tstzrange = "tstzrange"
  }(oc || (oc = {}));
  const cc = function(e, t) {
      var n;
      const r = null !== (n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).skipTypes) && void 0 !== n ? n : [];
      return t ? Object.keys(t).reduce((n, i) => (n[i] = uc(i, e, t, r), n), {}) : {}
    },
    uc = (e, t, n, r) => {
      const i = t.find(t => t.name === e),
        s = null === i || void 0 === i ? void 0 : i.type,
        o = n[e];
      return s && !r.includes(s) ? hc(s, o) : dc(o)
    },
    hc = (e, t) => {
      if ("_" === e.charAt(0)) {
        const n = e.slice(1, e.length);
        return mc(t, n)
      }
      switch (e) {
        case oc.bool:
          return fc(t);
        case oc.float4:
        case oc.float8:
        case oc.int2:
        case oc.int4:
        case oc.int8:
        case oc.numeric:
        case oc.oid:
          return pc(t);
        case oc.json:
        case oc.jsonb:
          return gc(t);
        case oc.timestamp:
          return yc(t);
        case oc.abstime:
        case oc.date:
        case oc.daterange:
        case oc.int4range:
        case oc.int8range:
        case oc.money:
        case oc.reltime:
        case oc.text:
        case oc.time:
        case oc.timestamptz:
        case oc.timetz:
        case oc.tsrange:
        case oc.tstzrange:
        default:
          return dc(t)
      }
    },
    dc = e => e,
    fc = e => {
      switch (e) {
        case "t":
          return !0;
        case "f":
          return !1;
        default:
          return e
      }
    },
    pc = e => {
      if ("string" === typeof e) {
        const t = parseFloat(e);
        if (!Number.isNaN(t)) return t
      }
      return e
    },
    gc = e => {
      if ("string" === typeof e) try {
        return JSON.parse(e)
      } catch (t) {
        return console.log("JSON parse error: ".concat(t)), e
      }
      return e
    },
    mc = (e, t) => {
      if ("string" !== typeof e) return e;
      const n = e.length - 1,
        r = e[n];
      if ("{" === e[0] && "}" === r) {
        let r;
        const s = e.slice(1, n);
        try {
          r = JSON.parse("[" + s + "]")
        } catch (i) {
          r = s ? s.split(",") : []
        }
        return r.map(e => hc(t, e))
      }
      return e
    },
    yc = e => "string" === typeof e ? e.replace(" ", "T") : e,
    vc = e => {
      let t = e;
      return t = t.replace(/^ws/i, "http"), t = t.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), t.replace(/\/+$/, "") + "/api/broadcast"
    };
  class bc {
    constructor(e, t) {
      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ec;
      this.channel = e, this.event = t, this.payload = n, this.timeout = r, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null
    }
    resend(e) {
      this.timeout = e, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send()
    }
    send() {
      this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef()
      }))
    }
    updatePayload(e) {
      this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, t) {
      var n;
      return this._hasReceived(e) && t(null === (n = this.receivedResp) || void 0 === n ? void 0 : n.response), this.recHooks.push({
        status: e,
        callback: t
      }), this
    }
    startTimeout() {
      if (this.timeoutTimer) return;
      this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref);
      this.channel._on(this.refEvent, {}, e => {
        this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = e, this._matchReceive(e)
      }), this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {})
      }, this.timeout)
    }
    trigger(e, t) {
      this.refEvent && this.channel._trigger(this.refEvent, {
        status: e,
        response: t
      })
    }
    destroy() {
      this._cancelRefEvent(), this._cancelTimeout()
    }
    _cancelRefEvent() {
      this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
      clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0
    }
    _matchReceive(e) {
      let {
        status: t,
        response: n
      } = e;
      this.recHooks.filter(e => e.status === t).forEach(e => e.callback(n))
    }
    _hasReceived(e) {
      return this.receivedResp && this.receivedResp.status === e
    }
  }
  var wc, _c, xc, kc;
  ! function(e) {
    e.SYNC = "sync", e.JOIN = "join", e.LEAVE = "leave"
  }(wc || (wc = {}));
  class Sc {
    constructor(e, t) {
      this.channel = e, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.enabled = !1, this.caller = {
        onJoin: () => {},
        onLeave: () => {},
        onSync: () => {}
      };
      const n = (null === t || void 0 === t ? void 0 : t.events) || {
        state: "presence_state",
        diff: "presence_diff"
      };
      this.channel._on(n.state, {}, e => {
        const {
          onJoin: t,
          onLeave: n,
          onSync: r
        } = this.caller;
        this.joinRef = this.channel._joinRef(), this.state = Sc.syncState(this.state, e, t, n), this.pendingDiffs.forEach(e => {
          this.state = Sc.syncDiff(this.state, e, t, n)
        }), this.pendingDiffs = [], r()
      }), this.channel._on(n.diff, {}, e => {
        const {
          onJoin: t,
          onLeave: n,
          onSync: r
        } = this.caller;
        this.inPendingSyncState() ? this.pendingDiffs.push(e) : (this.state = Sc.syncDiff(this.state, e, t, n), r())
      }), this.onJoin((e, t, n) => {
        this.channel._trigger("presence", {
          event: "join",
          key: e,
          currentPresences: t,
          newPresences: n
        })
      }), this.onLeave((e, t, n) => {
        this.channel._trigger("presence", {
          event: "leave",
          key: e,
          currentPresences: t,
          leftPresences: n
        })
      }), this.onSync(() => {
        this.channel._trigger("presence", {
          event: "sync"
        })
      })
    }
    static syncState(e, t, n, r) {
      const i = this.cloneDeep(e),
        s = this.transformState(t),
        o = {},
        a = {};
      return this.map(i, (e, t) => {
        s[e] || (a[e] = t)
      }), this.map(s, (e, t) => {
        const n = i[e];
        if (n) {
          const r = t.map(e => e.presence_ref),
            i = n.map(e => e.presence_ref),
            s = t.filter(e => i.indexOf(e.presence_ref) < 0),
            l = n.filter(e => r.indexOf(e.presence_ref) < 0);
          s.length > 0 && (o[e] = s), l.length > 0 && (a[e] = l)
        } else o[e] = t
      }), this.syncDiff(i, {
        joins: o,
        leaves: a
      }, n, r)
    }
    static syncDiff(e, t, n, r) {
      const {
        joins: i,
        leaves: s
      } = {
        joins: this.transformState(t.joins),
        leaves: this.transformState(t.leaves)
      };
      return n || (n = () => {}), r || (r = () => {}), this.map(i, (t, r) => {
        var i;
        const s = null !== (i = e[t]) && void 0 !== i ? i : [];
        if (e[t] = this.cloneDeep(r), s.length > 0) {
          const n = e[t].map(e => e.presence_ref),
            r = s.filter(e => n.indexOf(e.presence_ref) < 0);
          e[t].unshift(...r)
        }
        n(t, s, r)
      }), this.map(s, (t, n) => {
        let i = e[t];
        if (!i) return;
        const s = n.map(e => e.presence_ref);
        i = i.filter(e => s.indexOf(e.presence_ref) < 0), e[t] = i, r(t, i, n), 0 === i.length && delete e[t]
      }), e
    }
    static map(e, t) {
      return Object.getOwnPropertyNames(e).map(n => t(n, e[n]))
    }
    static transformState(e) {
      return e = this.cloneDeep(e), Object.getOwnPropertyNames(e).reduce((t, n) => {
        const r = e[n];
        return t[n] = "metas" in r ? r.metas.map(e => (e.presence_ref = e.phx_ref, delete e.phx_ref, delete e.phx_ref_prev, e)) : r, t
      }, {})
    }
    static cloneDeep(e) {
      return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
      this.caller.onJoin = e
    }
    onLeave(e) {
      this.caller.onLeave = e
    }
    onSync(e) {
      this.caller.onSync = e
    }
    inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
  }! function(e) {
    e.ALL = "*", e.INSERT = "INSERT", e.UPDATE = "UPDATE", e.DELETE = "DELETE"
  }(_c || (_c = {})),
  function(e) {
    e.BROADCAST = "broadcast", e.PRESENCE = "presence", e.POSTGRES_CHANGES = "postgres_changes", e.SYSTEM = "system"
  }(xc || (xc = {})),
  function(e) {
    e.SUBSCRIBED = "SUBSCRIBED", e.TIMED_OUT = "TIMED_OUT", e.CLOSED = "CLOSED", e.CHANNEL_ERROR = "CHANNEL_ERROR"
  }(kc || (kc = {}));
  class Ec {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
          config: {}
        },
        n = arguments.length > 2 ? arguments[2] : void 0;
      var r, i;
      if (this.topic = e, this.params = t, this.socket = n, this.bindings = {}, this.state = nc.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = e.replace(/^realtime:/i, ""), this.params.config = Object.assign({
          broadcast: {
            ack: !1,
            self: !1
          },
          presence: {
            key: "",
            enabled: !1
          },
          private: !1
        }, t.config), this.timeout = this.socket.timeout, this.joinPush = new bc(this, rc.join, this.params, this.timeout), this.rejoinTimer = new lc(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
          this.state = nc.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(e => e.send()), this.pushBuffer = []
        }), this._onClose(() => {
          this.rejoinTimer.reset(), this.socket.log("channel", "close ".concat(this.topic, " ").concat(this._joinRef())), this.state = nc.closed, this.socket._remove(this)
        }), this._onError(e => {
          this._isLeaving() || this._isClosed() || (this.socket.log("channel", "error ".concat(this.topic), e), this.state = nc.errored, this.rejoinTimer.scheduleTimeout())
        }), this.joinPush.receive("timeout", () => {
          this._isJoining() && (this.socket.log("channel", "timeout ".concat(this.topic), this.joinPush.timeout), this.state = nc.errored, this.rejoinTimer.scheduleTimeout())
        }), this.joinPush.receive("error", e => {
          this._isLeaving() || this._isClosed() || (this.socket.log("channel", "error ".concat(this.topic), e), this.state = nc.errored, this.rejoinTimer.scheduleTimeout())
        }), this._on(rc.reply, {}, (e, t) => {
          this._trigger(this._replyEventName(t), e)
        }), this.presence = new Sc(this), this.broadcastEndpointURL = vc(this.socket.endPoint), this.private = this.params.config.private || !1, !this.private && (null === (i = null === (r = this.params.config) || void 0 === r ? void 0 : r.broadcast) || void 0 === i ? void 0 : i.replay)) throw "tried to use replay on public channel '".concat(this.topic, "'. It must be a private channel.")
    }
    subscribe(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.timeout;
      var n, r, i;
      if (this.socket.isConnected() || this.socket.connect(), this.state == nc.closed) {
        const {
          config: {
            broadcast: s,
            presence: o,
            private: a
          }
        } = this.params, l = null !== (r = null === (n = this.bindings.postgres_changes) || void 0 === n ? void 0 : n.map(e => e.filter)) && void 0 !== r ? r : [], c = !!this.bindings[xc.PRESENCE] && this.bindings[xc.PRESENCE].length > 0 || !0 === (null === (i = this.params.config.presence) || void 0 === i ? void 0 : i.enabled), u = {}, h = {
          broadcast: s,
          presence: Object.assign(Object.assign({}, o), {
            enabled: c
          }),
          postgres_changes: l,
          private: a
        };
        this.socket.accessTokenValue && (u.access_token = this.socket.accessTokenValue), this._onError(t => null === e || void 0 === e ? void 0 : e(kc.CHANNEL_ERROR, t)), this._onClose(() => null === e || void 0 === e ? void 0 : e(kc.CLOSED)), this.updateJoinPayload(Object.assign({
          config: h
        }, u)), this.joinedOnce = !0, this._rejoin(t), this.joinPush.receive("ok", async t => {
          let {
            postgres_changes: n
          } = t;
          var r;
          if (this.socket.setAuth(), void 0 !== n) {
            const t = this.bindings.postgres_changes,
              i = null !== (r = null === t || void 0 === t ? void 0 : t.length) && void 0 !== r ? r : 0,
              s = [];
            for (let r = 0; r < i; r++) {
              const i = t[r],
                {
                  filter: {
                    event: o,
                    schema: a,
                    table: l,
                    filter: c
                  }
                } = i,
                u = n && n[r];
              if (!u || u.event !== o || u.schema !== a || u.table !== l || u.filter !== c) return this.unsubscribe(), this.state = nc.errored, void(null === e || void 0 === e || e(kc.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes")));
              s.push(Object.assign(Object.assign({}, i), {
                id: u.id
              }))
            }
            return this.bindings.postgres_changes = s, void(e && e(kc.SUBSCRIBED))
          }
          null === e || void 0 === e || e(kc.SUBSCRIBED)
        }).receive("error", t => {
          this.state = nc.errored, null === e || void 0 === e || e(kc.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(t).join(", ") || "error")))
        }).receive("timeout", () => {
          null === e || void 0 === e || e(kc.TIMED_OUT)
        })
      }
      return this
    }
    presenceState() {
      return this.presence.state
    }
    async track(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return await this.send({
        type: "presence",
        event: "track",
        payload: e
      }, t.timeout || this.timeout)
    }
    async untrack() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return await this.send({
        type: "presence",
        event: "untrack"
      }, e)
    }
    on(e, t, n) {
      return this.state === nc.joined && e === xc.PRESENCE && (this.socket.log("channel", "resubscribe to ".concat(this.topic, " due to change in presence callbacks on joined channel")), this.unsubscribe().then(() => this.subscribe())), this._on(e, t, n)
    }
    async send(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      var n, r;
      if (this._canPush() || "broadcast" !== e.type) return new Promise(n => {
        var r, i, s;
        const o = this._push(e.type, e, t.timeout || this.timeout);
        "broadcast" !== e.type || (null === (s = null === (i = null === (r = this.params) || void 0 === r ? void 0 : r.config) || void 0 === i ? void 0 : i.broadcast) || void 0 === s ? void 0 : s.ack) || n("ok"), o.receive("ok", () => n("ok")), o.receive("error", () => n("error")), o.receive("timeout", () => n("timed out"))
      });
      {
        const {
          event: s,
          payload: o
        } = e, a = {
          method: "POST",
          headers: {
            Authorization: this.socket.accessTokenValue ? "Bearer ".concat(this.socket.accessTokenValue) : "",
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: [{
              topic: this.subTopic,
              event: s,
              payload: o,
              private: this.private
            }]
          })
        };
        try {
          const e = await this._fetchWithTimeout(this.broadcastEndpointURL, a, null !== (n = t.timeout) && void 0 !== n ? n : this.timeout);
          return await (null === (r = e.body) || void 0 === r ? void 0 : r.cancel()), e.ok ? "ok" : "error"
        } catch (i) {
          return "AbortError" === i.name ? "timed out" : "error"
        }
      }
    }
    updateJoinPayload(e) {
      this.joinPush.updatePayload(e)
    }
    unsubscribe() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;
      this.state = nc.leaving;
      const t = () => {
        this.socket.log("channel", "leave ".concat(this.topic)), this._trigger(rc.close, "leave", this._joinRef())
      };
      this.joinPush.destroy();
      let n = null;
      return new Promise(r => {
        n = new bc(this, rc.leave, {}, e), n.receive("ok", () => {
          t(), r("ok")
        }).receive("timeout", () => {
          t(), r("timed out")
        }).receive("error", () => {
          r("error")
        }), n.send(), this._canPush() || n.trigger("ok", {})
      }).finally(() => {
        null === n || void 0 === n || n.destroy()
      })
    }
    teardown() {
      this.pushBuffer.forEach(e => e.destroy()), this.pushBuffer = [], this.rejoinTimer.reset(), this.joinPush.destroy(), this.state = nc.closed, this.bindings = {}
    }
    async _fetchWithTimeout(e, t, n) {
      const r = new AbortController,
        i = setTimeout(() => r.abort(), n),
        s = await this.socket.fetch(e, Object.assign(Object.assign({}, t), {
          signal: r.signal
        }));
      return clearTimeout(i), s
    }
    _push(e, t) {
      let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;
      if (!this.joinedOnce) throw "tried to push '".concat(e, "' to '").concat(this.topic, "' before joining. Use channel.subscribe() before pushing events");
      let r = new bc(this, e, t, n);
      return this._canPush() ? r.send() : this._addToPushBuffer(r), r
    }
    _addToPushBuffer(e) {
      if (e.startTimeout(), this.pushBuffer.push(e), this.pushBuffer.length > 100) {
        const e = this.pushBuffer.shift();
        e && (e.destroy(), this.socket.log("channel", "discarded push due to buffer overflow: ".concat(e.event), e.payload))
      }
    }
    _onMessage(e, t, n) {
      return t
    }
    _isMember(e) {
      return this.topic === e
    }
    _joinRef() {
      return this.joinPush.ref
    }
    _trigger(e, t, n) {
      var r, i;
      const s = e.toLocaleLowerCase(),
        {
          close: o,
          error: a,
          leave: l,
          join: c
        } = rc;
      if (n && [o, a, l, c].indexOf(s) >= 0 && n !== this._joinRef()) return;
      let u = this._onMessage(s, t, n);
      if (t && !u) throw "channel onMessage callbacks must return the payload, modified or unmodified";
      ["insert", "update", "delete"].includes(s) ? null === (r = this.bindings.postgres_changes) || void 0 === r || r.filter(e => {
        var t, n, r;
        return "*" === (null === (t = e.filter) || void 0 === t ? void 0 : t.event) || (null === (r = null === (n = e.filter) || void 0 === n ? void 0 : n.event) || void 0 === r ? void 0 : r.toLocaleLowerCase()) === s
      }).map(e => e.callback(u, n)) : null === (i = this.bindings[s]) || void 0 === i || i.filter(e => {
        var n, r, i, o, a, l;
        if (["broadcast", "presence", "postgres_changes"].includes(s)) {
          if ("id" in e) {
            const s = e.id,
              o = null === (n = e.filter) || void 0 === n ? void 0 : n.event;
            return s && (null === (r = t.ids) || void 0 === r ? void 0 : r.includes(s)) && ("*" === o || (null === o || void 0 === o ? void 0 : o.toLocaleLowerCase()) === (null === (i = t.data) || void 0 === i ? void 0 : i.type.toLocaleLowerCase()))
          } {
            const n = null === (a = null === (o = null === e || void 0 === e ? void 0 : e.filter) || void 0 === o ? void 0 : o.event) || void 0 === a ? void 0 : a.toLocaleLowerCase();
            return "*" === n || n === (null === (l = null === t || void 0 === t ? void 0 : t.event) || void 0 === l ? void 0 : l.toLocaleLowerCase())
          }
        }
        return e.type.toLocaleLowerCase() === s
      }).map(e => {
        if ("object" === typeof u && "ids" in u) {
          const e = u.data,
            {
              schema: t,
              table: n,
              commit_timestamp: r,
              type: i,
              errors: s
            } = e,
            o = {
              schema: t,
              table: n,
              commit_timestamp: r,
              eventType: i,
              new: {},
              old: {},
              errors: s
            };
          u = Object.assign(Object.assign({}, o), this._getPayloadRecords(e))
        }
        e.callback(u, n)
      })
    }
    _isClosed() {
      return this.state === nc.closed
    }
    _isJoined() {
      return this.state === nc.joined
    }
    _isJoining() {
      return this.state === nc.joining
    }
    _isLeaving() {
      return this.state === nc.leaving
    }
    _replyEventName(e) {
      return "chan_reply_".concat(e)
    }
    _on(e, t, n) {
      const r = e.toLocaleLowerCase(),
        i = {
          type: r,
          filter: t,
          callback: n
        };
      return this.bindings[r] ? this.bindings[r].push(i) : this.bindings[r] = [i], this
    }
    _off(e, t) {
      const n = e.toLocaleLowerCase();
      return this.bindings[n] && (this.bindings[n] = this.bindings[n].filter(e => {
        var r;
        return !((null === (r = e.type) || void 0 === r ? void 0 : r.toLocaleLowerCase()) === n && Ec.isEqual(e.filter, t))
      })), this
    }
    static isEqual(e, t) {
      if (Object.keys(e).length !== Object.keys(t).length) return !1;
      for (const n in e)
        if (e[n] !== t[n]) return !1;
      return !0
    }
    _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
      this._on(rc.close, {}, e)
    }
    _onError(e) {
      this._on(rc.error, {}, t => e(t))
    }
    _canPush() {
      return this.socket.isConnected() && this._isJoined()
    }
    _rejoin() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;
      this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = nc.joining, this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
      const t = {
        new: {},
        old: {}
      };
      return "INSERT" !== e.type && "UPDATE" !== e.type || (t.new = cc(e.columns, e.record)), "UPDATE" !== e.type && "DELETE" !== e.type || (t.old = cc(e.columns, e.old_record)), t
    }
  }
  const Tc = () => {},
    Cc = 25e3,
    Oc = 10,
    Pc = 100,
    Ac = [1e3, 2e3, 5e3, 1e4];
  class Rc {
    constructor(e, t) {
      var r;
      if (this.accessTokenValue = null, this.apiKey = null, this.channels = new Array, this.endPoint = "", this.httpEndpoint = "", this.headers = {}, this.params = {}, this.timeout = ec, this.transport = null, this.heartbeatIntervalMs = Cc, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.heartbeatCallback = Tc, this.ref = 0, this.reconnectTimer = null, this.logger = Tc, this.conn = null, this.sendBuffer = [], this.serializer = new ac, this.stateChangeCallbacks = {
          open: [],
          close: [],
          error: [],
          message: []
        }, this.accessToken = null, this._connectionState = "disconnected", this._wasManualDisconnect = !1, this._authPromise = null, this._resolveFetch = e => {
          let t;
          return t = e || ("undefined" === typeof fetch ? function() {
              for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
              return Promise.resolve().then(n.bind(n, 630)).then(e => {
                let {
                  default: n
                } = e;
                return n(...t)
              }).catch(e => {
                throw new Error("Failed to load @supabase/node-fetch: ".concat(e.message, ". ") + "This is required for HTTP requests in Node.js environments without native fetch.")
              })
            } : fetch),
            function() {
              return t(...arguments)
            }
        }, !(null === (r = null === t || void 0 === t ? void 0 : t.params) || void 0 === r ? void 0 : r.apikey)) throw new Error("API key is required to connect to Realtime");
      this.apiKey = t.params.apikey, this.endPoint = "".concat(e, "/").concat(ic.websocket), this.httpEndpoint = vc(e), this._initializeOptions(t), this._setupReconnectionTimer(), this.fetch = this._resolveFetch(null === t || void 0 === t ? void 0 : t.fetch)
    }
    connect() {
      if (!(this.isConnecting() || this.isDisconnecting() || null !== this.conn && this.isConnected())) {
        if (this._setConnectionState("connecting"), this._setAuthSafely("connect"), this.transport) this.conn = new this.transport(this.endpointURL());
        else try {
          this.conn = Xl.createWebSocket(this.endpointURL())
        } catch (e) {
          this._setConnectionState("disconnected");
          const t = e.message;
          if (t.includes("Node.js")) throw new Error("".concat(t, "\n\n") + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\n\nOption 1: Use Node.js 22+ which has native WebSocket support\nOption 2: Install and provide the "ws" package:\n\n  npm install ws\n\n  import ws from "ws"\n  const client = new RealtimeClient(url, {\n    ...options,\n    transport: ws\n  })');
          throw new Error("WebSocket not available: ".concat(t))
        }
        this._setupConnectionHandlers()
      }
    }
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {
        vsn: "1.0.0"
      }))
    }
    disconnect(e, t) {
      if (!this.isDisconnecting())
        if (this._setConnectionState("disconnecting", !0), this.conn) {
          const n = setTimeout(() => {
            this._setConnectionState("disconnected")
          }, 100);
          this.conn.onclose = () => {
            clearTimeout(n), this._setConnectionState("disconnected")
          }, e ? this.conn.close(e, null !== t && void 0 !== t ? t : "") : this.conn.close(), this._teardownConnection()
        } else this._setConnectionState("disconnected")
    }
    getChannels() {
      return this.channels
    }
    async removeChannel(e) {
      const t = await e.unsubscribe();
      return 0 === this.channels.length && this.disconnect(), t
    }
    async removeAllChannels() {
      const e = await Promise.all(this.channels.map(e => e.unsubscribe()));
      return this.channels = [], this.disconnect(), e
    }
    log(e, t, n) {
      this.logger(e, t, n)
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case tc.connecting:
          return sc.Connecting;
        case tc.open:
          return sc.Open;
        case tc.closing:
          return sc.Closing;
        default:
          return sc.Closed
      }
    }
    isConnected() {
      return this.connectionState() === sc.Open
    }
    isConnecting() {
      return "connecting" === this._connectionState
    }
    isDisconnecting() {
      return "disconnecting" === this._connectionState
    }
    channel(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        config: {}
      };
      const n = "realtime:".concat(e),
        r = this.getChannels().find(e => e.topic === n);
      if (r) return r;
      {
        const n = new Ec("realtime:".concat(e), t, this);
        return this.channels.push(n), n
      }
    }
    push(e) {
      const {
        topic: t,
        event: n,
        payload: r,
        ref: i
      } = e, s = () => {
        this.encode(e, e => {
          var t;
          null === (t = this.conn) || void 0 === t || t.send(e)
        })
      };
      this.log("push", "".concat(t, " ").concat(n, " (").concat(i, ")"), r), this.isConnected() ? s() : this.sendBuffer.push(s)
    }
    async setAuth() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      this._authPromise = this._performAuth(e);
      try {
        await this._authPromise
      } finally {
        this._authPromise = null
      }
    }
    async sendHeartbeat() {
      var e;
      if (this.isConnected()) {
        if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          try {
            this.heartbeatCallback("timeout")
          } catch (Lf) {
            this.log("error", "error in heartbeat callback", Lf)
          }
          return this._wasManualDisconnect = !1, null === (e = this.conn) || void 0 === e || e.close(1e3, "heartbeat timeout"), void setTimeout(() => {
            var e;
            this.isConnected() || null === (e = this.reconnectTimer) || void 0 === e || e.scheduleTimeout()
          }, Pc)
        }
        this.pendingHeartbeatRef = this._makeRef(), this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef
        });
        try {
          this.heartbeatCallback("sent")
        } catch (Lf) {
          this.log("error", "error in heartbeat callback", Lf)
        }
        this._setAuthSafely("heartbeat")
      } else try {
        this.heartbeatCallback("disconnected")
      } catch (Lf) {
        this.log("error", "error in heartbeat callback", Lf)
      }
    }
    onHeartbeat(e) {
      this.heartbeatCallback = e
    }
    flushSendBuffer() {
      this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()), this.sendBuffer = [])
    }
    _makeRef() {
      let e = this.ref + 1;
      return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString()
    }
    _leaveOpenTopic(e) {
      let t = this.channels.find(t => t.topic === e && (t._isJoined() || t._isJoining()));
      t && (this.log("transport", 'leaving duplicate topic "'.concat(e, '"')), t.unsubscribe())
    }
    _remove(e) {
      this.channels = this.channels.filter(t => t.topic !== e.topic)
    }
    _onConnMessage(e) {
      this.decode(e.data, e => {
        if ("phoenix" === e.topic && "phx_reply" === e.event) try {
          this.heartbeatCallback("ok" === e.payload.status ? "ok" : "error")
        } catch (Lf) {
          this.log("error", "error in heartbeat callback", Lf)
        }
        e.ref && e.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
        const {
          topic: t,
          event: n,
          payload: r,
          ref: i
        } = e, s = i ? "(".concat(i, ")") : "", o = r.status || "";
        this.log("receive", "".concat(o, " ").concat(t, " ").concat(n, " ").concat(s).trim(), r), this.channels.filter(e => e._isMember(t)).forEach(e => e._trigger(n, r, i)), this._triggerStateCallbacks("message", e)
      })
    }
    _clearTimer(e) {
      var t;
      "heartbeat" === e && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer), this.heartbeatTimer = void 0) : "reconnect" === e && (null === (t = this.reconnectTimer) || void 0 === t || t.reset())
    }
    _clearAllTimers() {
      this._clearTimer("heartbeat"), this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
      this.conn && ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"), this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = e => this._onConnError(e), this.conn.onmessage = e => this._onConnMessage(e), this.conn.onclose = e => this._onConnClose(e))
    }
    _teardownConnection() {
      this.conn && (this.conn.onopen = null, this.conn.onerror = null, this.conn.onmessage = null, this.conn.onclose = null, this.conn = null), this._clearAllTimers(), this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
      this._setConnectionState("connected"), this.log("transport", "connected to ".concat(this.endpointURL())), this.flushSendBuffer(), this._clearTimer("reconnect"), this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(), this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
      this.workerUrl ? this.log("worker", "starting worker for from ".concat(this.workerUrl)) : this.log("worker", "starting default worker");
      const e = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(e), this.workerRef.onerror = e => {
        this.log("worker", "worker error", e.message), this.workerRef.terminate()
      }, this.workerRef.onmessage = e => {
        "keepAlive" === e.data.event && this.sendHeartbeat()
      }, this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      })
    }
    _onConnClose(e) {
      var t;
      this._setConnectionState("disconnected"), this.log("transport", "close", e), this._triggerChanError(), this._clearTimer("heartbeat"), this._wasManualDisconnect || null === (t = this.reconnectTimer) || void 0 === t || t.scheduleTimeout(), this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
      this._setConnectionState("disconnected"), this.log("transport", "".concat(e)), this._triggerChanError(), this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
      this.channels.forEach(e => e._trigger(rc.error))
    }
    _appendParams(e, t) {
      if (0 === Object.keys(t).length) return e;
      const n = e.match(/\?/) ? "&" : "?",
        r = new URLSearchParams(t);
      return "".concat(e).concat(n).concat(r)
    }
    _workerObjectUrl(e) {
      let t;
      if (e) t = e;
      else {
        const e = new Blob(['\n  addEventListener("message", (e) => {\n    if (e.data.event === "start") {\n      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });'], {
          type: "application/javascript"
        });
        t = URL.createObjectURL(e)
      }
      return t
    }
    _setConnectionState(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._connectionState = e, "connecting" === e ? this._wasManualDisconnect = !1 : "disconnecting" === e && (this._wasManualDisconnect = t)
    }
    async _performAuth() {
      let e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      e = t || (this.accessToken ? await this.accessToken() : this.accessTokenValue), this.accessTokenValue != e && (this.accessTokenValue = e, this.channels.forEach(t => {
        const n = {
          access_token: e,
          version: Zl
        };
        e && t.updateJoinPayload(n), t.joinedOnce && t._isJoined() && t._push(rc.access_token, {
          access_token: e
        })
      }))
    }
    async _waitForAuthIfNeeded() {
      this._authPromise && await this._authPromise
    }
    _setAuthSafely() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "general";
      this.setAuth().catch(t => {
        this.log("error", "error setting auth in ".concat(e), t)
      })
    }
    _triggerStateCallbacks(e, t) {
      try {
        this.stateChangeCallbacks[e].forEach(n => {
          try {
            n(t)
          } catch (Lf) {
            this.log("error", "error in ".concat(e, " callback"), Lf)
          }
        })
      } catch (Lf) {
        this.log("error", "error triggering ".concat(e, " callbacks"), Lf)
      }
    }
    _setupReconnectionTimer() {
      this.reconnectTimer = new lc(async () => {
        setTimeout(async () => {
          await this._waitForAuthIfNeeded(), this.isConnected() || this.connect()
        }, Oc)
      }, this.reconnectAfterMs)
    }
    _initializeOptions(e) {
      var t, n, r, i, s, o, a, l, c;
      if (this.transport = null !== (t = null === e || void 0 === e ? void 0 : e.transport) && void 0 !== t ? t : null, this.timeout = null !== (n = null === e || void 0 === e ? void 0 : e.timeout) && void 0 !== n ? n : ec, this.heartbeatIntervalMs = null !== (r = null === e || void 0 === e ? void 0 : e.heartbeatIntervalMs) && void 0 !== r ? r : Cc, this.worker = null !== (i = null === e || void 0 === e ? void 0 : e.worker) && void 0 !== i && i, this.accessToken = null !== (s = null === e || void 0 === e ? void 0 : e.accessToken) && void 0 !== s ? s : null, this.heartbeatCallback = null !== (o = null === e || void 0 === e ? void 0 : e.heartbeatCallback) && void 0 !== o ? o : Tc, (null === e || void 0 === e ? void 0 : e.params) && (this.params = e.params), (null === e || void 0 === e ? void 0 : e.logger) && (this.logger = e.logger), ((null === e || void 0 === e ? void 0 : e.logLevel) || (null === e || void 0 === e ? void 0 : e.log_level)) && (this.logLevel = e.logLevel || e.log_level, this.params = Object.assign(Object.assign({}, this.params), {
          log_level: this.logLevel
        })), this.reconnectAfterMs = null !== (a = null === e || void 0 === e ? void 0 : e.reconnectAfterMs) && void 0 !== a ? a : e => Ac[e - 1] || 1e4, this.encode = null !== (l = null === e || void 0 === e ? void 0 : e.encode) && void 0 !== l ? l : (e, t) => t(JSON.stringify(e)), this.decode = null !== (c = null === e || void 0 === e ? void 0 : e.decode) && void 0 !== c ? c : this.serializer.decode.bind(this.serializer), this.worker) {
        if ("undefined" !== typeof window && !window.Worker) throw new Error("Web Worker is not supported");
        this.workerUrl = null === e || void 0 === e ? void 0 : e.workerUrl
      }
    }
  }
  class Mc extends Error {
    constructor(e) {
      super(e), this.__isStorageError = !0, this.name = "StorageError"
    }
  }

  function Lc(e) {
    return "object" === typeof e && null !== e && "__isStorageError" in e
  }
  class jc extends Mc {
    constructor(e, t, n) {
      super(e), this.name = "StorageApiError", this.status = t, this.statusCode = n
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        statusCode: this.statusCode
      }
    }
  }
  class Nc extends Mc {
    constructor(e, t) {
      super(e), this.name = "StorageUnknownError", this.originalError = t
    }
  }
  var Ic = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  const Dc = e => {
      let t;
      return t = e || ("undefined" === typeof fetch ? function() {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
          return Promise.resolve().then(n.bind(n, 630)).then(e => {
            let {
              default: n
            } = e;
            return n(...t)
          })
        } : fetch),
        function() {
          return t(...arguments)
        }
    },
    zc = e => {
      if (Array.isArray(e)) return e.map(e => zc(e));
      if ("function" === typeof e || e !== Object(e)) return e;
      const t = {};
      return Object.entries(e).forEach(e => {
        let [n, r] = e;
        const i = n.replace(/([-_][a-z])/gi, e => e.toUpperCase().replace(/[-_]/g, ""));
        t[i] = zc(r)
      }), t
    };
  var Fc = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  const Bc = e => e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
    Uc = (e, t, r) => Fc(void 0, void 0, void 0, function*() {
      const i = yield Ic(void 0, void 0, void 0, function*() {
        return "undefined" === typeof Response ? (yield Promise.resolve().then(n.bind(n, 630))).Response : Response
      });
      e instanceof i && !(null === r || void 0 === r ? void 0 : r.noResolveJson) ? e.json().then(n => {
        const r = e.status || 500,
          i = (null === n || void 0 === n ? void 0 : n.statusCode) || r + "";
        t(new jc(Bc(n), r, i))
      }).catch(e => {
        t(new Nc(Bc(e), e))
      }) : t(new Nc(Bc(e), e))
    }),
    Wc = (e, t, n, r) => {
      const i = {
        method: e,
        headers: (null === t || void 0 === t ? void 0 : t.headers) || {}
      };
      return "GET" !== e && r ? ((e => {
        if ("object" !== typeof e || null === e) return !1;
        const t = Object.getPrototypeOf(e);
        return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
      })(r) ? (i.headers = Object.assign({
        "Content-Type": "application/json"
      }, null === t || void 0 === t ? void 0 : t.headers), i.body = JSON.stringify(r)) : i.body = r, (null === t || void 0 === t ? void 0 : t.duplex) && (i.duplex = t.duplex), Object.assign(Object.assign({}, i), n)) : i
    };

  function Hc(e, t, n, r, i, s) {
    return Fc(this, void 0, void 0, function*() {
      return new Promise((o, a) => {
        e(n, Wc(t, r, i, s)).then(e => {
          if (!e.ok) throw e;
          return (null === r || void 0 === r ? void 0 : r.noResolveJson) ? e : e.json()
        }).then(e => o(e)).catch(e => Uc(e, a, r))
      })
    })
  }

  function Vc(e, t, n, r) {
    return Fc(this, void 0, void 0, function*() {
      return Hc(e, "GET", t, n, r)
    })
  }

  function qc(e, t, n, r, i) {
    return Fc(this, void 0, void 0, function*() {
      return Hc(e, "POST", t, r, i, n)
    })
  }

  function Kc(e, t, n, r, i) {
    return Fc(this, void 0, void 0, function*() {
      return Hc(e, "PUT", t, r, i, n)
    })
  }

  function $c(e, t, n, r, i) {
    return Fc(this, void 0, void 0, function*() {
      return Hc(e, "DELETE", t, r, i, n)
    })
  }
  var Yc = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  class Jc {
    constructor(e, t) {
      this.downloadFn = e, this.shouldThrowOnError = t
    }
    then(e, t) {
      return this.execute().then(e, t)
    }
    execute() {
      return Yc(this, void 0, void 0, function*() {
        try {
          return {
            data: (yield this.downloadFn()).body,
            error: null
          }
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (Lc(e)) return {
            data: null,
            error: e
          };
          throw e
        }
      })
    }
  }
  var Gc, Qc = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  Gc = Symbol.toStringTag;
  const Xc = class {
    constructor(e, t) {
      this.downloadFn = e, this.shouldThrowOnError = t, this[Gc] = "BlobDownloadBuilder", this.promise = null
    }
    asStream() {
      return new Jc(this.downloadFn, this.shouldThrowOnError)
    }
    then(e, t) {
      return this.getPromise().then(e, t)
    } catch (e) {
      return this.getPromise().catch(e)
    } finally(e) {
      return this.getPromise().finally(e)
    }
    getPromise() {
      return this.promise || (this.promise = this.execute()), this.promise
    }
    execute() {
      return Qc(this, void 0, void 0, function*() {
        try {
          const e = yield this.downloadFn();
          return {
            data: yield e.blob(),
            error: null
          }
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (Lc(e)) return {
            data: null,
            error: e
          };
          throw e
        }
      })
    }
  };
  var Zc = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  const eu = {
      limit: 100,
      offset: 0,
      sortBy: {
        column: "name",
        order: "asc"
      }
    },
    tu = {
      cacheControl: "3600",
      contentType: "text/plain;charset=UTF-8",
      upsert: !1
    };
  class nu {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = arguments.length > 2 ? arguments[2] : void 0,
        r = arguments.length > 3 ? arguments[3] : void 0;
      this.shouldThrowOnError = !1, this.url = e, this.headers = t, this.bucketId = n, this.fetch = Dc(r)
    }
    throwOnError() {
      return this.shouldThrowOnError = !0, this
    }
    uploadOrUpdate(e, t, n, r) {
      return Zc(this, void 0, void 0, function*() {
        try {
          let i;
          const s = Object.assign(Object.assign({}, tu), r);
          let o = Object.assign(Object.assign({}, this.headers), "POST" === e && {
            "x-upsert": String(s.upsert)
          });
          const a = s.metadata;
          "undefined" !== typeof Blob && n instanceof Blob ? (i = new FormData, i.append("cacheControl", s.cacheControl), a && i.append("metadata", this.encodeMetadata(a)), i.append("", n)) : "undefined" !== typeof FormData && n instanceof FormData ? (i = n, i.append("cacheControl", s.cacheControl), a && i.append("metadata", this.encodeMetadata(a))) : (i = n, o["cache-control"] = "max-age=".concat(s.cacheControl), o["content-type"] = s.contentType, a && (o["x-metadata"] = this.toBase64(this.encodeMetadata(a)))), (null === r || void 0 === r ? void 0 : r.headers) && (o = Object.assign(Object.assign({}, o), r.headers));
          const l = this._removeEmptyFolders(t),
            c = this._getFinalPath(l),
            u = yield("PUT" == e ? Kc : qc)(this.fetch, "".concat(this.url, "/object/").concat(c), i, Object.assign({
              headers: o
            }, (null === s || void 0 === s ? void 0 : s.duplex) ? {
              duplex: s.duplex
            } : {}));
          return {
            data: {
              path: l,
              id: u.Id,
              fullPath: u.Key
            },
            error: null
          }
        } catch (i) {
          if (this.shouldThrowOnError) throw i;
          if (Lc(i)) return {
            data: null,
            error: i
          };
          throw i
        }
      })
    }
    upload(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        return this.uploadOrUpdate("POST", e, t, n)
      })
    }
    uploadToSignedUrl(e, t, n, r) {
      return Zc(this, void 0, void 0, function*() {
        const i = this._removeEmptyFolders(e),
          s = this._getFinalPath(i),
          o = new URL(this.url + "/object/upload/sign/".concat(s));
        o.searchParams.set("token", t);
        try {
          let e;
          const t = Object.assign({
              upsert: tu.upsert
            }, r),
            s = Object.assign(Object.assign({}, this.headers), {
              "x-upsert": String(t.upsert)
            });
          "undefined" !== typeof Blob && n instanceof Blob ? (e = new FormData, e.append("cacheControl", t.cacheControl), e.append("", n)) : "undefined" !== typeof FormData && n instanceof FormData ? (e = n, e.append("cacheControl", t.cacheControl)) : (e = n, s["cache-control"] = "max-age=".concat(t.cacheControl), s["content-type"] = t.contentType);
          return {
            data: {
              path: i,
              fullPath: (yield Kc(this.fetch, o.toString(), e, {
                headers: s
              })).Key
            },
            error: null
          }
        } catch (a) {
          if (this.shouldThrowOnError) throw a;
          if (Lc(a)) return {
            data: null,
            error: a
          };
          throw a
        }
      })
    }
    createSignedUploadUrl(e, t) {
      return Zc(this, void 0, void 0, function*() {
        try {
          let n = this._getFinalPath(e);
          const r = Object.assign({}, this.headers);
          (null === t || void 0 === t ? void 0 : t.upsert) && (r["x-upsert"] = "true");
          const i = yield qc(this.fetch, "".concat(this.url, "/object/upload/sign/").concat(n), {}, {
            headers: r
          }), s = new URL(this.url + i.url), o = s.searchParams.get("token");
          if (!o) throw new Mc("No token returned by API");
          return {
            data: {
              signedUrl: s.toString(),
              path: e,
              token: o
            },
            error: null
          }
        } catch (n) {
          if (this.shouldThrowOnError) throw n;
          if (Lc(n)) return {
            data: null,
            error: n
          };
          throw n
        }
      })
    }
    update(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        return this.uploadOrUpdate("PUT", e, t, n)
      })
    }
    move(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        try {
          return {
            data: yield qc(this.fetch, "".concat(this.url, "/object/move"), {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: t,
              destinationBucket: null === n || void 0 === n ? void 0 : n.destinationBucket
            }, {
              headers: this.headers
            }),
            error: null
          }
        } catch (r) {
          if (this.shouldThrowOnError) throw r;
          if (Lc(r)) return {
            data: null,
            error: r
          };
          throw r
        }
      })
    }
    copy(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        try {
          return {
            data: {
              path: (yield qc(this.fetch, "".concat(this.url, "/object/copy"), {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: t,
                destinationBucket: null === n || void 0 === n ? void 0 : n.destinationBucket
              }, {
                headers: this.headers
              })).Key
            },
            error: null
          }
        } catch (r) {
          if (this.shouldThrowOnError) throw r;
          if (Lc(r)) return {
            data: null,
            error: r
          };
          throw r
        }
      })
    }
    createSignedUrl(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        try {
          let r = this._getFinalPath(e),
            i = yield qc(this.fetch, "".concat(this.url, "/object/sign/").concat(r), Object.assign({
              expiresIn: t
            }, (null === n || void 0 === n ? void 0 : n.transform) ? {
              transform: n.transform
            } : {}), {
              headers: this.headers
            });
          const s = (null === n || void 0 === n ? void 0 : n.download) ? "&download=".concat(!0 === n.download ? "" : n.download) : "";
          return i = {
            signedUrl: encodeURI("".concat(this.url).concat(i.signedURL).concat(s))
          }, {
            data: i,
            error: null
          }
        } catch (r) {
          if (this.shouldThrowOnError) throw r;
          if (Lc(r)) return {
            data: null,
            error: r
          };
          throw r
        }
      })
    }
    createSignedUrls(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        try {
          const r = yield qc(this.fetch, "".concat(this.url, "/object/sign/").concat(this.bucketId), {
            expiresIn: t,
            paths: e
          }, {
            headers: this.headers
          }), i = (null === n || void 0 === n ? void 0 : n.download) ? "&download=".concat(!0 === n.download ? "" : n.download) : "";
          return {
            data: r.map(e => Object.assign(Object.assign({}, e), {
              signedUrl: e.signedURL ? encodeURI("".concat(this.url).concat(e.signedURL).concat(i)) : null
            })),
            error: null
          }
        } catch (r) {
          if (this.shouldThrowOnError) throw r;
          if (Lc(r)) return {
            data: null,
            error: r
          };
          throw r
        }
      })
    }
    download(e, t) {
      const n = "undefined" !== typeof(null === t || void 0 === t ? void 0 : t.transform) ? "render/image/authenticated" : "object",
        r = this.transformOptsToQueryString((null === t || void 0 === t ? void 0 : t.transform) || {}),
        i = r ? "?".concat(r) : "",
        s = this._getFinalPath(e);
      return new Xc(() => Vc(this.fetch, "".concat(this.url, "/").concat(n, "/").concat(s).concat(i), {
        headers: this.headers,
        noResolveJson: !0
      }), this.shouldThrowOnError)
    }
    info(e) {
      return Zc(this, void 0, void 0, function*() {
        const t = this._getFinalPath(e);
        try {
          const e = yield Vc(this.fetch, "".concat(this.url, "/object/info/").concat(t), {
            headers: this.headers
          });
          return {
            data: zc(e),
            error: null
          }
        } catch (n) {
          if (this.shouldThrowOnError) throw n;
          if (Lc(n)) return {
            data: null,
            error: n
          };
          throw n
        }
      })
    }
    exists(e) {
      return Zc(this, void 0, void 0, function*() {
        const t = this._getFinalPath(e);
        try {
          return yield function(e, t, n, r) {
            return Fc(this, void 0, void 0, function*() {
              return Hc(e, "HEAD", t, Object.assign(Object.assign({}, n), {
                noResolveJson: !0
              }), r)
            })
          }(this.fetch, "".concat(this.url, "/object/").concat(t), {
            headers: this.headers
          }), {
            data: !0,
            error: null
          }
        } catch (n) {
          if (this.shouldThrowOnError) throw n;
          if (Lc(n) && n instanceof Nc) {
            const e = n.originalError;
            if ([400, 404].includes(null === e || void 0 === e ? void 0 : e.status)) return {
              data: !1,
              error: n
            }
          }
          throw n
        }
      })
    }
    getPublicUrl(e, t) {
      const n = this._getFinalPath(e),
        r = [],
        i = (null === t || void 0 === t ? void 0 : t.download) ? "download=".concat(!0 === t.download ? "" : t.download) : "";
      "" !== i && r.push(i);
      const s = "undefined" !== typeof(null === t || void 0 === t ? void 0 : t.transform) ? "render/image" : "object",
        o = this.transformOptsToQueryString((null === t || void 0 === t ? void 0 : t.transform) || {});
      "" !== o && r.push(o);
      let a = r.join("&");
      return "" !== a && (a = "?".concat(a)), {
        data: {
          publicUrl: encodeURI("".concat(this.url, "/").concat(s, "/public/").concat(n).concat(a))
        }
      }
    }
    remove(e) {
      return Zc(this, void 0, void 0, function*() {
        try {
          return {
            data: yield $c(this.fetch, "".concat(this.url, "/object/").concat(this.bucketId), {
              prefixes: e
            }, {
              headers: this.headers
            }),
            error: null
          }
        } catch (t) {
          if (this.shouldThrowOnError) throw t;
          if (Lc(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
    list(e, t, n) {
      return Zc(this, void 0, void 0, function*() {
        try {
          const r = Object.assign(Object.assign(Object.assign({}, eu), t), {
            prefix: e || ""
          });
          return {
            data: yield qc(this.fetch, "".concat(this.url, "/object/list/").concat(this.bucketId), r, {
              headers: this.headers
            }, n),
            error: null
          }
        } catch (r) {
          if (this.shouldThrowOnError) throw r;
          if (Lc(r)) return {
            data: null,
            error: r
          };
          throw r
        }
      })
    }
    listV2(e, t) {
      return Zc(this, void 0, void 0, function*() {
        try {
          const n = Object.assign({}, e);
          return {
            data: yield qc(this.fetch, "".concat(this.url, "/object/list-v2/").concat(this.bucketId), n, {
              headers: this.headers
            }, t),
            error: null
          }
        } catch (n) {
          if (this.shouldThrowOnError) throw n;
          if (Lc(n)) return {
            data: null,
            error: n
          };
          throw n
        }
      })
    }
    encodeMetadata(e) {
      return JSON.stringify(e)
    }
    toBase64(e) {
      return "undefined" !== typeof Buffer ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
      return "".concat(this.bucketId, "/").concat(e.replace(/^\/+/, ""))
    }
    _removeEmptyFolders(e) {
      return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
      const t = [];
      return e.width && t.push("width=".concat(e.width)), e.height && t.push("height=".concat(e.height)), e.resize && t.push("resize=".concat(e.resize)), e.format && t.push("format=".concat(e.format)), e.quality && t.push("quality=".concat(e.quality)), t.join("&")
    }
  }
  const ru = {
    "X-Client-Info": "storage-js/".concat("2.75.1")
  };
  var iu = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  class su {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = arguments.length > 2 ? arguments[2] : void 0,
        r = arguments.length > 3 ? arguments[3] : void 0;
      this.shouldThrowOnError = !1;
      const i = new URL(e);
      if (null === r || void 0 === r ? void 0 : r.useNewHostname) {
        /supabase\.(co|in|red)$/.test(i.hostname) && !i.hostname.includes("storage.supabase.") && (i.hostname = i.hostname.replace("supabase.", "storage.supabase."))
      }
      this.url = i.href.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, ru), t), this.fetch = Dc(n)
    }
    throwOnError() {
      return this.shouldThrowOnError = !0, this
    }
    listBuckets() {
      return iu(this, void 0, void 0, function*() {
        try {
          return {
            data: yield Vc(this.fetch, "".concat(this.url, "/bucket"), {
              headers: this.headers
            }),
            error: null
          }
        } catch (e) {
          if (this.shouldThrowOnError) throw e;
          if (Lc(e)) return {
            data: null,
            error: e
          };
          throw e
        }
      })
    }
    getBucket(e) {
      return iu(this, void 0, void 0, function*() {
        try {
          return {
            data: yield Vc(this.fetch, "".concat(this.url, "/bucket/").concat(e), {
              headers: this.headers
            }),
            error: null
          }
        } catch (t) {
          if (this.shouldThrowOnError) throw t;
          if (Lc(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
    createBucket(e) {
      return iu(this, arguments, void 0, function(e) {
        var t = this;
        let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
          public: !1
        };
        return function*() {
          try {
            return {
              data: yield qc(t.fetch, "".concat(t.url, "/bucket"), {
                id: e,
                name: e,
                type: n.type,
                public: n.public,
                file_size_limit: n.fileSizeLimit,
                allowed_mime_types: n.allowedMimeTypes
              }, {
                headers: t.headers
              }),
              error: null
            }
          } catch (r) {
            if (t.shouldThrowOnError) throw r;
            if (Lc(r)) return {
              data: null,
              error: r
            };
            throw r
          }
        }()
      })
    }
    updateBucket(e, t) {
      return iu(this, void 0, void 0, function*() {
        try {
          return {
            data: yield Kc(this.fetch, "".concat(this.url, "/bucket/").concat(e), {
              id: e,
              name: e,
              public: t.public,
              file_size_limit: t.fileSizeLimit,
              allowed_mime_types: t.allowedMimeTypes
            }, {
              headers: this.headers
            }),
            error: null
          }
        } catch (n) {
          if (this.shouldThrowOnError) throw n;
          if (Lc(n)) return {
            data: null,
            error: n
          };
          throw n
        }
      })
    }
    emptyBucket(e) {
      return iu(this, void 0, void 0, function*() {
        try {
          return {
            data: yield qc(this.fetch, "".concat(this.url, "/bucket/").concat(e, "/empty"), {}, {
              headers: this.headers
            }),
            error: null
          }
        } catch (t) {
          if (this.shouldThrowOnError) throw t;
          if (Lc(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
    deleteBucket(e) {
      return iu(this, void 0, void 0, function*() {
        try {
          return {
            data: yield $c(this.fetch, "".concat(this.url, "/bucket/").concat(e), {}, {
              headers: this.headers
            }),
            error: null
          }
        } catch (t) {
          if (this.shouldThrowOnError) throw t;
          if (Lc(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
  }
  class ou extends su {
    constructor(e) {
      super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, arguments.length > 2 ? arguments[2] : void 0, arguments.length > 3 ? arguments[3] : void 0)
    }
    from(e) {
      return new nu(this.url, this.headers, e, this.fetch)
    }
  }
  let au = "";
  au = "undefined" !== typeof Deno ? "deno" : "undefined" !== typeof document ? "web" : "undefined" !== typeof navigator && "ReactNative" === navigator.product ? "react-native" : "node";
  const lu = {
      headers: {
        "X-Client-Info": "supabase-js-".concat(au, "/").concat("2.75.1")
      }
    },
    cu = {
      schema: "public"
    },
    uu = {
      autoRefreshToken: !0,
      persistSession: !0,
      detectSessionInUrl: !0,
      flowType: "implicit"
    },
    hu = {};
  var du = n(630),
    fu = function(e, t, n, r) {
      return new(n || (n = Promise))(function(i, s) {
        function o(e) {
          try {
            l(r.next(e))
          } catch (Lf) {
            s(Lf)
          }
        }

        function a(e) {
          try {
            l(r.throw(e))
          } catch (Lf) {
            s(Lf)
          }
        }

        function l(e) {
          e.done ? i(e.value) : function(e) {
            return e instanceof n ? e : new n(function(t) {
              t(e)
            })
          }(e.value).then(o, a)
        }
        l((r = r.apply(e, t || [])).next())
      })
    };
  const pu = e => {
      let t;
      return t = e || ("undefined" === typeof fetch ? du.default : fetch),
        function() {
          return t(...arguments)
        }
    },
    gu = (e, t, n) => {
      const r = pu(n),
        i = "undefined" === typeof Headers ? du.Headers : Headers;
      return (n, s) => fu(void 0, void 0, void 0, function*() {
        var o;
        const a = null !== (o = yield t()) && void 0 !== o ? o : e;
        let l = new i(null === s || void 0 === s ? void 0 : s.headers);
        return l.has("apikey") || l.set("apikey", e), l.has("Authorization") || l.set("Authorization", "Bearer ".concat(a)), r(n, Object.assign(Object.assign({}, s), {
          headers: l
        }))
      })
    };
  var mu = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  const yu = "2.75.1",
    vu = 3e4,
    bu = 9e4,
    wu = {
      "X-Client-Info": "gotrue-js/".concat(yu)
    },
    _u = "X-Supabase-Api-Version",
    xu = {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01"
    },
    ku = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
  class Su extends Error {
    constructor(e, t, n) {
      super(e), this.__isAuthError = !0, this.name = "AuthError", this.status = t, this.code = n
    }
  }

  function Eu(e) {
    return "object" === typeof e && null !== e && "__isAuthError" in e
  }
  class Tu extends Su {
    constructor(e, t, n) {
      super(e, t, n), this.name = "AuthApiError", this.status = t, this.code = n
    }
  }
  class Cu extends Su {
    constructor(e, t) {
      super(e), this.name = "AuthUnknownError", this.originalError = t
    }
  }
  class Ou extends Su {
    constructor(e, t, n, r) {
      super(e, n, r), this.name = t, this.status = n
    }
  }
  class Pu extends Ou {
    constructor() {
      super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
  }
  class Au extends Ou {
    constructor() {
      super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
  }
  class Ru extends Ou {
    constructor(e) {
      super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
  }
  class Mu extends Ou {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      super(e, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = t
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      }
    }
  }
  class Lu extends Ou {
    constructor(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = t
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      }
    }
  }
  class ju extends Ou {
    constructor(e, t) {
      super(e, "AuthRetryableFetchError", t, void 0)
    }
  }

  function Nu(e) {
    return Eu(e) && "AuthRetryableFetchError" === e.name
  }
  class Iu extends Ou {
    constructor(e, t, n) {
      super(e, "AuthWeakPasswordError", t, "weak_password"), this.reasons = n
    }
  }
  class Du extends Ou {
    constructor(e) {
      super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
  }
  const zu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),
    Fu = " \t\n\r=".split(""),
    Bu = (() => {
      const e = new Array(128);
      for (let t = 0; t < e.length; t += 1) e[t] = -1;
      for (let t = 0; t < Fu.length; t += 1) e[Fu[t].charCodeAt(0)] = -2;
      for (let t = 0; t < zu.length; t += 1) e[zu[t].charCodeAt(0)] = t;
      return e
    })();

  function Uu(e, t, n) {
    if (null !== e)
      for (t.queue = t.queue << 8 | e, t.queuedBits += 8; t.queuedBits >= 6;) {
        const e = t.queue >> t.queuedBits - 6 & 63;
        n(zu[e]), t.queuedBits -= 6
      } else if (t.queuedBits > 0)
        for (t.queue = t.queue << 6 - t.queuedBits, t.queuedBits = 6; t.queuedBits >= 6;) {
          const e = t.queue >> t.queuedBits - 6 & 63;
          n(zu[e]), t.queuedBits -= 6
        }
  }

  function Wu(e, t, n) {
    const r = Bu[e];
    if (!(r > -1)) {
      if (-2 === r) return;
      throw new Error('Invalid Base64-URL character "'.concat(String.fromCharCode(e), '"'))
    }
    for (t.queue = t.queue << 6 | r, t.queuedBits += 6; t.queuedBits >= 8;) n(t.queue >> t.queuedBits - 8 & 255), t.queuedBits -= 8
  }

  function Hu(e) {
    const t = [],
      n = e => {
        t.push(String.fromCodePoint(e))
      },
      r = {
        utf8seq: 0,
        codepoint: 0
      },
      i = {
        queue: 0,
        queuedBits: 0
      },
      s = e => {
        ! function(e, t, n) {
          if (0 === t.utf8seq) {
            if (e <= 127) return void n(e);
            for (let n = 1; n < 6; n += 1)
              if (0 === (e >> 7 - n & 1)) {
                t.utf8seq = n;
                break
              } if (2 === t.utf8seq) t.codepoint = 31 & e;
            else if (3 === t.utf8seq) t.codepoint = 15 & e;
            else {
              if (4 !== t.utf8seq) throw new Error("Invalid UTF-8 sequence");
              t.codepoint = 7 & e
            }
            t.utf8seq -= 1
          } else if (t.utf8seq > 0) {
            if (e <= 127) throw new Error("Invalid UTF-8 sequence");
            t.codepoint = t.codepoint << 6 | 63 & e, t.utf8seq -= 1, 0 === t.utf8seq && n(t.codepoint)
          }
        }(e, r, n)
      };
    for (let o = 0; o < e.length; o += 1) Wu(e.charCodeAt(o), i, s);
    return t.join("")
  }

  function Vu(e, t) {
    if (!(e <= 127)) {
      if (e <= 2047) return t(192 | e >> 6), void t(128 | 63 & e);
      if (e <= 65535) return t(224 | e >> 12), t(128 | e >> 6 & 63), void t(128 | 63 & e);
      if (e <= 1114111) return t(240 | e >> 18), t(128 | e >> 12 & 63), t(128 | e >> 6 & 63), void t(128 | 63 & e);
      throw new Error("Unrecognized Unicode codepoint: ".concat(e.toString(16)))
    }
    t(e)
  }

  function qu(e, t) {
    for (let n = 0; n < e.length; n += 1) {
      let r = e.charCodeAt(n);
      if (r > 55295 && r <= 56319) {
        const t = 1024 * (r - 55296) & 65535;
        r = 65536 + (e.charCodeAt(n + 1) - 56320 & 65535 | t), n += 1
      }
      Vu(r, t)
    }
  }

  function Ku(e) {
    const t = [],
      n = {
        queue: 0,
        queuedBits: 0
      },
      r = e => {
        t.push(e)
      };
    for (let i = 0; i < e.length; i += 1) Wu(e.charCodeAt(i), n, r);
    return new Uint8Array(t)
  }

  function $u(e) {
    const t = [],
      n = {
        queue: 0,
        queuedBits: 0
      },
      r = e => {
        t.push(e)
      };
    return e.forEach(e => Uu(e, n, r)), Uu(null, n, r), t.join("")
  }
  const Yu = () => "undefined" !== typeof window && "undefined" !== typeof document,
    Ju = {
      tested: !1,
      writable: !1
    },
    Gu = () => {
      if (!Yu()) return !1;
      try {
        if ("object" !== typeof globalThis.localStorage) return !1
      } catch (Lf) {
        return !1
      }
      if (Ju.tested) return Ju.writable;
      const e = "lswt-".concat(Math.random()).concat(Math.random());
      try {
        globalThis.localStorage.setItem(e, e), globalThis.localStorage.removeItem(e), Ju.tested = !0, Ju.writable = !0
      } catch (Lf) {
        Ju.tested = !0, Ju.writable = !1
      }
      return Ju.writable
    };
  const Qu = e => {
      let t;
      return t = e || ("undefined" === typeof fetch ? function() {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
          return Promise.resolve().then(n.bind(n, 630)).then(e => {
            let {
              default: n
            } = e;
            return n(...t)
          })
        } : fetch),
        function() {
          return t(...arguments)
        }
    },
    Xu = async (e, t, n) => {
      await e.setItem(t, JSON.stringify(n))
    }, Zu = async (e, t) => {
      const n = await e.getItem(t);
      if (!n) return null;
      try {
        return JSON.parse(n)
      } catch (Gc) {
        return n
      }
    }, eh = async (e, t) => {
      await e.removeItem(t)
    };
  class th {
    constructor() {
      this.promise = new th.promiseConstructor((e, t) => {
        this.resolve = e, this.reject = t
      })
    }
  }

  function nh(e) {
    const t = e.split(".");
    if (3 !== t.length) throw new Du("Invalid JWT structure");
    for (let n = 0; n < t.length; n++)
      if (!ku.test(t[n])) throw new Du("JWT not in base64url format");
    return {
      header: JSON.parse(Hu(t[0])),
      payload: JSON.parse(Hu(t[1])),
      signature: Ku(t[2]),
      raw: {
        header: t[0],
        payload: t[1]
      }
    }
  }

  function rh(e) {
    return ("0" + e.toString(16)).substr(-2)
  }
  async function ih(e) {
    if (!("undefined" !== typeof crypto && "undefined" !== typeof crypto.subtle && "undefined" !== typeof TextEncoder)) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), e;
    const t = await async function(e) {
      const t = (new TextEncoder).encode(e),
        n = await crypto.subtle.digest("SHA-256", t),
        r = new Uint8Array(n);
      return Array.from(r).map(e => String.fromCharCode(e)).join("")
    }(e);
    return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
  }
  async function sh(e, t) {
    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const r = function() {
      const e = new Uint32Array(56);
      if ("undefined" === typeof crypto) {
        const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
          t = e.length;
        let n = "";
        for (let r = 0; r < 56; r++) n += e.charAt(Math.floor(Math.random() * t));
        return n
      }
      return crypto.getRandomValues(e), Array.from(e, rh).join("")
    }();
    let i = r;
    n && (i += "/PASSWORD_RECOVERY"), await Xu(e, "".concat(t, "-code-verifier"), i);
    const s = await ih(r);
    return [s, r === s ? "plain" : "s256"]
  }
  th.promiseConstructor = Promise;
  const oh = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
  const ah = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;

  function lh(e) {
    if (!ah.test(e)) throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
  }

  function ch() {
    return new Proxy({}, {
      get: (e, t) => {
        if ("__isUserNotAvailableProxy" === t) return !0;
        if ("symbol" === typeof t) {
          const e = t.toString();
          if ("Symbol(Symbol.toPrimitive)" === e || "Symbol(Symbol.toStringTag)" === e || "Symbol(util.inspect.custom)" === e) return
        }
        throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "'.concat(t, '" property of the session object is not supported. Please use getUser() instead.'))
      },
      set: (e, t) => {
        throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "'.concat(t, '" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.'))
      },
      deleteProperty: (e, t) => {
        throw new Error('@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "'.concat(t, '" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.'))
      }
    })
  }

  function uh(e) {
    return JSON.parse(JSON.stringify(e))
  }
  var hh = function(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
    }
    return n
  };
  const dh = e => e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
    fh = [502, 503, 504];
  async function ph(e) {
    var t, n;
    if (!("object" === typeof(n = e) && null !== n && "status" in n && "ok" in n && "json" in n && "function" === typeof n.json)) throw new ju(dh(e), 0);
    if (fh.includes(e.status)) throw new ju(dh(e), e.status);
    let r, i;
    try {
      r = await e.json()
    } catch (Lf) {
      throw new Cu(dh(Lf), Lf)
    }
    const s = function(e) {
      const t = e.headers.get(_u);
      if (!t) return null;
      if (!t.match(oh)) return null;
      try {
        return new Date("".concat(t, "T00:00:00.0Z"))
      } catch (Lf) {
        return null
      }
    }(e);
    if (s && s.getTime() >= xu.timestamp && "object" === typeof r && r && "string" === typeof r.code ? i = r.code : "object" === typeof r && r && "string" === typeof r.error_code && (i = r.error_code), i) {
      if ("weak_password" === i) throw new Iu(dh(r), e.status, (null === (t = r.weak_password) || void 0 === t ? void 0 : t.reasons) || []);
      if ("session_not_found" === i) throw new Pu
    } else if ("object" === typeof r && r && "object" === typeof r.weak_password && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce((e, t) => e && "string" === typeof t, !0)) throw new Iu(dh(r), e.status, r.weak_password.reasons);
    throw new Tu(dh(r), e.status || 500, i)
  }
  async function gh(e, t, n, r) {
    var i;
    const s = Object.assign({}, null === r || void 0 === r ? void 0 : r.headers);
    s[_u] || (s[_u] = xu.name), (null === r || void 0 === r ? void 0 : r.jwt) && (s.Authorization = "Bearer ".concat(r.jwt));
    const o = null !== (i = null === r || void 0 === r ? void 0 : r.query) && void 0 !== i ? i : {};
    (null === r || void 0 === r ? void 0 : r.redirectTo) && (o.redirect_to = r.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : "",
      l = await async function(e, t, n, r, i, s) {
        const o = ((e, t, n, r) => {
          const i = {
            method: e,
            headers: (null === t || void 0 === t ? void 0 : t.headers) || {}
          };
          return "GET" === e ? i : (i.headers = Object.assign({
            "Content-Type": "application/json;charset=UTF-8"
          }, null === t || void 0 === t ? void 0 : t.headers), i.body = JSON.stringify(r), Object.assign(Object.assign({}, i), n))
        })(t, r, i, s);
        let a;
        try {
          a = await e(n, Object.assign({}, o))
        } catch (Lf) {
          throw console.error(Lf), new ju(dh(Lf), 0)
        }
        a.ok || await ph(a);
        if (null === r || void 0 === r ? void 0 : r.noResolveJson) return a;
        try {
          return await a.json()
        } catch (Lf) {
          await ph(Lf)
        }
      }(e, t, n + a, {
        headers: s,
        noResolveJson: null === r || void 0 === r ? void 0 : r.noResolveJson
      }, {}, null === r || void 0 === r ? void 0 : r.body);
    return (null === r || void 0 === r ? void 0 : r.xform) ? null === r || void 0 === r ? void 0 : r.xform(l) : {
      data: Object.assign({}, l),
      error: null
    }
  }

  function mh(e) {
    var t;
    let n = null;
    var r;
    (function(e) {
      return e.access_token && e.refresh_token && e.expires_in
    })(e) && (n = Object.assign({}, e), e.expires_at || (n.expires_at = (r = e.expires_in, Math.round(Date.now() / 1e3) + r)));
    return {
      data: {
        session: n,
        user: null !== (t = e.user) && void 0 !== t ? t : e
      },
      error: null
    }
  }

  function yh(e) {
    const t = mh(e);
    return !t.error && e.weak_password && "object" === typeof e.weak_password && Array.isArray(e.weak_password.reasons) && e.weak_password.reasons.length && e.weak_password.message && "string" === typeof e.weak_password.message && e.weak_password.reasons.reduce((e, t) => e && "string" === typeof t, !0) && (t.data.weak_password = e.weak_password), t
  }

  function vh(e) {
    var t;
    return {
      data: {
        user: null !== (t = e.user) && void 0 !== t ? t : e
      },
      error: null
    }
  }

  function bh(e) {
    return {
      data: e,
      error: null
    }
  }

  function wh(e) {
    const {
      action_link: t,
      email_otp: n,
      hashed_token: r,
      redirect_to: i,
      verification_type: s
    } = e, o = hh(e, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
    return {
      data: {
        properties: {
          action_link: t,
          email_otp: n,
          hashed_token: r,
          redirect_to: i,
          verification_type: s
        },
        user: Object.assign({}, o)
      },
      error: null
    }
  }

  function _h(e) {
    return e
  }
  const xh = ["global", "local", "others"];
  var kh = function(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
    }
    return n
  };
  class Sh {
    constructor(e) {
      let {
        url: t = "",
        headers: n = {},
        fetch: r
      } = e;
      this.url = t, this.headers = n, this.fetch = Qu(r), this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this)
      }, this.oauth = {
        listClients: this._listOAuthClients.bind(this),
        createClient: this._createOAuthClient.bind(this),
        getClient: this._getOAuthClient.bind(this),
        deleteClient: this._deleteOAuthClient.bind(this),
        regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
      }
    }
    async signOut(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : xh[0];
      if (xh.indexOf(t) < 0) throw new Error("@supabase/auth-js: Parameter scope must be one of ".concat(xh.join(", ")));
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/logout?scope=").concat(t), {
          headers: this.headers,
          jwt: e,
          noResolveJson: !0
        }), {
          data: null,
          error: null
        }
      } catch (n) {
        if (Eu(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    }
    async inviteUserByEmail(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/invite"), {
          body: {
            email: e,
            data: t.data
          },
          headers: this.headers,
          redirectTo: t.redirectTo,
          xform: vh
        })
      } catch (n) {
        if (Eu(n)) return {
          data: {
            user: null
          },
          error: n
        };
        throw n
      }
    }
    async generateLink(e) {
      try {
        const {
          options: t
        } = e, n = kh(e, ["options"]), r = Object.assign(Object.assign({}, n), t);
        return "newEmail" in n && (r.new_email = null === n || void 0 === n ? void 0 : n.newEmail, delete r.newEmail), await gh(this.fetch, "POST", "".concat(this.url, "/admin/generate_link"), {
          body: r,
          headers: this.headers,
          xform: wh,
          redirectTo: null === t || void 0 === t ? void 0 : t.redirectTo
        })
      } catch (t) {
        if (Eu(t)) return {
          data: {
            properties: null,
            user: null
          },
          error: t
        };
        throw t
      }
    }
    async createUser(e) {
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/admin/users"), {
          body: e,
          headers: this.headers,
          xform: vh
        })
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null
          },
          error: t
        };
        throw t
      }
    }
    async listUsers(e) {
      var t, n, r, i, s, o, a;
      try {
        const l = {
            nextPage: null,
            lastPage: 0,
            total: 0
          },
          c = await gh(this.fetch, "GET", "".concat(this.url, "/admin/users"), {
            headers: this.headers,
            noResolveJson: !0,
            query: {
              page: null !== (n = null === (t = null === e || void 0 === e ? void 0 : e.page) || void 0 === t ? void 0 : t.toString()) && void 0 !== n ? n : "",
              per_page: null !== (i = null === (r = null === e || void 0 === e ? void 0 : e.perPage) || void 0 === r ? void 0 : r.toString()) && void 0 !== i ? i : ""
            },
            xform: _h
          });
        if (c.error) throw c.error;
        const u = await c.json(),
          h = null !== (s = c.headers.get("x-total-count")) && void 0 !== s ? s : 0,
          d = null !== (a = null === (o = c.headers.get("link")) || void 0 === o ? void 0 : o.split(",")) && void 0 !== a ? a : [];
        return d.length > 0 && (d.forEach(e => {
          const t = parseInt(e.split(";")[0].split("=")[1].substring(0, 1)),
            n = JSON.parse(e.split(";")[1].split("=")[1]);
          l["".concat(n, "Page")] = t
        }), l.total = parseInt(h)), {
          data: Object.assign(Object.assign({}, u), l),
          error: null
        }
      } catch (l) {
        if (Eu(l)) return {
          data: {
            users: []
          },
          error: l
        };
        throw l
      }
    }
    async getUserById(e) {
      lh(e);
      try {
        return await gh(this.fetch, "GET", "".concat(this.url, "/admin/users/").concat(e), {
          headers: this.headers,
          xform: vh
        })
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null
          },
          error: t
        };
        throw t
      }
    }
    async updateUserById(e, t) {
      lh(e);
      try {
        return await gh(this.fetch, "PUT", "".concat(this.url, "/admin/users/").concat(e), {
          body: t,
          headers: this.headers,
          xform: vh
        })
      } catch (n) {
        if (Eu(n)) return {
          data: {
            user: null
          },
          error: n
        };
        throw n
      }
    }
    async deleteUser(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      lh(e);
      try {
        return await gh(this.fetch, "DELETE", "".concat(this.url, "/admin/users/").concat(e), {
          headers: this.headers,
          body: {
            should_soft_delete: t
          },
          xform: vh
        })
      } catch (n) {
        if (Eu(n)) return {
          data: {
            user: null
          },
          error: n
        };
        throw n
      }
    }
    async _listFactors(e) {
      lh(e.userId);
      try {
        const {
          data: t,
          error: n
        } = await gh(this.fetch, "GET", "".concat(this.url, "/admin/users/").concat(e.userId, "/factors"), {
          headers: this.headers,
          xform: e => ({
            data: {
              factors: e
            },
            error: null
          })
        });
        return {
          data: t,
          error: n
        }
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _deleteFactor(e) {
      lh(e.userId), lh(e.id);
      try {
        return {
          data: await gh(this.fetch, "DELETE", "".concat(this.url, "/admin/users/").concat(e.userId, "/factors/").concat(e.id), {
            headers: this.headers
          }),
          error: null
        }
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _listOAuthClients(e) {
      var t, n, r, i, s, o, a;
      try {
        const l = {
            nextPage: null,
            lastPage: 0,
            total: 0
          },
          c = await gh(this.fetch, "GET", "".concat(this.url, "/admin/oauth/clients"), {
            headers: this.headers,
            noResolveJson: !0,
            query: {
              page: null !== (n = null === (t = null === e || void 0 === e ? void 0 : e.page) || void 0 === t ? void 0 : t.toString()) && void 0 !== n ? n : "",
              per_page: null !== (i = null === (r = null === e || void 0 === e ? void 0 : e.perPage) || void 0 === r ? void 0 : r.toString()) && void 0 !== i ? i : ""
            },
            xform: _h
          });
        if (c.error) throw c.error;
        const u = await c.json(),
          h = null !== (s = c.headers.get("x-total-count")) && void 0 !== s ? s : 0,
          d = null !== (a = null === (o = c.headers.get("link")) || void 0 === o ? void 0 : o.split(",")) && void 0 !== a ? a : [];
        return d.length > 0 && (d.forEach(e => {
          const t = parseInt(e.split(";")[0].split("=")[1].substring(0, 1)),
            n = JSON.parse(e.split(";")[1].split("=")[1]);
          l["".concat(n, "Page")] = t
        }), l.total = parseInt(h)), {
          data: Object.assign(Object.assign({}, u), l),
          error: null
        }
      } catch (l) {
        if (Eu(l)) return {
          data: {
            clients: []
          },
          error: l
        };
        throw l
      }
    }
    async _createOAuthClient(e) {
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/admin/oauth/clients"), {
          body: e,
          headers: this.headers,
          xform: e => ({
            data: e,
            error: null
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _getOAuthClient(e) {
      try {
        return await gh(this.fetch, "GET", "".concat(this.url, "/admin/oauth/clients/").concat(e), {
          headers: this.headers,
          xform: e => ({
            data: e,
            error: null
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _deleteOAuthClient(e) {
      try {
        return await gh(this.fetch, "DELETE", "".concat(this.url, "/admin/oauth/clients/").concat(e), {
          headers: this.headers,
          xform: e => ({
            data: e,
            error: null
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _regenerateOAuthClientSecret(e) {
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/admin/oauth/clients/").concat(e, "/regenerate_secret"), {
          headers: this.headers,
          xform: e => ({
            data: e,
            error: null
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
  }

  function Eh() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return {
      getItem: t => e[t] || null,
      setItem: (t, n) => {
        e[t] = n
      },
      removeItem: t => {
        delete e[t]
      }
    }
  }
  const Th = !!(globalThis && Gu() && globalThis.localStorage && "true" === globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug"));
  class Ch extends Error {
    constructor(e) {
      super(e), this.isAcquireTimeout = !0
    }
  }
  class Oh extends Ch {}
  async function Ph(e, t, n) {
    Th && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", e, t);
    const r = new globalThis.AbortController;
    return t > 0 && setTimeout(() => {
      r.abort(), Th && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", e)
    }, t), await Promise.resolve().then(() => globalThis.navigator.locks.request(e, 0 === t ? {
      mode: "exclusive",
      ifAvailable: !0
    } : {
      mode: "exclusive",
      signal: r.signal
    }, async r => {
      if (!r) {
        if (0 === t) throw Th && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", e), new Oh('Acquiring an exclusive Navigator LockManager lock "'.concat(e, '" immediately failed'));
        if (Th) try {
          const e = await globalThis.navigator.locks.query();
          console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(e, null, "  "))
        } catch (Lf) {
          console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", Lf)
        }
        return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await n()
      }
      Th && console.log("@supabase/gotrue-js: navigatorLock: acquired", e, r.name);
      try {
        return await n()
      } finally {
        Th && console.log("@supabase/gotrue-js: navigatorLock: released", e, r.name)
      }
    }))
  }

  function Ah(e) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(e)) throw new Error('@supabase/auth-js: Address "'.concat(e, '" is invalid.'));
    return e.toLowerCase()
  }

  function Rh(e) {
    const t = (new TextEncoder).encode(e);
    return "0x" + Array.from(t, e => e.toString(16).padStart(2, "0")).join("")
  }
  class Mh extends Error {
    constructor(e) {
      let {
        message: t,
        code: n,
        cause: r,
        name: i
      } = e;
      var s;
      super(t, {
        cause: r
      }), this.__isWebAuthnError = !0, this.name = null !== (s = null !== i && void 0 !== i ? i : r instanceof Error ? r.name : void 0) && void 0 !== s ? s : "Unknown Error", this.code = n
    }
  }
  class Lh extends Mh {
    constructor(e, t) {
      super({
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t,
        message: e
      }), this.name = "WebAuthnUnknownError", this.originalError = t
    }
  }

  function jh(e) {
    let {
      error: t,
      options: n
    } = e;
    var r, i, s;
    const {
      publicKey: o
    } = n;
    if (!o) throw Error("options was missing required publicKey property");
    if ("AbortError" === t.name) {
      if (n.signal instanceof AbortSignal) return new Mh({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: t
      })
    } else if ("ConstraintError" === t.name) {
      if (!0 === (null === (r = o.authenticatorSelection) || void 0 === r ? void 0 : r.requireResidentKey)) return new Mh({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: t
      });
      if ("conditional" === n.mediation && "required" === (null === (i = o.authenticatorSelection) || void 0 === i ? void 0 : i.userVerification)) return new Mh({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: t
      });
      if ("required" === (null === (s = o.authenticatorSelection) || void 0 === s ? void 0 : s.userVerification)) return new Mh({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: t
      })
    } else {
      if ("InvalidStateError" === t.name) return new Mh({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: t
      });
      if ("NotAllowedError" === t.name) return new Mh({
        message: t.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
      });
      if ("NotSupportedError" === t.name) {
        return 0 === o.pubKeyCredParams.filter(e => "public-key" === e.type).length ? new Mh({
          message: 'No entry in pubKeyCredParams was of type "public-key"',
          code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
          cause: t
        }) : new Mh({
          message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
          code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
          cause: t
        })
      }
      if ("SecurityError" === t.name) {
        const e = window.location.hostname;
        if (!Wh(e)) return new Mh({
          message: "".concat(window.location.hostname, " is an invalid domain"),
          code: "ERROR_INVALID_DOMAIN",
          cause: t
        });
        if (o.rp.id !== e) return new Mh({
          message: 'The RP ID "'.concat(o.rp.id, '" is invalid for this domain'),
          code: "ERROR_INVALID_RP_ID",
          cause: t
        })
      } else if ("TypeError" === t.name) {
        if (o.user.id.byteLength < 1 || o.user.id.byteLength > 64) return new Mh({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: t
        })
      } else if ("UnknownError" === t.name) return new Mh({
        message: "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: t
      })
    }
    return new Mh({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: t
    })
  }

  function Nh(e) {
    let {
      error: t,
      options: n
    } = e;
    const {
      publicKey: r
    } = n;
    if (!r) throw Error("options was missing required publicKey property");
    if ("AbortError" === t.name) {
      if (n.signal instanceof AbortSignal) return new Mh({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: t
      })
    } else {
      if ("NotAllowedError" === t.name) return new Mh({
        message: t.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
      });
      if ("SecurityError" === t.name) {
        const e = window.location.hostname;
        if (!Wh(e)) return new Mh({
          message: "".concat(window.location.hostname, " is an invalid domain"),
          code: "ERROR_INVALID_DOMAIN",
          cause: t
        });
        if (r.rpId !== e) return new Mh({
          message: 'The RP ID "'.concat(r.rpId, '" is invalid for this domain'),
          code: "ERROR_INVALID_RP_ID",
          cause: t
        })
      } else if ("UnknownError" === t.name) return new Mh({
        message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: t
      })
    }
    return new Mh({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: t
    })
  }
  var Ih = function(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
    }
    return n
  };
  const Dh = new class {
    createNewAbortSignal() {
      if (this.controller) {
        const e = new Error("Cancelling existing WebAuthn API call for new one");
        e.name = "AbortError", this.controller.abort(e)
      }
      const e = new AbortController;
      return this.controller = e, e.signal
    }
    cancelCeremony() {
      if (this.controller) {
        const e = new Error("Manually cancelling existing WebAuthn API call");
        e.name = "AbortError", this.controller.abort(e), this.controller = void 0
      }
    }
  };

  function zh(e) {
    if (!e) throw new Error("Credential creation options are required");
    if ("undefined" !== typeof PublicKeyCredential && "parseCreationOptionsFromJSON" in PublicKeyCredential && "function" === typeof PublicKeyCredential.parseCreationOptionsFromJSON) return PublicKeyCredential.parseCreationOptionsFromJSON(e);
    const {
      challenge: t,
      user: n,
      excludeCredentials: r
    } = e, i = Ih(e, ["challenge", "user", "excludeCredentials"]), s = Ku(t).buffer, o = Object.assign(Object.assign({}, n), {
      id: Ku(n.id).buffer
    }), a = Object.assign(Object.assign({}, i), {
      challenge: s,
      user: o
    });
    if (r && r.length > 0) {
      a.excludeCredentials = new Array(r.length);
      for (let e = 0; e < r.length; e++) {
        const t = r[e];
        a.excludeCredentials[e] = Object.assign(Object.assign({}, t), {
          id: Ku(t.id).buffer,
          type: t.type || "public-key",
          transports: t.transports
        })
      }
    }
    return a
  }

  function Fh(e) {
    if (!e) throw new Error("Credential request options are required");
    if ("undefined" !== typeof PublicKeyCredential && "parseRequestOptionsFromJSON" in PublicKeyCredential && "function" === typeof PublicKeyCredential.parseRequestOptionsFromJSON) return PublicKeyCredential.parseRequestOptionsFromJSON(e);
    const {
      challenge: t,
      allowCredentials: n
    } = e, r = Ih(e, ["challenge", "allowCredentials"]), i = Ku(t).buffer, s = Object.assign(Object.assign({}, r), {
      challenge: i
    });
    if (n && n.length > 0) {
      s.allowCredentials = new Array(n.length);
      for (let e = 0; e < n.length; e++) {
        const t = n[e];
        s.allowCredentials[e] = Object.assign(Object.assign({}, t), {
          id: Ku(t.id).buffer,
          type: t.type || "public-key",
          transports: t.transports
        })
      }
    }
    return s
  }

  function Bh(e) {
    var t;
    if ("toJSON" in e && "function" === typeof e.toJSON) return e.toJSON();
    const n = e;
    return {
      id: e.id,
      rawId: e.id,
      response: {
        attestationObject: $u(new Uint8Array(e.response.attestationObject)),
        clientDataJSON: $u(new Uint8Array(e.response.clientDataJSON))
      },
      type: "public-key",
      clientExtensionResults: e.getClientExtensionResults(),
      authenticatorAttachment: null !== (t = n.authenticatorAttachment) && void 0 !== t ? t : void 0
    }
  }

  function Uh(e) {
    var t;
    if ("toJSON" in e && "function" === typeof e.toJSON) return e.toJSON();
    const n = e,
      r = e.getClientExtensionResults(),
      i = e.response;
    return {
      id: e.id,
      rawId: e.id,
      response: {
        authenticatorData: $u(new Uint8Array(i.authenticatorData)),
        clientDataJSON: $u(new Uint8Array(i.clientDataJSON)),
        signature: $u(new Uint8Array(i.signature)),
        userHandle: i.userHandle ? $u(new Uint8Array(i.userHandle)) : void 0
      },
      type: "public-key",
      clientExtensionResults: r,
      authenticatorAttachment: null !== (t = n.authenticatorAttachment) && void 0 !== t ? t : void 0
    }
  }

  function Wh(e) {
    return "localhost" === e || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)
  }

  function Hh() {
    var e, t;
    return !!(Yu() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && "function" === typeof(null === (e = null === navigator || void 0 === navigator ? void 0 : navigator.credentials) || void 0 === e ? void 0 : e.create) && "function" === typeof(null === (t = null === navigator || void 0 === navigator ? void 0 : navigator.credentials) || void 0 === t ? void 0 : t.get))
  }
  const Vh = {
      hints: ["security-key"],
      authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: !1,
        userVerification: "preferred",
        residentKey: "discouraged"
      },
      attestation: "none"
    },
    qh = {
      userVerification: "preferred",
      hints: ["security-key"]
    };

  function Kh() {
    const e = e => null !== e && "object" === typeof e && !Array.isArray(e),
      t = e => e instanceof ArrayBuffer || ArrayBuffer.isView(e),
      n = {};
    for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
    for (const o of i)
      if (o)
        for (const r in o) {
          const i = o[r];
          if (void 0 !== i)
            if (Array.isArray(i)) n[r] = i;
            else if (t(i)) n[r] = i;
          else if (e(i)) {
            const t = n[r];
            e(t) ? n[r] = Kh(t, i) : n[r] = Kh(i)
          } else n[r] = i
        }
    return n
  }
  class $h {
    constructor(e) {
      this.client = e, this.enroll = this._enroll.bind(this), this.challenge = this._challenge.bind(this), this.verify = this._verify.bind(this), this.authenticate = this._authenticate.bind(this), this.register = this._register.bind(this)
    }
    async _enroll(e) {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, e), {
        factorType: "webauthn"
      }))
    }
    async _challenge(e, t) {
      let {
        factorId: n,
        webauthn: r,
        friendlyName: i,
        signal: s
      } = e;
      try {
        const {
          data: e,
          error: o
        } = await this.client.mfa.challenge({
          factorId: n,
          webauthn: r
        });
        if (!e) return {
          data: null,
          error: o
        };
        const a = null !== s && void 0 !== s ? s : Dh.createNewAbortSignal();
        if ("create" === e.webauthn.type) {
          const {
            user: t
          } = e.webauthn.credential_options.publicKey;
          t.name || (t.name = "".concat(t.id, ":").concat(i)), t.displayName || (t.displayName = t.name)
        }
        switch (e.webauthn.type) {
          case "create": {
            const r = function(e, t) {
                return Kh(Vh, e, t || {})
              }(e.webauthn.credential_options.publicKey, null === t || void 0 === t ? void 0 : t.create),
              {
                data: i,
                error: s
              } = await async function(e) {
                try {
                  const t = await navigator.credentials.create(e);
                  return t ? t instanceof PublicKeyCredential ? {
                    data: t,
                    error: null
                  } : {
                    data: null,
                    error: new Lh("Browser returned unexpected credential type", t)
                  } : {
                    data: null,
                    error: new Lh("Empty credential response", t)
                  }
                } catch (t) {
                  return {
                    data: null,
                    error: jh({
                      error: t,
                      options: e
                    })
                  }
                }
              }({
                publicKey: r,
                signal: a
              });
            return i ? {
              data: {
                factorId: n,
                challengeId: e.id,
                webauthn: {
                  type: e.webauthn.type,
                  credential_response: i
                }
              },
              error: null
            } : {
              data: null,
              error: s
            }
          }
          case "request": {
            const r = function(e, t) {
                return Kh(qh, e, t || {})
              }(e.webauthn.credential_options.publicKey, null === t || void 0 === t ? void 0 : t.request),
              {
                data: i,
                error: s
              } = await async function(e) {
                try {
                  const t = await navigator.credentials.get(e);
                  return t ? t instanceof PublicKeyCredential ? {
                    data: t,
                    error: null
                  } : {
                    data: null,
                    error: new Lh("Browser returned unexpected credential type", t)
                  } : {
                    data: null,
                    error: new Lh("Empty credential response", t)
                  }
                } catch (t) {
                  return {
                    data: null,
                    error: Nh({
                      error: t,
                      options: e
                    })
                  }
                }
              }(Object.assign(Object.assign({}, e.webauthn.credential_options), {
                publicKey: r,
                signal: a
              }));
            return i ? {
              data: {
                factorId: n,
                challengeId: e.id,
                webauthn: {
                  type: e.webauthn.type,
                  credential_response: i
                }
              },
              error: null
            } : {
              data: null,
              error: s
            }
          }
        }
      } catch (o) {
        return Eu(o) ? {
          data: null,
          error: o
        } : {
          data: null,
          error: new Cu("Unexpected error in challenge", o)
        }
      }
    }
    async _verify(e) {
      let {
        challengeId: t,
        factorId: n,
        webauthn: r
      } = e;
      return this.client.mfa.verify({
        factorId: n,
        challengeId: t,
        webauthn: r
      })
    }
    async _authenticate(e, t) {
      let {
        factorId: n,
        webauthn: {
          rpId: r = ("undefined" !== typeof window ? window.location.hostname : void 0),
          rpOrigins: i = ("undefined" !== typeof window ? [window.location.origin] : void 0),
          signal: s
        }
      } = e;
      if (!r) return {
        data: null,
        error: new Su("rpId is required for WebAuthn authentication")
      };
      try {
        if (!Hh()) return {
          data: null,
          error: new Cu("Browser does not support WebAuthn", null)
        };
        const {
          data: e,
          error: o
        } = await this.challenge({
          factorId: n,
          webauthn: {
            rpId: r,
            rpOrigins: i
          },
          signal: s
        }, {
          request: t
        });
        if (!e) return {
          data: null,
          error: o
        };
        const {
          webauthn: a
        } = e;
        return this._verify({
          factorId: n,
          challengeId: e.challengeId,
          webauthn: {
            type: a.type,
            rpId: r,
            rpOrigins: i,
            credential_response: a.credential_response
          }
        })
      } catch (o) {
        return Eu(o) ? {
          data: null,
          error: o
        } : {
          data: null,
          error: new Cu("Unexpected error in authenticate", o)
        }
      }
    }
    async _register(e, t) {
      let {
        friendlyName: n,
        rpId: r = ("undefined" !== typeof window ? window.location.hostname : void 0),
        rpOrigins: i = ("undefined" !== typeof window ? [window.location.origin] : void 0),
        signal: s
      } = e;
      if (!r) return {
        data: null,
        error: new Su("rpId is required for WebAuthn registration")
      };
      try {
        if (!Hh()) return {
          data: null,
          error: new Cu("Browser does not support WebAuthn", null)
        };
        const {
          data: e,
          error: o
        } = await this._enroll({
          friendlyName: n
        });
        if (!e) return await this.client.mfa.listFactors().then(e => {
          var t;
          return null === (t = e.data) || void 0 === t ? void 0 : t.all.find(e => "webauthn" === e.factor_type && e.friendly_name === n && "unverified" !== e.status)
        }).then(e => e ? this.client.mfa.unenroll({
          factorId: null === e || void 0 === e ? void 0 : e.id
        }) : void 0), {
          data: null,
          error: o
        };
        const {
          data: a,
          error: l
        } = await this._challenge({
          factorId: e.id,
          friendlyName: e.friendly_name,
          webauthn: {
            rpId: r,
            rpOrigins: i
          },
          signal: s
        }, {
          create: t
        });
        return a ? this._verify({
          factorId: e.id,
          challengeId: a.challengeId,
          webauthn: {
            rpId: r,
            rpOrigins: i,
            type: a.webauthn.type,
            credential_response: a.webauthn.credential_response
          }
        }) : {
          data: null,
          error: l
        }
      } catch (o) {
        return Eu(o) ? {
          data: null,
          error: o
        } : {
          data: null,
          error: new Cu("Unexpected error in register", o)
        }
      }
    }
  }! function() {
    if ("object" !== typeof globalThis) try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function() {
          return this
        },
        configurable: !0
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__
    } catch (Lf) {
      "undefined" !== typeof self && (self.globalThis = self)
    }
  }();
  const Yh = {
    url: "http://localhost:9999",
    storageKey: "supabase.auth.token",
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: wu,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1
  };
  async function Jh(e, t, n) {
    return await n()
  }
  const Gh = {};
  class Qh {
    get jwks() {
      var e, t;
      return null !== (t = null === (e = Gh[this.storageKey]) || void 0 === e ? void 0 : e.jwks) && void 0 !== t ? t : {
        keys: []
      }
    }
    set jwks(e) {
      Gh[this.storageKey] = Object.assign(Object.assign({}, Gh[this.storageKey]), {
        jwks: e
      })
    }
    get jwks_cached_at() {
      var e, t;
      return null !== (t = null === (e = Gh[this.storageKey]) || void 0 === e ? void 0 : e.cachedAt) && void 0 !== t ? t : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
      Gh[this.storageKey] = Object.assign(Object.assign({}, Gh[this.storageKey]), {
        cachedAt: e
      })
    }
    constructor(e) {
      var t, n;
      this.userStorage = null, this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Qh.nextInstanceID, Qh.nextInstanceID += 1, this.instanceID > 0 && Yu() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
      const r = Object.assign(Object.assign({}, Yh), e);
      if (this.logDebugMessages = !!r.debug, "function" === typeof r.debug && (this.logger = r.debug), this.persistSession = r.persistSession, this.storageKey = r.storageKey, this.autoRefreshToken = r.autoRefreshToken, this.admin = new Sh({
          url: r.url,
          headers: r.headers,
          fetch: r.fetch
        }), this.url = r.url, this.headers = r.headers, this.fetch = Qu(r.fetch), this.lock = r.lock || Jh, this.detectSessionInUrl = r.detectSessionInUrl, this.flowType = r.flowType, this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader, r.lock ? this.lock = r.lock : Yu() && (null === (t = null === globalThis || void 0 === globalThis ? void 0 : globalThis.navigator) || void 0 === t ? void 0 : t.locks) ? this.lock = Ph : this.lock = Jh, this.jwks || (this.jwks = {
          keys: []
        }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER), this.mfa = {
          verify: this._verify.bind(this),
          enroll: this._enroll.bind(this),
          unenroll: this._unenroll.bind(this),
          challenge: this._challenge.bind(this),
          listFactors: this._listFactors.bind(this),
          challengeAndVerify: this._challengeAndVerify.bind(this),
          getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
          webauthn: new $h(this)
        }, this.persistSession ? (r.storage ? this.storage = r.storage : Gu() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = Eh(this.memoryStorage)), r.userStorage && (this.userStorage = r.userStorage)) : (this.memoryStorage = {}, this.storage = Eh(this.memoryStorage)), Yu() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
          this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
        } catch (Lf) {
          console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", Lf)
        }
        null === (n = this.broadcastChannel) || void 0 === n || n.addEventListener("message", async e => {
          this._debug("received broadcast notification from other tab or client", e), await this._notifyAllSubscribers(e.data.event, e.data.session, !1)
        })
      }
      this.initialize()
    }
    _debug() {
      if (this.logDebugMessages) {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        this.logger("GoTrueClient@".concat(this.instanceID, " (").concat(yu, ") ").concat((new Date).toISOString()), ...t)
      }
      return this
    }
    async initialize() {
      return this.initializePromise || (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))()), await this.initializePromise
    }
    async _initialize() {
      var e;
      try {
        const t = function(e) {
          const t = {},
            n = new URL(e);
          if (n.hash && "#" === n.hash[0]) try {
            new URLSearchParams(n.hash.substring(1)).forEach((e, n) => {
              t[n] = e
            })
          } catch (Lf) {}
          return n.searchParams.forEach((e, n) => {
            t[n] = e
          }), t
        }(window.location.href);
        let n = "none";
        if (this._isImplicitGrantCallback(t) ? n = "implicit" : await this._isPKCECallback(t) && (n = "pkce"), Yu() && this.detectSessionInUrl && "none" !== n) {
          const {
            data: r,
            error: i
          } = await this._getSessionFromURL(t, n);
          if (i) {
            if (this._debug("#_initialize()", "error detecting session from URL", i), function(e) {
                return Eu(e) && "AuthImplicitGrantRedirectError" === e.name
              }(i)) {
              const t = null === (e = i.details) || void 0 === e ? void 0 : e.code;
              if ("identity_already_exists" === t || "identity_not_found" === t || "single_identity_not_deletable" === t) return {
                error: i
              }
            }
            return await this._removeSession(), {
              error: i
            }
          }
          const {
            session: s,
            redirectType: o
          } = r;
          return this._debug("#_initialize()", "detected session in URL", s, "redirect type", o), await this._saveSession(s), setTimeout(async () => {
            "recovery" === o ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", s) : await this._notifyAllSubscribers("SIGNED_IN", s)
          }, 0), {
            error: null
          }
        }
        return await this._recoverAndRefresh(), {
          error: null
        }
      } catch (t) {
        return Eu(t) ? {
          error: t
        } : {
          error: new Cu("Unexpected error during initialization", t)
        }
      } finally {
        await this._handleVisibilityChange(), this._debug("#_initialize()", "end")
      }
    }
    async signInAnonymously(e) {
      var t, n, r;
      try {
        const i = await gh(this.fetch, "POST", "".concat(this.url, "/signup"), {
            headers: this.headers,
            body: {
              data: null !== (n = null === (t = null === e || void 0 === e ? void 0 : e.options) || void 0 === t ? void 0 : t.data) && void 0 !== n ? n : {},
              gotrue_meta_security: {
                captcha_token: null === (r = null === e || void 0 === e ? void 0 : e.options) || void 0 === r ? void 0 : r.captchaToken
              }
            },
            xform: mh
          }),
          {
            data: s,
            error: o
          } = i;
        if (o || !s) return {
          data: {
            user: null,
            session: null
          },
          error: o
        };
        const a = s.session,
          l = s.user;
        return s.session && (await this._saveSession(s.session), await this._notifyAllSubscribers("SIGNED_IN", a)), {
          data: {
            user: l,
            session: a
          },
          error: null
        }
      } catch (i) {
        if (Eu(i)) return {
          data: {
            user: null,
            session: null
          },
          error: i
        };
        throw i
      }
    }
    async signUp(e) {
      var t, n, r;
      try {
        let i;
        if ("email" in e) {
          const {
            email: n,
            password: r,
            options: s
          } = e;
          let o = null,
            a = null;
          "pkce" === this.flowType && ([o, a] = await sh(this.storage, this.storageKey)), i = await gh(this.fetch, "POST", "".concat(this.url, "/signup"), {
            headers: this.headers,
            redirectTo: null === s || void 0 === s ? void 0 : s.emailRedirectTo,
            body: {
              email: n,
              password: r,
              data: null !== (t = null === s || void 0 === s ? void 0 : s.data) && void 0 !== t ? t : {},
              gotrue_meta_security: {
                captcha_token: null === s || void 0 === s ? void 0 : s.captchaToken
              },
              code_challenge: o,
              code_challenge_method: a
            },
            xform: mh
          })
        } else {
          if (!("phone" in e)) throw new Ru("You must provide either an email or phone number and a password");
          {
            const {
              phone: t,
              password: s,
              options: o
            } = e;
            i = await gh(this.fetch, "POST", "".concat(this.url, "/signup"), {
              headers: this.headers,
              body: {
                phone: t,
                password: s,
                data: null !== (n = null === o || void 0 === o ? void 0 : o.data) && void 0 !== n ? n : {},
                channel: null !== (r = null === o || void 0 === o ? void 0 : o.channel) && void 0 !== r ? r : "sms",
                gotrue_meta_security: {
                  captcha_token: null === o || void 0 === o ? void 0 : o.captchaToken
                }
              },
              xform: mh
            })
          }
        }
        const {
          data: s,
          error: o
        } = i;
        if (o || !s) return {
          data: {
            user: null,
            session: null
          },
          error: o
        };
        const a = s.session,
          l = s.user;
        return s.session && (await this._saveSession(s.session), await this._notifyAllSubscribers("SIGNED_IN", a)), {
          data: {
            user: l,
            session: a
          },
          error: null
        }
      } catch (i) {
        if (Eu(i)) return {
          data: {
            user: null,
            session: null
          },
          error: i
        };
        throw i
      }
    }
    async signInWithPassword(e) {
      try {
        let t;
        if ("email" in e) {
          const {
            email: n,
            password: r,
            options: i
          } = e;
          t = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=password"), {
            headers: this.headers,
            body: {
              email: n,
              password: r,
              gotrue_meta_security: {
                captcha_token: null === i || void 0 === i ? void 0 : i.captchaToken
              }
            },
            xform: yh
          })
        } else {
          if (!("phone" in e)) throw new Ru("You must provide either an email or phone number and a password");
          {
            const {
              phone: n,
              password: r,
              options: i
            } = e;
            t = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=password"), {
              headers: this.headers,
              body: {
                phone: n,
                password: r,
                gotrue_meta_security: {
                  captcha_token: null === i || void 0 === i ? void 0 : i.captchaToken
                }
              },
              xform: yh
            })
          }
        }
        const {
          data: n,
          error: r
        } = t;
        return r ? {
          data: {
            user: null,
            session: null
          },
          error: r
        } : n && n.session && n.user ? (n.session && (await this._saveSession(n.session), await this._notifyAllSubscribers("SIGNED_IN", n.session)), {
          data: Object.assign({
            user: n.user,
            session: n.session
          }, n.weak_password ? {
            weakPassword: n.weak_password
          } : null),
          error: r
        }) : {
          data: {
            user: null,
            session: null
          },
          error: new Au
        }
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null,
            session: null
          },
          error: t
        };
        throw t
      }
    }
    async signInWithOAuth(e) {
      var t, n, r, i;
      return await this._handleProviderSignIn(e.provider, {
        redirectTo: null === (t = e.options) || void 0 === t ? void 0 : t.redirectTo,
        scopes: null === (n = e.options) || void 0 === n ? void 0 : n.scopes,
        queryParams: null === (r = e.options) || void 0 === r ? void 0 : r.queryParams,
        skipBrowserRedirect: null === (i = e.options) || void 0 === i ? void 0 : i.skipBrowserRedirect
      })
    }
    async exchangeCodeForSession(e) {
      return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
      const {
        chain: t
      } = e;
      switch (t) {
        case "ethereum":
          return await this.signInWithEthereum(e);
        case "solana":
          return await this.signInWithSolana(e);
        default:
          throw new Error('@supabase/auth-js: Unsupported chain "'.concat(t, '"'))
      }
    }
    async signInWithEthereum(e) {
      var t, n, r, i, s, o, a, l, c, u, h;
      let d, f;
      if ("message" in e) d = e.message, f = e.signature;
      else {
        const {
          chain: u,
          wallet: h,
          statement: p,
          options: g
        } = e;
        let m;
        if (Yu())
          if ("object" === typeof h) m = h;
          else {
            const e = window;
            if (!("ethereum" in e) || "object" !== typeof e.ethereum || !("request" in e.ethereum) || "function" !== typeof e.ethereum.request) throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.");
            m = e.ethereum
          }
        else {
          if ("object" !== typeof h || !(null === g || void 0 === g ? void 0 : g.url)) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          m = h
        }
        const y = new URL(null !== (t = null === g || void 0 === g ? void 0 : g.url) && void 0 !== t ? t : window.location.href),
          v = await m.request({
            method: "eth_requestAccounts"
          }).then(e => e).catch(() => {
            throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
          });
        if (!v || 0 === v.length) throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
        const b = Ah(v[0]);
        let w = null === (n = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === n ? void 0 : n.chainId;
        if (!w) {
          w = function(e) {
            return parseInt(e, 16)
          }(await m.request({
            method: "eth_chainId"
          }))
        }
        d = function(e) {
          var t;
          const {
            chainId: n,
            domain: r,
            expirationTime: i,
            issuedAt: s = new Date,
            nonce: o,
            notBefore: a,
            requestId: l,
            resources: c,
            scheme: u,
            uri: h,
            version: d
          } = e;
          if (!Number.isInteger(n)) throw new Error('@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: '.concat(n));
          if (!r) throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
          if (o && o.length < 8) throw new Error('@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: '.concat(o));
          if (!h) throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
          if ("1" !== d) throw new Error("@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ".concat(d));
          if (null === (t = e.statement) || void 0 === t ? void 0 : t.includes("\n")) throw new Error("@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\n'. Provided value: ".concat(e.statement));
          const f = Ah(e.address),
            p = u ? "".concat(u, "://").concat(r) : r,
            g = e.statement ? "".concat(e.statement, "\n") : "",
            m = "".concat(p, " wants you to sign in with your Ethereum account:\n").concat(f, "\n\n").concat(g);
          let y = "URI: ".concat(h, "\nVersion: ").concat(d, "\nChain ID: ").concat(n).concat(o ? "\nNonce: ".concat(o) : "", "\nIssued At: ").concat(s.toISOString());
          if (i && (y += "\nExpiration Time: ".concat(i.toISOString())), a && (y += "\nNot Before: ".concat(a.toISOString())), l && (y += "\nRequest ID: ".concat(l)), c) {
            let e = "\nResources:";
            for (const t of c) {
              if (!t || "string" !== typeof t) throw new Error('@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: '.concat(t));
              e += "\n- ".concat(t)
            }
            y += e
          }
          return "".concat(m, "\n").concat(y)
        }({
          domain: y.host,
          address: b,
          statement: p,
          uri: y.href,
          version: "1",
          chainId: w,
          nonce: null === (r = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === r ? void 0 : r.nonce,
          issuedAt: null !== (s = null === (i = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === i ? void 0 : i.issuedAt) && void 0 !== s ? s : new Date,
          expirationTime: null === (o = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === o ? void 0 : o.expirationTime,
          notBefore: null === (a = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === a ? void 0 : a.notBefore,
          requestId: null === (l = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === l ? void 0 : l.requestId,
          resources: null === (c = null === g || void 0 === g ? void 0 : g.signInWithEthereum) || void 0 === c ? void 0 : c.resources
        }), f = await m.request({
          method: "personal_sign",
          params: [Rh(d), b]
        })
      }
      try {
        const {
          data: t,
          error: n
        } = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=web3"), {
          headers: this.headers,
          body: Object.assign({
            chain: "ethereum",
            message: d,
            signature: f
          }, (null === (u = e.options) || void 0 === u ? void 0 : u.captchaToken) ? {
            gotrue_meta_security: {
              captcha_token: null === (h = e.options) || void 0 === h ? void 0 : h.captchaToken
            }
          } : null),
          xform: mh
        });
        if (n) throw n;
        return t && t.session && t.user ? (t.session && (await this._saveSession(t.session), await this._notifyAllSubscribers("SIGNED_IN", t.session)), {
          data: Object.assign({}, t),
          error: n
        }) : {
          data: {
            user: null,
            session: null
          },
          error: new Au
        }
      } catch (p) {
        if (Eu(p)) return {
          data: {
            user: null,
            session: null
          },
          error: p
        };
        throw p
      }
    }
    async signInWithSolana(e) {
      var t, n, r, i, s, o, a, l, c, u, h, d;
      let f, p;
      if ("message" in e) f = e.message, p = e.signature;
      else {
        const {
          chain: h,
          wallet: d,
          statement: g,
          options: m
        } = e;
        let y;
        if (Yu())
          if ("object" === typeof d) y = d;
          else {
            const e = window;
            if (!("solana" in e) || "object" !== typeof e.solana || !("signIn" in e.solana && "function" === typeof e.solana.signIn || "signMessage" in e.solana && "function" === typeof e.solana.signMessage)) throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.");
            y = e.solana
          }
        else {
          if ("object" !== typeof d || !(null === m || void 0 === m ? void 0 : m.url)) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          y = d
        }
        const v = new URL(null !== (t = null === m || void 0 === m ? void 0 : m.url) && void 0 !== t ? t : window.location.href);
        if ("signIn" in y && y.signIn) {
          const e = await y.signIn(Object.assign(Object.assign(Object.assign({
            issuedAt: (new Date).toISOString()
          }, null === m || void 0 === m ? void 0 : m.signInWithSolana), {
            version: "1",
            domain: v.host,
            uri: v.href
          }), g ? {
            statement: g
          } : null));
          let t;
          if (Array.isArray(e) && e[0] && "object" === typeof e[0]) t = e[0];
          else {
            if (!(e && "object" === typeof e && "signedMessage" in e && "signature" in e)) throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
            t = e
          }
          if (!("signedMessage" in t && "signature" in t && ("string" === typeof t.signedMessage || t.signedMessage instanceof Uint8Array) && t.signature instanceof Uint8Array)) throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          f = "string" === typeof t.signedMessage ? t.signedMessage : (new TextDecoder).decode(t.signedMessage), p = t.signature
        } else {
          if (!("signMessage" in y) || "function" !== typeof y.signMessage || !("publicKey" in y) || "object" !== typeof y || !y.publicKey || !("toBase58" in y.publicKey) || "function" !== typeof y.publicKey.toBase58) throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          f = ["".concat(v.host, " wants you to sign in with your Solana account:"), y.publicKey.toBase58(), ...g ? ["", g, ""] : [""], "Version: 1", "URI: ".concat(v.href), "Issued At: ".concat(null !== (r = null === (n = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === n ? void 0 : n.issuedAt) && void 0 !== r ? r : (new Date).toISOString()), ...(null === (i = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === i ? void 0 : i.notBefore) ? ["Not Before: ".concat(m.signInWithSolana.notBefore)] : [], ...(null === (s = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === s ? void 0 : s.expirationTime) ? ["Expiration Time: ".concat(m.signInWithSolana.expirationTime)] : [], ...(null === (o = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === o ? void 0 : o.chainId) ? ["Chain ID: ".concat(m.signInWithSolana.chainId)] : [], ...(null === (a = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === a ? void 0 : a.nonce) ? ["Nonce: ".concat(m.signInWithSolana.nonce)] : [], ...(null === (l = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === l ? void 0 : l.requestId) ? ["Request ID: ".concat(m.signInWithSolana.requestId)] : [], ...(null === (u = null === (c = null === m || void 0 === m ? void 0 : m.signInWithSolana) || void 0 === c ? void 0 : c.resources) || void 0 === u ? void 0 : u.length) ? ["Resources", ...m.signInWithSolana.resources.map(e => "- ".concat(e))] : []].join("\n");
          const e = await y.signMessage((new TextEncoder).encode(f), "utf8");
          if (!e || !(e instanceof Uint8Array)) throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          p = e
        }
      }
      try {
        const {
          data: t,
          error: n
        } = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=web3"), {
          headers: this.headers,
          body: Object.assign({
            chain: "solana",
            message: f,
            signature: $u(p)
          }, (null === (h = e.options) || void 0 === h ? void 0 : h.captchaToken) ? {
            gotrue_meta_security: {
              captcha_token: null === (d = e.options) || void 0 === d ? void 0 : d.captchaToken
            }
          } : null),
          xform: mh
        });
        if (n) throw n;
        return t && t.session && t.user ? (t.session && (await this._saveSession(t.session), await this._notifyAllSubscribers("SIGNED_IN", t.session)), {
          data: Object.assign({}, t),
          error: n
        }) : {
          data: {
            user: null,
            session: null
          },
          error: new Au
        }
      } catch (g) {
        if (Eu(g)) return {
          data: {
            user: null,
            session: null
          },
          error: g
        };
        throw g
      }
    }
    async _exchangeCodeForSession(e) {
      const t = await Zu(this.storage, "".concat(this.storageKey, "-code-verifier")),
        [n, r] = (null !== t && void 0 !== t ? t : "").split("/");
      try {
        const {
          data: t,
          error: i
        } = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=pkce"), {
          headers: this.headers,
          body: {
            auth_code: e,
            code_verifier: n
          },
          xform: mh
        });
        if (await eh(this.storage, "".concat(this.storageKey, "-code-verifier")), i) throw i;
        return t && t.session && t.user ? (t.session && (await this._saveSession(t.session), await this._notifyAllSubscribers("SIGNED_IN", t.session)), {
          data: Object.assign(Object.assign({}, t), {
            redirectType: null !== r && void 0 !== r ? r : null
          }),
          error: i
        }) : {
          data: {
            user: null,
            session: null,
            redirectType: null
          },
          error: new Au
        }
      } catch (i) {
        if (Eu(i)) return {
          data: {
            user: null,
            session: null,
            redirectType: null
          },
          error: i
        };
        throw i
      }
    }
    async signInWithIdToken(e) {
      try {
        const {
          options: t,
          provider: n,
          token: r,
          access_token: i,
          nonce: s
        } = e, o = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=id_token"), {
          headers: this.headers,
          body: {
            provider: n,
            id_token: r,
            access_token: i,
            nonce: s,
            gotrue_meta_security: {
              captcha_token: null === t || void 0 === t ? void 0 : t.captchaToken
            }
          },
          xform: mh
        }), {
          data: a,
          error: l
        } = o;
        return l ? {
          data: {
            user: null,
            session: null
          },
          error: l
        } : a && a.session && a.user ? (a.session && (await this._saveSession(a.session), await this._notifyAllSubscribers("SIGNED_IN", a.session)), {
          data: a,
          error: l
        }) : {
          data: {
            user: null,
            session: null
          },
          error: new Au
        }
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null,
            session: null
          },
          error: t
        };
        throw t
      }
    }
    async signInWithOtp(e) {
      var t, n, r, i, s;
      try {
        if ("email" in e) {
          const {
            email: r,
            options: i
          } = e;
          let s = null,
            o = null;
          "pkce" === this.flowType && ([s, o] = await sh(this.storage, this.storageKey));
          const {
            error: a
          } = await gh(this.fetch, "POST", "".concat(this.url, "/otp"), {
            headers: this.headers,
            body: {
              email: r,
              data: null !== (t = null === i || void 0 === i ? void 0 : i.data) && void 0 !== t ? t : {},
              create_user: null === (n = null === i || void 0 === i ? void 0 : i.shouldCreateUser) || void 0 === n || n,
              gotrue_meta_security: {
                captcha_token: null === i || void 0 === i ? void 0 : i.captchaToken
              },
              code_challenge: s,
              code_challenge_method: o
            },
            redirectTo: null === i || void 0 === i ? void 0 : i.emailRedirectTo
          });
          return {
            data: {
              user: null,
              session: null
            },
            error: a
          }
        }
        if ("phone" in e) {
          const {
            phone: t,
            options: n
          } = e, {
            data: o,
            error: a
          } = await gh(this.fetch, "POST", "".concat(this.url, "/otp"), {
            headers: this.headers,
            body: {
              phone: t,
              data: null !== (r = null === n || void 0 === n ? void 0 : n.data) && void 0 !== r ? r : {},
              create_user: null === (i = null === n || void 0 === n ? void 0 : n.shouldCreateUser) || void 0 === i || i,
              gotrue_meta_security: {
                captcha_token: null === n || void 0 === n ? void 0 : n.captchaToken
              },
              channel: null !== (s = null === n || void 0 === n ? void 0 : n.channel) && void 0 !== s ? s : "sms"
            }
          });
          return {
            data: {
              user: null,
              session: null,
              messageId: null === o || void 0 === o ? void 0 : o.message_id
            },
            error: a
          }
        }
        throw new Ru("You must provide either an email or phone number.")
      } catch (o) {
        if (Eu(o)) return {
          data: {
            user: null,
            session: null
          },
          error: o
        };
        throw o
      }
    }
    async verifyOtp(e) {
      var t, n;
      try {
        let r, i;
        "options" in e && (r = null === (t = e.options) || void 0 === t ? void 0 : t.redirectTo, i = null === (n = e.options) || void 0 === n ? void 0 : n.captchaToken);
        const {
          data: s,
          error: o
        } = await gh(this.fetch, "POST", "".concat(this.url, "/verify"), {
          headers: this.headers,
          body: Object.assign(Object.assign({}, e), {
            gotrue_meta_security: {
              captcha_token: i
            }
          }),
          redirectTo: r,
          xform: mh
        });
        if (o) throw o;
        if (!s) throw new Error("An error occurred on token verification.");
        const a = s.session,
          l = s.user;
        return (null === a || void 0 === a ? void 0 : a.access_token) && (await this._saveSession(a), await this._notifyAllSubscribers("recovery" == e.type ? "PASSWORD_RECOVERY" : "SIGNED_IN", a)), {
          data: {
            user: l,
            session: a
          },
          error: null
        }
      } catch (r) {
        if (Eu(r)) return {
          data: {
            user: null,
            session: null
          },
          error: r
        };
        throw r
      }
    }
    async signInWithSSO(e) {
      var t, n, r;
      try {
        let i = null,
          s = null;
        return "pkce" === this.flowType && ([i, s] = await sh(this.storage, this.storageKey)), await gh(this.fetch, "POST", "".concat(this.url, "/sso"), {
          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in e ? {
            provider_id: e.providerId
          } : null), "domain" in e ? {
            domain: e.domain
          } : null), {
            redirect_to: null !== (n = null === (t = e.options) || void 0 === t ? void 0 : t.redirectTo) && void 0 !== n ? n : void 0
          }), (null === (r = null === e || void 0 === e ? void 0 : e.options) || void 0 === r ? void 0 : r.captchaToken) ? {
            gotrue_meta_security: {
              captcha_token: e.options.captchaToken
            }
          } : null), {
            skip_http_redirect: !0,
            code_challenge: i,
            code_challenge_method: s
          }),
          headers: this.headers,
          xform: bh
        })
      } catch (i) {
        if (Eu(i)) return {
          data: null,
          error: i
        };
        throw i
      }
    }
    async reauthenticate() {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
      try {
        return await this._useSession(async e => {
          const {
            data: {
              session: t
            },
            error: n
          } = e;
          if (n) throw n;
          if (!t) throw new Pu;
          const {
            error: r
          } = await gh(this.fetch, "GET", "".concat(this.url, "/reauthenticate"), {
            headers: this.headers,
            jwt: t.access_token
          });
          return {
            data: {
              user: null,
              session: null
            },
            error: r
          }
        })
      } catch (e) {
        if (Eu(e)) return {
          data: {
            user: null,
            session: null
          },
          error: e
        };
        throw e
      }
    }
    async resend(e) {
      try {
        const t = "".concat(this.url, "/resend");
        if ("email" in e) {
          const {
            email: n,
            type: r,
            options: i
          } = e, {
            error: s
          } = await gh(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              email: n,
              type: r,
              gotrue_meta_security: {
                captcha_token: null === i || void 0 === i ? void 0 : i.captchaToken
              }
            },
            redirectTo: null === i || void 0 === i ? void 0 : i.emailRedirectTo
          });
          return {
            data: {
              user: null,
              session: null
            },
            error: s
          }
        }
        if ("phone" in e) {
          const {
            phone: n,
            type: r,
            options: i
          } = e, {
            data: s,
            error: o
          } = await gh(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              phone: n,
              type: r,
              gotrue_meta_security: {
                captcha_token: null === i || void 0 === i ? void 0 : i.captchaToken
              }
            }
          });
          return {
            data: {
              user: null,
              session: null,
              messageId: null === s || void 0 === s ? void 0 : s.message_id
            },
            error: o
          }
        }
        throw new Ru("You must provide either an email or phone number and a type")
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null,
            session: null
          },
          error: t
        };
        throw t
      }
    }
    async getSession() {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => this._useSession(async e => e))
    }
    async _acquireLock(e, t) {
      this._debug("#_acquireLock", "begin", e);
      try {
        if (this.lockAcquired) {
          const e = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(),
            n = (async () => (await e, await t()))();
          return this.pendingInLock.push((async () => {
            try {
              await n
            } catch (Lf) {}
          })()), n
        }
        return await this.lock("lock:".concat(this.storageKey), e, async () => {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = !0;
            const e = t();
            for (this.pendingInLock.push((async () => {
                try {
                  await e
                } catch (Lf) {}
              })()), await e; this.pendingInLock.length;) {
              const e = [...this.pendingInLock];
              await Promise.all(e), this.pendingInLock.splice(0, e.length)
            }
            return await e
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1
          }
        })
      } finally {
        this._debug("#_acquireLock", "end")
      }
    }
    async _useSession(e) {
      this._debug("#_useSession", "begin");
      try {
        const t = await this.__loadSession();
        return await e(t)
      } finally {
        this._debug("#_useSession", "end")
      }
    }
    async __loadSession() {
      this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", (new Error).stack);
      try {
        let e = null;
        const t = await Zu(this.storage, this.storageKey);
        if (this._debug("#getSession()", "session from storage", t), null !== t && (this._isValidSession(t) ? e = t : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !e) return {
          data: {
            session: null
          },
          error: null
        };
        const n = !!e.expires_at && 1e3 * e.expires_at - Date.now() < bu;
        if (this._debug("#__loadSession()", "session has".concat(n ? "" : " not", " expired"), "expires_at", e.expires_at), !n) {
          if (this.userStorage) {
            const t = await Zu(this.userStorage, this.storageKey + "-user");
            (null === t || void 0 === t ? void 0 : t.user) ? e.user = t.user: e.user = ch()
          }
          if (this.storage.isServer && e.user) {
            let t = this.suppressGetSessionWarning;
            e = new Proxy(e, {
              get: (e, n, r) => (t || "user" !== n || (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), t = !0, this.suppressGetSessionWarning = !0), Reflect.get(e, n, r))
            })
          }
          return {
            data: {
              session: e
            },
            error: null
          }
        }
        const {
          data: r,
          error: i
        } = await this._callRefreshToken(e.refresh_token);
        return i ? {
          data: {
            session: null
          },
          error: i
        } : {
          data: {
            session: r
          },
          error: null
        }
      } finally {
        this._debug("#__loadSession()", "end")
      }
    }
    async getUser(e) {
      if (e) return await this._getUser(e);
      await this.initializePromise;
      return await this._acquireLock(-1, async () => await this._getUser())
    }
    async _getUser(e) {
      try {
        return e ? await gh(this.fetch, "GET", "".concat(this.url, "/user"), {
          headers: this.headers,
          jwt: e,
          xform: vh
        }) : await this._useSession(async e => {
          var t, n, r;
          const {
            data: i,
            error: s
          } = e;
          if (s) throw s;
          return (null === (t = i.session) || void 0 === t ? void 0 : t.access_token) || this.hasCustomAuthorizationHeader ? await gh(this.fetch, "GET", "".concat(this.url, "/user"), {
            headers: this.headers,
            jwt: null !== (r = null === (n = i.session) || void 0 === n ? void 0 : n.access_token) && void 0 !== r ? r : void 0,
            xform: vh
          }) : {
            data: {
              user: null
            },
            error: new Pu
          }
        })
      } catch (t) {
        if (Eu(t)) return function(e) {
          return Eu(e) && "AuthSessionMissingError" === e.name
        }(t) && (await this._removeSession(), await eh(this.storage, "".concat(this.storageKey, "-code-verifier"))), {
          data: {
            user: null
          },
          error: t
        };
        throw t
      }
    }
    async updateUser(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(e, t))
    }
    async _updateUser(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      try {
        return await this._useSession(async n => {
          const {
            data: r,
            error: i
          } = n;
          if (i) throw i;
          if (!r.session) throw new Pu;
          const s = r.session;
          let o = null,
            a = null;
          "pkce" === this.flowType && null != e.email && ([o, a] = await sh(this.storage, this.storageKey));
          const {
            data: l,
            error: c
          } = await gh(this.fetch, "PUT", "".concat(this.url, "/user"), {
            headers: this.headers,
            redirectTo: null === t || void 0 === t ? void 0 : t.emailRedirectTo,
            body: Object.assign(Object.assign({}, e), {
              code_challenge: o,
              code_challenge_method: a
            }),
            jwt: s.access_token,
            xform: vh
          });
          if (c) throw c;
          return s.user = l.user, await this._saveSession(s), await this._notifyAllSubscribers("USER_UPDATED", s), {
            data: {
              user: s.user
            },
            error: null
          }
        })
      } catch (n) {
        if (Eu(n)) return {
          data: {
            user: null
          },
          error: n
        };
        throw n
      }
    }
    async setSession(e) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(e))
    }
    async _setSession(e) {
      try {
        if (!e.access_token || !e.refresh_token) throw new Pu;
        const t = Date.now() / 1e3;
        let n = t,
          r = !0,
          i = null;
        const {
          payload: s
        } = nh(e.access_token);
        if (s.exp && (n = s.exp, r = n <= t), r) {
          const {
            data: t,
            error: n
          } = await this._callRefreshToken(e.refresh_token);
          if (n) return {
            data: {
              user: null,
              session: null
            },
            error: n
          };
          if (!t) return {
            data: {
              user: null,
              session: null
            },
            error: null
          };
          i = t
        } else {
          const {
            data: r,
            error: s
          } = await this._getUser(e.access_token);
          if (s) throw s;
          i = {
            access_token: e.access_token,
            refresh_token: e.refresh_token,
            user: r.user,
            token_type: "bearer",
            expires_in: n - t,
            expires_at: n
          }, await this._saveSession(i), await this._notifyAllSubscribers("SIGNED_IN", i)
        }
        return {
          data: {
            user: i.user,
            session: i
          },
          error: null
        }
      } catch (t) {
        if (Eu(t)) return {
          data: {
            session: null,
            user: null
          },
          error: t
        };
        throw t
      }
    }
    async refreshSession(e) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
      try {
        return await this._useSession(async t => {
          var n;
          if (!e) {
            const {
              data: r,
              error: i
            } = t;
            if (i) throw i;
            e = null !== (n = r.session) && void 0 !== n ? n : void 0
          }
          if (!(null === e || void 0 === e ? void 0 : e.refresh_token)) throw new Pu;
          const {
            data: r,
            error: i
          } = await this._callRefreshToken(e.refresh_token);
          return i ? {
            data: {
              user: null,
              session: null
            },
            error: i
          } : r ? {
            data: {
              user: r.user,
              session: r
            },
            error: null
          } : {
            data: {
              user: null,
              session: null
            },
            error: null
          }
        })
      } catch (t) {
        if (Eu(t)) return {
          data: {
            user: null,
            session: null
          },
          error: t
        };
        throw t
      }
    }
    async _getSessionFromURL(e, t) {
      try {
        if (!Yu()) throw new Mu("No browser detected.");
        if (e.error || e.error_description || e.error_code) throw new Mu(e.error_description || "Error in URL with unspecified error_description", {
          error: e.error || "unspecified_error",
          code: e.error_code || "unspecified_code"
        });
        switch (t) {
          case "implicit":
            if ("pkce" === this.flowType) throw new Lu("Not a valid PKCE flow url.");
            break;
          case "pkce":
            if ("implicit" === this.flowType) throw new Mu("Not a valid implicit grant flow url.")
        }
        if ("pkce" === t) {
          if (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !e.code) throw new Lu("No code detected.");
          const {
            data: t,
            error: n
          } = await this._exchangeCodeForSession(e.code);
          if (n) throw n;
          const r = new URL(window.location.href);
          return r.searchParams.delete("code"), window.history.replaceState(window.history.state, "", r.toString()), {
            data: {
              session: t.session,
              redirectType: null
            },
            error: null
          }
        }
        const {
          provider_token: n,
          provider_refresh_token: r,
          access_token: i,
          refresh_token: s,
          expires_in: o,
          expires_at: a,
          token_type: l
        } = e;
        if (!i || !o || !s || !l) throw new Mu("No session defined in URL");
        const c = Math.round(Date.now() / 1e3),
          u = parseInt(o);
        let h = c + u;
        a && (h = parseInt(a));
        const d = h - c;
        1e3 * d <= vu && console.warn("@supabase/gotrue-js: Session as retrieved from URL expires in ".concat(d, "s, should have been closer to ").concat(u, "s"));
        const f = h - u;
        c - f >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", f, h, c) : c - f < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", f, h, c);
        const {
          data: p,
          error: g
        } = await this._getUser(i);
        if (g) throw g;
        const m = {
          provider_token: n,
          provider_refresh_token: r,
          access_token: i,
          expires_in: u,
          expires_at: h,
          refresh_token: s,
          token_type: l,
          user: p.user
        };
        return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), {
          data: {
            session: m,
            redirectType: e.type
          },
          error: null
        }
      } catch (n) {
        if (Eu(n)) return {
          data: {
            session: null,
            redirectType: null
          },
          error: n
        };
        throw n
      }
    }
    _isImplicitGrantCallback(e) {
      return Boolean(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
      const t = await Zu(this.storage, "".concat(this.storageKey, "-code-verifier"));
      return !(!e.code || !t)
    }
    async signOut() {
      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        scope: "global"
      };
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(e))
    }
    async _signOut() {
      let {
        scope: e
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        scope: "global"
      };
      return await this._useSession(async t => {
        var n;
        const {
          data: r,
          error: i
        } = t;
        if (i) return {
          error: i
        };
        const s = null === (n = r.session) || void 0 === n ? void 0 : n.access_token;
        if (s) {
          const {
            error: t
          } = await this.admin.signOut(s, e);
          if (t && (! function(e) {
              return Eu(e) && "AuthApiError" === e.name
            }(t) || 404 !== t.status && 401 !== t.status && 403 !== t.status)) return {
            error: t
          }
        }
        return "others" !== e && (await this._removeSession(), await eh(this.storage, "".concat(this.storageKey, "-code-verifier"))), {
          error: null
        }
      })
    }
    onAuthStateChange(e) {
      const t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
          const t = 16 * Math.random() | 0;
          return ("x" == e ? t : 3 & t | 8).toString(16)
        }),
        n = {
          id: t,
          callback: e,
          unsubscribe: () => {
            this._debug("#unsubscribe()", "state change callback with id removed", t), this.stateChangeEmitters.delete(t)
          }
        };
      return this._debug("#onAuthStateChange()", "registered callback with id", t), this.stateChangeEmitters.set(t, n), (async () => {
        await this.initializePromise, await this._acquireLock(-1, async () => {
          this._emitInitialSession(t)
        })
      })(), {
        data: {
          subscription: n
        }
      }
    }
    async _emitInitialSession(e) {
      return await this._useSession(async t => {
        var n, r;
        try {
          const {
            data: {
              session: r
            },
            error: i
          } = t;
          if (i) throw i;
          await (null === (n = this.stateChangeEmitters.get(e)) || void 0 === n ? void 0 : n.callback("INITIAL_SESSION", r)), this._debug("INITIAL_SESSION", "callback id", e, "session", r)
        } catch (i) {
          await (null === (r = this.stateChangeEmitters.get(e)) || void 0 === r ? void 0 : r.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", e, "error", i), console.error(i)
        }
      })
    }
    async resetPasswordForEmail(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = null,
        r = null;
      "pkce" === this.flowType && ([n, r] = await sh(this.storage, this.storageKey, !0));
      try {
        return await gh(this.fetch, "POST", "".concat(this.url, "/recover"), {
          body: {
            email: e,
            code_challenge: n,
            code_challenge_method: r,
            gotrue_meta_security: {
              captcha_token: t.captchaToken
            }
          },
          headers: this.headers,
          redirectTo: t.redirectTo
        })
      } catch (i) {
        if (Eu(i)) return {
          data: null,
          error: i
        };
        throw i
      }
    }
    async getUserIdentities() {
      var e;
      try {
        const {
          data: t,
          error: n
        } = await this.getUser();
        if (n) throw n;
        return {
          data: {
            identities: null !== (e = t.user.identities) && void 0 !== e ? e : []
          },
          error: null
        }
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async linkIdentity(e) {
      return "token" in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e)
    }
    async linkIdentityOAuth(e) {
      var t;
      try {
        const {
          data: n,
          error: r
        } = await this._useSession(async t => {
          var n, r, i, s, o;
          const {
            data: a,
            error: l
          } = t;
          if (l) throw l;
          const c = await this._getUrlForProvider("".concat(this.url, "/user/identities/authorize"), e.provider, {
            redirectTo: null === (n = e.options) || void 0 === n ? void 0 : n.redirectTo,
            scopes: null === (r = e.options) || void 0 === r ? void 0 : r.scopes,
            queryParams: null === (i = e.options) || void 0 === i ? void 0 : i.queryParams,
            skipBrowserRedirect: !0
          });
          return await gh(this.fetch, "GET", c, {
            headers: this.headers,
            jwt: null !== (o = null === (s = a.session) || void 0 === s ? void 0 : s.access_token) && void 0 !== o ? o : void 0
          })
        });
        if (r) throw r;
        return Yu() && !(null === (t = e.options) || void 0 === t ? void 0 : t.skipBrowserRedirect) && window.location.assign(null === n || void 0 === n ? void 0 : n.url), {
          data: {
            provider: e.provider,
            url: null === n || void 0 === n ? void 0 : n.url
          },
          error: null
        }
      } catch (n) {
        if (Eu(n)) return {
          data: {
            provider: e.provider,
            url: null
          },
          error: n
        };
        throw n
      }
    }
    async linkIdentityIdToken(e) {
      return await this._useSession(async t => {
        var n;
        try {
          const {
            error: r,
            data: {
              session: i
            }
          } = t;
          if (r) throw r;
          const {
            options: s,
            provider: o,
            token: a,
            access_token: l,
            nonce: c
          } = e, u = await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=id_token"), {
            headers: this.headers,
            jwt: null !== (n = null === i || void 0 === i ? void 0 : i.access_token) && void 0 !== n ? n : void 0,
            body: {
              provider: o,
              id_token: a,
              access_token: l,
              nonce: c,
              link_identity: !0,
              gotrue_meta_security: {
                captcha_token: null === s || void 0 === s ? void 0 : s.captchaToken
              }
            },
            xform: mh
          }), {
            data: h,
            error: d
          } = u;
          return d ? {
            data: {
              user: null,
              session: null
            },
            error: d
          } : h && h.session && h.user ? (h.session && (await this._saveSession(h.session), await this._notifyAllSubscribers("USER_UPDATED", h.session)), {
            data: h,
            error: d
          }) : {
            data: {
              user: null,
              session: null
            },
            error: new Au
          }
        } catch (r) {
          if (Eu(r)) return {
            data: {
              user: null,
              session: null
            },
            error: r
          };
          throw r
        }
      })
    }
    async unlinkIdentity(e) {
      try {
        return await this._useSession(async t => {
          var n, r;
          const {
            data: i,
            error: s
          } = t;
          if (s) throw s;
          return await gh(this.fetch, "DELETE", "".concat(this.url, "/user/identities/").concat(e.identity_id), {
            headers: this.headers,
            jwt: null !== (r = null === (n = i.session) || void 0 === n ? void 0 : n.access_token) && void 0 !== r ? r : void 0
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _refreshAccessToken(e) {
      const t = "#_refreshAccessToken(".concat(e.substring(0, 5), "...)");
      this._debug(t, "begin");
      try {
        const i = Date.now();
        return await (n = async n => (n > 0 && await async function(e) {
          return await new Promise(t => {
            setTimeout(() => t(null), e)
          })
        }(200 * Math.pow(2, n - 1)), this._debug(t, "refreshing attempt", n), await gh(this.fetch, "POST", "".concat(this.url, "/token?grant_type=refresh_token"), {
          body: {
            refresh_token: e
          },
          headers: this.headers,
          xform: mh
        })), r = (e, t) => {
          const n = 200 * Math.pow(2, e);
          return t && Nu(t) && Date.now() + n - i < vu
        }, new Promise((e, t) => {
          (async () => {
            for (let i = 0; i < 1 / 0; i++) try {
              const t = await n(i);
              if (!r(i, null, t)) return void e(t)
            } catch (Lf) {
              if (!r(i, Lf)) return void t(Lf)
            }
          })()
        }))
      } catch (i) {
        if (this._debug(t, "error", i), Eu(i)) return {
          data: {
            session: null,
            user: null
          },
          error: i
        };
        throw i
      } finally {
        this._debug(t, "end")
      }
      var n, r
    }
    _isValidSession(e) {
      return "object" === typeof e && null !== e && "access_token" in e && "refresh_token" in e && "expires_at" in e
    }
    async _handleProviderSignIn(e, t) {
      const n = await this._getUrlForProvider("".concat(this.url, "/authorize"), e, {
        redirectTo: t.redirectTo,
        scopes: t.scopes,
        queryParams: t.queryParams
      });
      return this._debug("#_handleProviderSignIn()", "provider", e, "options", t, "url", n), Yu() && !t.skipBrowserRedirect && window.location.assign(n), {
        data: {
          provider: e,
          url: n
        },
        error: null
      }
    }
    async _recoverAndRefresh() {
      var e, t;
      const n = "#_recoverAndRefresh()";
      this._debug(n, "begin");
      try {
        const i = await Zu(this.storage, this.storageKey);
        if (i && this.userStorage) {
          let t = await Zu(this.userStorage, this.storageKey + "-user");
          this.storage.isServer || !Object.is(this.storage, this.userStorage) || t || (t = {
            user: i.user
          }, await Xu(this.userStorage, this.storageKey + "-user", t)), i.user = null !== (e = null === t || void 0 === t ? void 0 : t.user) && void 0 !== e ? e : ch()
        } else if (i && !i.user && !i.user) {
          const e = await Zu(this.storage, this.storageKey + "-user");
          e && (null === e || void 0 === e ? void 0 : e.user) ? (i.user = e.user, await eh(this.storage, this.storageKey + "-user"), await Xu(this.storage, this.storageKey, i)) : i.user = ch()
        }
        if (this._debug(n, "session from storage", i), !this._isValidSession(i)) return this._debug(n, "session is not valid"), void(null !== i && await this._removeSession());
        const s = 1e3 * (null !== (t = i.expires_at) && void 0 !== t ? t : 1 / 0) - Date.now() < bu;
        if (this._debug(n, "session has".concat(s ? "" : " not", " expired with margin of ").concat(bu, "s")), s) {
          if (this.autoRefreshToken && i.refresh_token) {
            const {
              error: e
            } = await this._callRefreshToken(i.refresh_token);
            e && (console.error(e), Nu(e) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", e), await this._removeSession()))
          }
        } else if (i.user && !0 === i.user.__isUserNotAvailableProxy) try {
          const {
            data: e,
            error: t
          } = await this._getUser(i.access_token);
          !t && (null === e || void 0 === e ? void 0 : e.user) ? (i.user = e.user, await this._saveSession(i), await this._notifyAllSubscribers("SIGNED_IN", i)) : this._debug(n, "could not get user data, skipping SIGNED_IN notification")
        } catch (r) {
          console.error("Error getting user data:", r), this._debug(n, "error getting user data, skipping SIGNED_IN notification", r)
        } else await this._notifyAllSubscribers("SIGNED_IN", i)
      } catch (i) {
        return this._debug(n, "error", i), void console.error(i)
      } finally {
        this._debug(n, "end")
      }
    }
    async _callRefreshToken(e) {
      var t, n;
      if (!e) throw new Pu;
      if (this.refreshingDeferred) return this.refreshingDeferred.promise;
      const r = "#_callRefreshToken(".concat(e.substring(0, 5), "...)");
      this._debug(r, "begin");
      try {
        this.refreshingDeferred = new th;
        const {
          data: t,
          error: n
        } = await this._refreshAccessToken(e);
        if (n) throw n;
        if (!t.session) throw new Pu;
        await this._saveSession(t.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", t.session);
        const r = {
          data: t.session,
          error: null
        };
        return this.refreshingDeferred.resolve(r), r
      } catch (i) {
        if (this._debug(r, "error", i), Eu(i)) {
          const e = {
            data: null,
            error: i
          };
          return Nu(i) || await this._removeSession(), null === (t = this.refreshingDeferred) || void 0 === t || t.resolve(e), e
        }
        throw null === (n = this.refreshingDeferred) || void 0 === n || n.reject(i), i
      } finally {
        this.refreshingDeferred = null, this._debug(r, "end")
      }
    }
    async _notifyAllSubscribers(e, t) {
      let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      const r = "#_notifyAllSubscribers(".concat(e, ")");
      this._debug(r, "begin", t, "broadcast = ".concat(n));
      try {
        this.broadcastChannel && n && this.broadcastChannel.postMessage({
          event: e,
          session: t
        });
        const r = [],
          i = Array.from(this.stateChangeEmitters.values()).map(async n => {
            try {
              await n.callback(e, t)
            } catch (Lf) {
              r.push(Lf)
            }
          });
        if (await Promise.all(i), r.length > 0) {
          for (let e = 0; e < r.length; e += 1) console.error(r[e]);
          throw r[0]
        }
      } finally {
        this._debug(r, "end")
      }
    }
    async _saveSession(e) {
      this._debug("#_saveSession()", e), this.suppressGetSessionWarning = !0;
      const t = Object.assign({}, e),
        n = t.user && !0 === t.user.__isUserNotAvailableProxy;
      if (this.userStorage) {
        !n && t.user && await Xu(this.userStorage, this.storageKey + "-user", {
          user: t.user
        });
        const e = Object.assign({}, t);
        delete e.user;
        const r = uh(e);
        await Xu(this.storage, this.storageKey, r)
      } else {
        const e = uh(t);
        await Xu(this.storage, this.storageKey, e)
      }
    }
    async _removeSession() {
      this._debug("#_removeSession()"), await eh(this.storage, this.storageKey), await eh(this.storage, this.storageKey + "-code-verifier"), await eh(this.storage, this.storageKey + "-user"), this.userStorage && await eh(this.userStorage, this.storageKey + "-user"), await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const e = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
        e && Yu() && (null === window || void 0 === window ? void 0 : window.removeEventListener) && window.removeEventListener("visibilitychange", e)
      } catch (Lf) {
        console.error("removing visibilitychange callback failed", Lf)
      }
    }
    async _startAutoRefresh() {
      await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
      const e = setInterval(() => this._autoRefreshTokenTick(), vu);
      this.autoRefreshTicker = e, e && "object" === typeof e && "function" === typeof e.unref ? e.unref() : "undefined" !== typeof Deno && "function" === typeof Deno.unrefTimer && Deno.unrefTimer(e), setTimeout(async () => {
        await this.initializePromise, await this._autoRefreshTokenTick()
      }, 0)
    }
    async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      const e = this.autoRefreshTicker;
      this.autoRefreshTicker = null, e && clearInterval(e)
    }
    async startAutoRefresh() {
      this._removeVisibilityChangedCallback(), await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
      this._removeVisibilityChangedCallback(), await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        await this._acquireLock(0, async () => {
          try {
            const e = Date.now();
            try {
              return await this._useSession(async t => {
                const {
                  data: {
                    session: n
                  }
                } = t;
                if (!n || !n.refresh_token || !n.expires_at) return void this._debug("#_autoRefreshTokenTick()", "no session");
                const r = Math.floor((1e3 * n.expires_at - e) / vu);
                this._debug("#_autoRefreshTokenTick()", "access token expires in ".concat(r, " ticks, a tick lasts ").concat(vu, "ms, refresh threshold is ").concat(3, " ticks")), r <= 3 && await this._callRefreshToken(n.refresh_token)
              })
            } catch (Lf) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", Lf)
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end")
          }
        })
      } catch (Lf) {
        if (!(Lf.isAcquireTimeout || Lf instanceof Ch)) throw Lf;
        this._debug("auto refresh token tick lock not available")
      }
    }
    async _handleVisibilityChange() {
      if (this._debug("#_handleVisibilityChange()"), !Yu() || !(null === window || void 0 === window ? void 0 : window.addEventListener)) return this.autoRefreshToken && this.startAutoRefresh(), !1;
      try {
        this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), null === window || void 0 === window || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0)
      } catch (e) {
        console.error("_handleVisibilityChange", e)
      }
    }
    async _onVisibilityChanged(e) {
      const t = "#_onVisibilityChanged(".concat(e, ")");
      this._debug(t, "visibilityState", document.visibilityState), "visible" === document.visibilityState ? (this.autoRefreshToken && this._startAutoRefresh(), e || (await this.initializePromise, await this._acquireLock(-1, async () => {
        "visible" === document.visibilityState ? await this._recoverAndRefresh() : this._debug(t, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting")
      }))) : "hidden" === document.visibilityState && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, t, n) {
      const r = ["provider=".concat(encodeURIComponent(t))];
      if ((null === n || void 0 === n ? void 0 : n.redirectTo) && r.push("redirect_to=".concat(encodeURIComponent(n.redirectTo))), (null === n || void 0 === n ? void 0 : n.scopes) && r.push("scopes=".concat(encodeURIComponent(n.scopes))), "pkce" === this.flowType) {
        const [e, t] = await sh(this.storage, this.storageKey), n = new URLSearchParams({
          code_challenge: "".concat(encodeURIComponent(e)),
          code_challenge_method: "".concat(encodeURIComponent(t))
        });
        r.push(n.toString())
      }
      if (null === n || void 0 === n ? void 0 : n.queryParams) {
        const e = new URLSearchParams(n.queryParams);
        r.push(e.toString())
      }
      return (null === n || void 0 === n ? void 0 : n.skipBrowserRedirect) && r.push("skip_http_redirect=".concat(n.skipBrowserRedirect)), "".concat(e, "?").concat(r.join("&"))
    }
    async _unenroll(e) {
      try {
        return await this._useSession(async t => {
          var n;
          const {
            data: r,
            error: i
          } = t;
          return i ? {
            data: null,
            error: i
          } : await gh(this.fetch, "DELETE", "".concat(this.url, "/factors/").concat(e.factorId), {
            headers: this.headers,
            jwt: null === (n = null === r || void 0 === r ? void 0 : r.session) || void 0 === n ? void 0 : n.access_token
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _enroll(e) {
      try {
        return await this._useSession(async t => {
          var n, r;
          const {
            data: i,
            error: s
          } = t;
          if (s) return {
            data: null,
            error: s
          };
          const o = Object.assign({
              friendly_name: e.friendlyName,
              factor_type: e.factorType
            }, "phone" === e.factorType ? {
              phone: e.phone
            } : "totp" === e.factorType ? {
              issuer: e.issuer
            } : {}),
            {
              data: a,
              error: l
            } = await gh(this.fetch, "POST", "".concat(this.url, "/factors"), {
              body: o,
              headers: this.headers,
              jwt: null === (n = null === i || void 0 === i ? void 0 : i.session) || void 0 === n ? void 0 : n.access_token
            });
          return l ? {
            data: null,
            error: l
          } : ("totp" === e.factorType && "totp" === a.type && (null === (r = null === a || void 0 === a ? void 0 : a.totp) || void 0 === r ? void 0 : r.qr_code) && (a.totp.qr_code = "data:image/svg+xml;utf-8,".concat(a.totp.qr_code)), {
            data: a,
            error: null
          })
        })
      } catch (t) {
        if (Eu(t)) return {
          data: null,
          error: t
        };
        throw t
      }
    }
    async _verify(e) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async t => {
            var n;
            const {
              data: r,
              error: i
            } = t;
            if (i) return {
              data: null,
              error: i
            };
            const s = Object.assign({
                challenge_id: e.challengeId
              }, "webauthn" in e ? {
                webauthn: Object.assign(Object.assign({}, e.webauthn), {
                  credential_response: "create" === e.webauthn.type ? Bh(e.webauthn.credential_response) : Uh(e.webauthn.credential_response)
                })
              } : {
                code: e.code
              }),
              {
                data: o,
                error: a
              } = await gh(this.fetch, "POST", "".concat(this.url, "/factors/").concat(e.factorId, "/verify"), {
                body: s,
                headers: this.headers,
                jwt: null === (n = null === r || void 0 === r ? void 0 : r.session) || void 0 === n ? void 0 : n.access_token
              });
            return a ? {
              data: null,
              error: a
            } : (await this._saveSession(Object.assign({
              expires_at: Math.round(Date.now() / 1e3) + o.expires_in
            }, o)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", o), {
              data: o,
              error: a
            })
          })
        } catch (t) {
          if (Eu(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
    async _challenge(e) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async t => {
            var n;
            const {
              data: r,
              error: i
            } = t;
            if (i) return {
              data: null,
              error: i
            };
            const s = await gh(this.fetch, "POST", "".concat(this.url, "/factors/").concat(e.factorId, "/challenge"), {
              body: e,
              headers: this.headers,
              jwt: null === (n = null === r || void 0 === r ? void 0 : r.session) || void 0 === n ? void 0 : n.access_token
            });
            if (s.error) return s;
            const {
              data: o
            } = s;
            if ("webauthn" !== o.type) return {
              data: o,
              error: null
            };
            switch (o.webauthn.type) {
              case "create":
                return {
                  data: Object.assign(Object.assign({}, o), {
                    webauthn: Object.assign(Object.assign({}, o.webauthn), {
                      credential_options: Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: zh(o.webauthn.credential_options.publicKey)
                      })
                    })
                  }), error: null
                };
              case "request":
                return {
                  data: Object.assign(Object.assign({}, o), {
                    webauthn: Object.assign(Object.assign({}, o.webauthn), {
                      credential_options: Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: Fh(o.webauthn.credential_options.publicKey)
                      })
                    })
                  }), error: null
                }
            }
          })
        } catch (t) {
          if (Eu(t)) return {
            data: null,
            error: t
          };
          throw t
        }
      })
    }
    async _challengeAndVerify(e) {
      const {
        data: t,
        error: n
      } = await this._challenge({
        factorId: e.factorId
      });
      return n ? {
        data: null,
        error: n
      } : await this._verify({
        factorId: e.factorId,
        challengeId: t.id,
        code: e.code
      })
    }
    async _listFactors() {
      var e;
      const {
        data: {
          user: t
        },
        error: n
      } = await this.getUser();
      if (n) return {
        data: null,
        error: n
      };
      const r = {
        all: [],
        phone: [],
        totp: [],
        webauthn: []
      };
      for (const i of null !== (e = null === t || void 0 === t ? void 0 : t.factors) && void 0 !== e ? e : []) r.all.push(i), "verified" === i.status && r[i.factor_type].push(i);
      return {
        data: r,
        error: null
      }
    }
    async _getAuthenticatorAssuranceLevel() {
      return this._acquireLock(-1, async () => await this._useSession(async e => {
        var t, n;
        const {
          data: {
            session: r
          },
          error: i
        } = e;
        if (i) return {
          data: null,
          error: i
        };
        if (!r) return {
          data: {
            currentLevel: null,
            nextLevel: null,
            currentAuthenticationMethods: []
          },
          error: null
        };
        const {
          payload: s
        } = nh(r.access_token);
        let o = null;
        s.aal && (o = s.aal);
        let a = o;
        (null !== (n = null === (t = r.user.factors) || void 0 === t ? void 0 : t.filter(e => "verified" === e.status)) && void 0 !== n ? n : []).length > 0 && (a = "aal2");
        return {
          data: {
            currentLevel: o,
            nextLevel: a,
            currentAuthenticationMethods: s.amr || []
          },
          error: null
        }
      }))
    }
    async fetchJwk(e) {
      let t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        keys: []
      }).keys.find(t => t.kid === e);
      if (t) return t;
      const n = Date.now();
      if (t = this.jwks.keys.find(t => t.kid === e), t && this.jwks_cached_at + 6e5 > n) return t;
      const {
        data: r,
        error: i
      } = await gh(this.fetch, "GET", "".concat(this.url, "/.well-known/jwks.json"), {
        headers: this.headers
      });
      if (i) throw i;
      return r.keys && 0 !== r.keys.length ? (this.jwks = r, this.jwks_cached_at = n, t = r.keys.find(t => t.kid === e), t || null) : null
    }
    async getClaims(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      try {
        let n = e;
        if (!n) {
          const {
            data: e,
            error: t
          } = await this.getSession();
          if (t || !e.session) return {
            data: null,
            error: t
          };
          n = e.session.access_token
        }
        const {
          header: r,
          payload: i,
          signature: s,
          raw: {
            header: o,
            payload: a
          }
        } = nh(n);
        (null === t || void 0 === t ? void 0 : t.allowExpired) || function(e) {
          if (!e) throw new Error("Missing exp claim");
          if (e <= Math.floor(Date.now() / 1e3)) throw new Error("JWT has expired")
        }(i.exp);
        const l = r.alg && !r.alg.startsWith("HS") && r.kid && "crypto" in globalThis && "subtle" in globalThis.crypto ? await this.fetchJwk(r.kid, (null === t || void 0 === t ? void 0 : t.keys) ? {
          keys: t.keys
        } : null === t || void 0 === t ? void 0 : t.jwks) : null;
        if (!l) {
          const {
            error: e
          } = await this.getUser(n);
          if (e) throw e;
          return {
            data: {
              claims: i,
              header: r,
              signature: s
            },
            error: null
          }
        }
        const c = function(e) {
            switch (e) {
              case "RS256":
                return {
                  name: "RSASSA-PKCS1-v1_5", hash: {
                    name: "SHA-256"
                  }
                };
              case "ES256":
                return {
                  name: "ECDSA", namedCurve: "P-256", hash: {
                    name: "SHA-256"
                  }
                };
              default:
                throw new Error("Invalid alg claim")
            }
          }(r.alg),
          u = await crypto.subtle.importKey("jwk", l, c, !0, ["verify"]);
        if (!await crypto.subtle.verify(c, u, s, function(e) {
            const t = [];
            return qu(e, e => t.push(e)), new Uint8Array(t)
          }("".concat(o, ".").concat(a)))) throw new Du("Invalid JWT signature");
        return {
          data: {
            claims: i,
            header: r,
            signature: s
          },
          error: null
        }
      } catch (n) {
        if (Eu(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    }
  }
  Qh.nextInstanceID = 0;
  const Xh = Qh;
  class Zh extends Xh {
    constructor(e) {
      super(e)
    }
  }
  var ed = function(e, t, n, r) {
    return new(n || (n = Promise))(function(i, s) {
      function o(e) {
        try {
          l(r.next(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function a(e) {
        try {
          l(r.throw(e))
        } catch (Lf) {
          s(Lf)
        }
      }

      function l(e) {
        e.done ? i(e.value) : function(e) {
          return e instanceof n ? e : new n(function(t) {
            t(e)
          })
        }(e.value).then(o, a)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
  class td {
    constructor(e, t, n) {
      var r, i, s;
      this.supabaseUrl = e, this.supabaseKey = t;
      const o = function(e) {
        const t = null === e || void 0 === e ? void 0 : e.trim();
        if (!t) throw new Error("supabaseUrl is required.");
        if (!t.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
        try {
          return new URL(function(e) {
            return e.endsWith("/") ? e : e + "/"
          }(t))
        } catch (r) {
          throw Error("Invalid supabaseUrl: Provided URL is malformed.")
        }
      }(e);
      if (!t) throw new Error("supabaseKey is required.");
      this.realtimeUrl = new URL("realtime/v1", o), this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"), this.authUrl = new URL("auth/v1", o), this.storageUrl = new URL("storage/v1", o), this.functionsUrl = new URL("functions/v1", o);
      const a = "sb-".concat(o.hostname.split(".")[0], "-auth-token"),
        l = function(e, t) {
          var n, r;
          const {
            db: i,
            auth: s,
            realtime: o,
            global: a
          } = e, {
            db: l,
            auth: c,
            realtime: u,
            global: h
          } = t, d = {
            db: Object.assign(Object.assign({}, l), i),
            auth: Object.assign(Object.assign({}, c), s),
            realtime: Object.assign(Object.assign({}, u), o),
            storage: {},
            global: Object.assign(Object.assign(Object.assign({}, h), a), {
              headers: Object.assign(Object.assign({}, null !== (n = null === h || void 0 === h ? void 0 : h.headers) && void 0 !== n ? n : {}), null !== (r = null === a || void 0 === a ? void 0 : a.headers) && void 0 !== r ? r : {})
            }),
            accessToken: () => mu(this, void 0, void 0, function*() {
              return ""
            })
          };
          return e.accessToken ? d.accessToken = e.accessToken : delete d.accessToken, d
        }(null !== n && void 0 !== n ? n : {}, {
          db: cu,
          realtime: hu,
          auth: Object.assign(Object.assign({}, uu), {
            storageKey: a
          }),
          global: lu
        });
      this.storageKey = null !== (r = l.auth.storageKey) && void 0 !== r ? r : "", this.headers = null !== (i = l.global.headers) && void 0 !== i ? i : {}, l.accessToken ? (this.accessToken = l.accessToken, this.auth = new Proxy({}, {
        get: (e, t) => {
          throw new Error("@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.".concat(String(t), " is not possible"))
        }
      })) : this.auth = this._initSupabaseAuthClient(null !== (s = l.auth) && void 0 !== s ? s : {}, this.headers, l.global.fetch), this.fetch = gu(t, this._getAccessToken.bind(this), l.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({
        headers: this.headers,
        accessToken: this._getAccessToken.bind(this)
      }, l.realtime)), this.rest = new Kl(new URL("rest/v1", o).href, {
        headers: this.headers,
        schema: l.db.schema,
        fetch: this.fetch
      }), this.storage = new ou(this.storageUrl.href, this.headers, this.fetch, null === n || void 0 === n ? void 0 : n.storage), l.accessToken || this._listenForAuthEvents()
    }
    get functions() {
      return new Vl(this.functionsUrl.href, {
        headers: this.headers,
        customFetch: this.fetch
      })
    }
    from(e) {
      return this.rest.from(e)
    }
    schema(e) {
      return this.rest.schema(e)
    }
    rpc(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
          head: !1,
          get: !1,
          count: void 0
        };
      return this.rest.rpc(e, t, n)
    }
    channel(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        config: {}
      };
      return this.realtime.channel(e, t)
    }
    getChannels() {
      return this.realtime.getChannels()
    }
    removeChannel(e) {
      return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
      return this.realtime.removeAllChannels()
    }
    _getAccessToken() {
      return ed(this, void 0, void 0, function*() {
        var e, t;
        if (this.accessToken) return yield this.accessToken();
        const {
          data: n
        } = yield this.auth.getSession();
        return null !== (t = null === (e = n.session) || void 0 === e ? void 0 : e.access_token) && void 0 !== t ? t : this.supabaseKey
      })
    }
    _initSupabaseAuthClient(e, t, n) {
      let {
        autoRefreshToken: r,
        persistSession: i,
        detectSessionInUrl: s,
        storage: o,
        userStorage: a,
        storageKey: l,
        flowType: c,
        lock: u,
        debug: h
      } = e;
      const d = {
        Authorization: "Bearer ".concat(this.supabaseKey),
        apikey: "".concat(this.supabaseKey)
      };
      return new Zh({
        url: this.authUrl.href,
        headers: Object.assign(Object.assign({}, d), t),
        storageKey: l,
        autoRefreshToken: r,
        persistSession: i,
        detectSessionInUrl: s,
        storage: o,
        userStorage: a,
        flowType: c,
        lock: u,
        debug: h,
        fetch: n,
        hasCustomAuthorizationHeader: Object.keys(this.headers).some(e => "authorization" === e.toLowerCase())
      })
    }
    _initRealtimeClient(e) {
      return new Rc(this.realtimeUrl.href, Object.assign(Object.assign({}, e), {
        params: Object.assign({
          apikey: this.supabaseKey
        }, null === e || void 0 === e ? void 0 : e.params)
      }))
    }
    _listenForAuthEvents() {
      return this.auth.onAuthStateChange((e, t) => {
        this._handleTokenChanged(e, "CLIENT", null === t || void 0 === t ? void 0 : t.access_token)
      })
    }
    _handleTokenChanged(e, t, n) {
      "TOKEN_REFRESHED" !== e && "SIGNED_IN" !== e || this.changedAccessToken === n ? "SIGNED_OUT" === e && (this.realtime.setAuth(), "STORAGE" == t && this.auth.signOut(), this.changedAccessToken = void 0) : (this.changedAccessToken = n, this.realtime.setAuth(n))
    }
  }(function() {
    if ("undefined" !== typeof window) return !1;
    if ("undefined" === typeof process) return !1;
    const e = process.version;
    if (void 0 === e || null === e) return !1;
    const t = e.match(/^v(\d+)\./);
    return !!t && parseInt(t[1], 10) <= 18
  })() && console.warn("\u26a0\ufe0f  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
  const nd = new td("https://pislpfnstcguhziglbms.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBpc2xwZm5zdGNndWh6aWdsYm1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTAzMDEsImV4cCI6MjA3NjI2NjMwMX0.x7vqSGk_OOzsm2fr0MawPwwPktb6k_sj5kF_TrylfL8", rd);
  var rd, id = n(579);
  Hi.register(Ds, Us, os, is, bs, js, ys);
  const sd = () => {
      const [e, t] = (0, i.useState)([]), [n, r] = (0, i.useState)([]), [s, o] = (0, i.useState)([]), [a, l] = (0, i.useState)(!1), [c, h] = (0, i.useState)(!1), [d, f] = (0, i.useState)(""), [p, g] = (0, i.useState)(""), [m, y] = (0, i.useState)(!1), [v, b] = (0, i.useState)(null), [w, _] = (0, i.useState)(0), [x, k] = (0, i.useState)([]), [S, E] = (0, i.useState)(!1), T = e => {
        const t = Date.now();
        k(n => [...n, {
          id: t,
          message: e
        }]), setTimeout(() => {
          k(e => e.filter(e => e.id !== t))
        }, 3e3)
      };
      (0, i.useEffect)(() => {
        const e = Array.from({
          length: 8
        }, (e, t) => ({
          teamId: t + 1,
          amount: 0
        }));
        r(e)
      }, []), (0, i.useEffect)(() => {
        if (c) {
          C(), O();
          const e = nd.channel("admin_stock_prices").on("postgres_changes", {
            event: "*",
            schema: "public",
            table: "stock_prices"
          }, () => {
            console.log("\uc8fc\uac00 \ub370\uc774\ud130 \ubcc0\uacbd\ub428"), C()
          }).on("postgres_changes", {
            event: "*",
            schema: "public",
            table: "investments"
          }, () => {
            console.log("\ud22c\uc790 \ub370\uc774\ud130 \ubcc0\uacbd\ub428"), C(), O()
          }).subscribe(e => {
            l("SUBSCRIBED" === e), console.log("Supabase \uc5f0\uacb0 \uc0c1\ud0dc:", e)
          });
          return () => {
            e.unsubscribe()
          }
        }
      }, [c]);
      const C = async () => {
        try {
          const e = await fetch(`${window.location.protocol}//${window.location.hostname}:3001/api/stocks`);
          if (!e.ok) throw new Error("\uc11c\ubc84\uc5d0\uc11c \ub370\uc774\ud130\ub97c \uac00\uc838\uc62c \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.");
          const n = await e.json();
          t(n)
        } catch (p) {
          console.error("\uc8fc\uac00 \ub370\uc774\ud130 \ub85c\ub4dc \uc2e4\ud328:", p), T("\uc8fc\uac00 \ub370\uc774\ud130\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.")
        }
      }, O = async () => {
        try {
          const e = await fetch(`${window.location.protocol}//${window.location.hostname}:3001/api/history`);
          if (!e.ok) throw new Error("\uc11c\ubc84\uc5d0\uc11c \ud788\uc2a4\ud1a0\ub9ac \ub370\uc774\ud130\ub97c \uac00\uc838\uc62c \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.");
          const t = await e.json();
          o(t)
        } catch (p) {
          console.error("\ud788\uc2a4\ud1a0\ub9ac \ub370\uc774\ud130 \ub85c\ub4dc \uc2e4\ud328:", p), T("\ud22c\uc790 \ud788\uc2a4\ud1a0\ub9ac\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.")
        }
      }, P = e => {
        e.preventDefault(), "admin123" === d ? (h(!0), g("")) : g("\uc798\ubabb\ub41c \uc554\ud638\uc785\ub2c8\ub2e4.")
      }, A = (e, t) => {
        r(n => n.map(n => n.teamId === e ? u(u({}, n), {}, {
          amount: t
        }) : n))
      }, R = async (e, t) => {
        if (t <= 0) T("\ud22c\uc790 \uae08\uc561\uc744 \uc62c\ubc14\ub974\uac8c \uc785\ub825\ud574\uc8fc\uc138\uc694.");
        else {
          E(!0);
          try {
            const n = await fetch(`${window.location.protocol}//${window.location.hostname}:3001/api/invest`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                teamId: e,
                amount: t
              })
            });
            if (!n.ok) {
              const e = await n.json();
              throw new Error(e.error || "\ud22c\uc790\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4.")
            }
            const r = await n.json();
            T("".concat(e, "\uc870 \ud22c\uc790 \uc644\ub8cc! \uc0c8\ub85c\uc6b4 \uc8fc\uac00: ").concat(r.newPrice, "\uc6d0 (").concat(r.changePercent, "%)")), await C(), await O(), A(e, 0), _(0), b(null)
          } catch (p) {
            console.error("\ud22c\uc790 \uc2e4\ud328:", p);
            const t = p instanceof Error ? p.message : "\uc54c \uc218 \uc5c6\ub294 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4.";
            T("\ud22c\uc790 \uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4: ".concat(t))
          } finally {
            E(!1)
          }
        }
      }, M = () => {
        b(null), _(0)
      }, L = {
        labels: e.map(e => e.team_name),
        datasets: [{
          label: "\ud604\uc7ac \uc8fc\uac00",
          data: e.map(e => e.current_price),
          borderColor: "#007aff",
          backgroundColor: "transparent",
          tension: 0,
          pointRadius: 0,
          pointHoverRadius: 4,
          borderWidth: 2,
          fill: !1
        }]
      };
      if (!c) return (0, id.jsx)("div", {
        className: "App",
        children: (0, id.jsx)("div", {
          className: "login-container",
          children: (0, id.jsxs)("div", {
            className: "login-box",
            children: [(0, id.jsx)(Al, {
              to: "/",
              className: "login-close-button",
              children: "\xd7"
            }), (0, id.jsx)("h1", {
              children: "\uad00\ub9ac\uc790 \ub85c\uadf8\uc778"
            }), (0, id.jsxs)("form", {
              onSubmit: P,
              className: "login-form",
              children: [(0, id.jsxs)("div", {
                className: "form-group",
                children: [(0, id.jsx)("label", {
                  htmlFor: "password",
                  children: "\uc554\ud638:"
                }), (0, id.jsx)("input", {
                  id: "password",
                  type: "password",
                  value: d,
                  onChange: e => f(e.target.value),
                  placeholder: "\uad00\ub9ac\uc790 \uc554\ud638\ub97c \uc785\ub825\ud558\uc138\uc694",
                  required: !0
                })]
              }), p && (0, id.jsx)("div", {
                className: "error-message",
                children: p
              }), (0, id.jsx)("button", {
                type: "submit",
                className: "login-button",
                children: "\ub85c\uadf8\uc778"
              })]
            })]
          })
        })
      });
      const j = e.find(e => e.team_id === v);
      return (0, id.jsxs)("div", {
        className: "App",
        children: [(0, id.jsxs)("header", {
          className: "app-header",
          children: [(0, id.jsx)("h1", {
            children: "\uad00\ub9ac\uc790 - \ud30c\ud2b8\ub108\uc988 \uc99d\uad8c \uac70\ub798\uc18c"
          }), (0, id.jsxs)("div", {
            className: "header-actions",
            children: [(0, id.jsx)("button", {
              onClick: () => {
                y(!m), m || O()
              },
              className: "history-button",
              children: m ? "\ucc28\ud2b8 \ubcf4\uae30" : "\ud788\uc2a4\ud1a0\ub9ac"
            }), (0, id.jsx)(Al, {
              to: "/",
              className: "logout-link",
              children: "\ub098\uac00\uae30"
            }), (0, id.jsx)("div", {
              className: "connection-status ".concat(a ? "connected" : "disconnected"),
              children: a ? "\uc5f0\uacb0\ub428" : "\uc5f0\uacb0 \ub04a\uae40"
            })]
          })]
        }), (0, id.jsxs)("main", {
          className: "app-main",
          children: [m ? (0, id.jsxs)("section", {
            className: "history-section",
            children: [(0, id.jsxs)("h2", {
              children: ["\ud22c\uc790 \ud788\uc2a4\ud1a0\ub9ac (\ucd1d ", s.length, "\uac1c)"]
            }), (0, id.jsx)("div", {
              className: "history-table",
              children: (0, id.jsxs)("table", {
                children: [(0, id.jsx)("thead", {
                  children: (0, id.jsxs)("tr", {
                    children: [(0, id.jsx)("th", {
                      children: "\uc2dc\uac04"
                    }), (0, id.jsx)("th", {
                      children: "\uc870"
                    }), (0, id.jsx)("th", {
                      children: "\ud22c\uc790 \uae08\uc561"
                    }), (0, id.jsx)("th", {
                      children: "\ud22c\uc790 \uc2dc \uc8fc\uac00"
                    })]
                  })
                }), (0, id.jsxs)("tbody", {
                  children: [s.map(e => (0, id.jsxs)("tr", {
                    children: [(0, id.jsx)("td", {
                      className: "timestamp",
                      children: new Date(e.timestamp).toLocaleString("ko-KR")
                    }), (0, id.jsx)("td", {
                      className: "team-name",
                      children: e.team_name
                    }), (0, id.jsxs)("td", {
                      className: "amount",
                      children: [e.amount.toLocaleString(), "\uc6d0"]
                    }), (0, id.jsxs)("td", {
                      className: "price",
                      children: [e.price_at_investment.toFixed(2), "\uc6d0"]
                    })]
                  }, e.uniqueKey || e.id)), 0 === s.length && (0, id.jsx)("tr", {
                    children: (0, id.jsx)("td", {
                      colSpan: 4,
                      className: "no-data",
                      children: "\ud22c\uc790 \uae30\ub85d\uc774 \uc5c6\uc2b5\ub2c8\ub2e4."
                    })
                  })]
                })]
              })
            })]
          }) : (0, id.jsxs)(id.Fragment, {
            children: [(0, id.jsx)("section", {
              className: "chart-section",
              children: (0, id.jsx)("div", {
                className: "chart-container",
                children: (0, id.jsx)(Eo, {
                  data: L,
                  options: {
                    responsive: !0,
                    maintainAspectRatio: !1,
                    plugins: {
                      title: {
                        display: !0,
                        text: "\ud30c\ud2b8\ub108\uc988 \uc99d\uad8c \uac70\ub798\uc18c - \uad00\ub9ac\uc790",
                        font: {
                          size: 20,
                          weight: "bold",
                          family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                        },
                        color: "#ffffff"
                      },
                      legend: {
                        display: !1
                      }
                    },
                    scales: {
                      y: {
                        beginAtZero: !1,
                        grid: {
                          color: "rgba(255, 255, 255, 0.1)",
                          drawBorder: !1
                        },
                        ticks: {
                          color: "#8e8e93",
                          font: {
                            size: 12,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                          }
                        }
                      },
                      x: {
                        grid: {
                          display: !1
                        },
                        ticks: {
                          color: "#8e8e93",
                          font: {
                            size: 12,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                          }
                        }
                      }
                    }
                  }
                })
              })
            }), (0, id.jsxs)("section", {
              className: "investment-section",
              children: [(0, id.jsx)("h2", {
                children: "\uc870\ubcc4 \ud22c\uc790 \uc785\ub825"
              }), (0, id.jsx)("div", {
                className: "team-investment-grid",
                children: e.map((e, t) => {
                  var r, i, s;
                  return (0, id.jsxs)("div", {
                    className: "team-investment-card",
                    onClick: () => {
                      return t = e.team_id, b(t), void _(null !== n && void 0 !== n ? n : 0);
                      var t, n
                    },
                    children: [(0, id.jsx)("h3", {
                      children: e.team_name
                    }), (0, id.jsxs)("div", {
                      className: "current-info",
                      children: [(0, id.jsxs)("div", {
                        className: "price",
                        children: ["\ud604\uc7ac: ", e.current_price.toFixed(2), "\uc6d0"]
                      }), (0, id.jsxs)("div", {
                        className: "change ".concat(e.change_percent >= 0 ? "positive" : "negative"),
                        children: [e.change_percent >= 0 ? "+" : "", e.change_percent.toFixed(2), "%"]
                      })]
                    }), (0, id.jsxs)("div", {
                      className: "investment-form",
                      children: [(0, id.jsx)("input", {
                        type: "number",
                        min: "0",
                        value: (null === (r = n[t]) || void 0 === r ? void 0 : r.amount) || "",
                        onChange: t => A(e.team_id, parseInt(t.target.value) || 0),
                        onFocus: t => {
                          "0" === t.target.value && (t.target.value = "", A(e.team_id, 0))
                        },
                        onBlur: t => {
                          "" === t.target.value && (t.target.value = "0", A(e.team_id, 0))
                        },
                        onKeyPress: r => {
                          var i;
                          "Enter" === r.key && R(e.team_id, (null === (i = n[t]) || void 0 === i ? void 0 : i.amount) || 0)
                        },
                        placeholder: "\ud22c\uc790 \uae08\uc561",
                        className: "amount-input",
                        onClick: e => e.stopPropagation()
                      }), (0, id.jsx)("button", {
                        onClick: r => {
                          var i;
                          r.stopPropagation(), R(e.team_id, (null === (i = n[t]) || void 0 === i ? void 0 : i.amount) || 0)
                        },
                        className: "invest-button",
                        disabled: !(null !== (i = n[t]) && void 0 !== i && i.amount) || S || (null === (s = n[t]) || void 0 === s ? void 0 : s.amount) <= 0,
                        children: S ? "\ucc98\ub9ac \uc911..." : "\ud22c\uc790"
                      })]
                    }), (0, id.jsxs)("div", {
                      className: "total-investment",
                      children: ["\ucd1d \ud22c\uc790: ", e.total_investment.toLocaleString(), "\uc6d0"]
                    })]
                  }, e.team_id)
                })
              })]
            })]
          }), x.map(e => (0, id.jsx)("div", {
            className: "toast-notification success",
            children: e.message
          }, e.id)), null !== v && j && (0, id.jsx)("div", {
            className: "modal-overlay",
            onClick: M,
            children: (0, id.jsxs)("div", {
              className: "modal",
              onClick: e => e.stopPropagation(),
              children: [(0, id.jsxs)("div", {
                className: "modal-header",
                children: [(0, id.jsxs)("h2", {
                  children: [j.team_name, " (", j.team_id, "\uc870) \ud22c\uc790"]
                }), (0, id.jsx)("button", {
                  onClick: M,
                  className: "modal-close-button",
                  children: "\xd7"
                })]
              }), (0, id.jsxs)("div", {
                className: "modal-current-info",
                children: [(0, id.jsxs)("div", {
                  className: "info-item",
                  children: [(0, id.jsx)("span", {
                    className: "label",
                    children: "\ud604\uc7ac \uc8fc\uac00"
                  }), (0, id.jsxs)("span", {
                    className: "price",
                    children: [j.current_price.toFixed(2), "\uc6d0"]
                  })]
                }), (0, id.jsxs)("div", {
                  className: "info-item",
                  children: [(0, id.jsx)("span", {
                    className: "label",
                    children: "\ubcc0\ub3d9\ub960"
                  }), (0, id.jsxs)("span", {
                    className: "change ".concat(j.change_percent >= 0 ? "positive" : "negative"),
                    children: [j.change_percent >= 0 ? "+" : "", j.change_percent.toFixed(2), "%"]
                  })]
                }), (0, id.jsxs)("div", {
                  className: "info-item",
                  children: [(0, id.jsx)("span", {
                    className: "label",
                    children: "\ucd1d \ud22c\uc790\uc561"
                  }), (0, id.jsxs)("span", {
                    className: "investment",
                    children: [j.total_investment.toLocaleString(), "\uc6d0"]
                  })]
                })]
              }), (0, id.jsxs)("div", {
                className: "modal-form",
                children: [(0, id.jsx)("label", {
                  htmlFor: "modal-amount",
                  children: "\ud22c\uc790 \uae08\uc561"
                }), (0, id.jsx)("input", {
                  id: "modal-amount",
                  type: "number",
                  min: "0",
                  value: 0 === w ? "" : w,
                  onChange: e => _(parseInt(e.target.value) || 0),
                  onFocus: e => {
                    "0" === e.target.value && (e.target.value = "")
                  },
                  onBlur: e => {
                    "" === e.target.value && _(0)
                  },
                  placeholder: "\ud22c\uc790 \uae08\uc561\uc744 \uc785\ub825\ud558\uc138\uc694"
                })]
              }), (0, id.jsxs)("div", {
                className: "modal-actions",
                children: [(0, id.jsx)("button", {
                  onClick: M,
                  className: "modal-cancel",
                  children: "\ucde8\uc18c"
                }), (0, id.jsx)("button", {
                  onClick: async () => {
                    null !== v && (await R(v, w), M())
                  },
                  type: "submit",
                  disabled: w <= 0 || S,
                  children: S ? "\ucc98\ub9ac \uc911..." : "\ud22c\uc790\ud558\uae30"
                })]
              })]
            })
          })]
        })]
      })
    },
    od = Object.create(null);
  od.open = "0", od.close = "1", od.ping = "2", od.pong = "3", od.message = "4", od.upgrade = "5", od.noop = "6";
  const ad = Object.create(null);
  Object.keys(od).forEach(e => {
    ad[od[e]] = e
  });
  const ld = {
      type: "error",
      data: "parser error"
    },
    cd = "function" === typeof Blob || "undefined" !== typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob),
    ud = "function" === typeof ArrayBuffer,
    hd = e => "function" === typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer,
    dd = (e, t, n) => {
      let {
        type: r,
        data: i
      } = e;
      return cd && i instanceof Blob ? t ? n(i) : fd(i, n) : ud && (i instanceof ArrayBuffer || hd(i)) ? t ? n(i) : fd(new Blob([i]), n) : n(od[r] + (i || ""))
    },
    fd = (e, t) => {
      const n = new FileReader;
      return n.onload = function() {
        const e = n.result.split(",")[1];
        t("b" + (e || ""))
      }, n.readAsDataURL(e)
    };

  function pd(e) {
    return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
  }
  let gd;
  const md = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    yd = "undefined" === typeof Uint8Array ? [] : new Uint8Array(256);
  for (let Nf = 0; Nf < 64; Nf++) yd[md.charCodeAt(Nf)] = Nf;
  const vd = "function" === typeof ArrayBuffer,
    bd = (e, t) => {
      if ("string" !== typeof e) return {
        type: "message",
        data: _d(e, t)
      };
      const n = e.charAt(0);
      if ("b" === n) return {
        type: "message",
        data: wd(e.substring(1), t)
      };
      return ad[n] ? e.length > 1 ? {
        type: ad[n],
        data: e.substring(1)
      } : {
        type: ad[n]
      } : ld
    },
    wd = (e, t) => {
      if (vd) {
        const n = (e => {
          let t, n, r, i, s, o = .75 * e.length,
            a = e.length,
            l = 0;
          "=" === e[e.length - 1] && (o--, "=" === e[e.length - 2] && o--);
          const c = new ArrayBuffer(o),
            u = new Uint8Array(c);
          for (t = 0; t < a; t += 4) n = yd[e.charCodeAt(t)], r = yd[e.charCodeAt(t + 1)], i = yd[e.charCodeAt(t + 2)], s = yd[e.charCodeAt(t + 3)], u[l++] = n << 2 | r >> 4, u[l++] = (15 & r) << 4 | i >> 2, u[l++] = (3 & i) << 6 | 63 & s;
          return c
        })(e);
        return _d(n, t)
      }
      return {
        base64: !0,
        data: e
      }
    },
    _d = (e, t) => "blob" === t ? e instanceof Blob ? e : new Blob([e]) : e instanceof ArrayBuffer ? e : e.buffer,
    xd = String.fromCharCode(30);

  function kd() {
    return new TransformStream({
      transform(e, t) {
        ! function(e, t) {
          cd && e.data instanceof Blob ? e.data.arrayBuffer().then(pd).then(t) : ud && (e.data instanceof ArrayBuffer || hd(e.data)) ? t(pd(e.data)) : dd(e, !1, e => {
            gd || (gd = new TextEncoder), t(gd.encode(e))
          })
        }(e, n => {
          const r = n.length;
          let i;
          if (r < 126) i = new Uint8Array(1), new DataView(i.buffer).setUint8(0, r);
          else if (r < 65536) {
            i = new Uint8Array(3);
            const e = new DataView(i.buffer);
            e.setUint8(0, 126), e.setUint16(1, r)
          } else {
            i = new Uint8Array(9);
            const e = new DataView(i.buffer);
            e.setUint8(0, 127), e.setBigUint64(1, BigInt(r))
          }
          e.data && "string" !== typeof e.data && (i[0] |= 128), t.enqueue(i), t.enqueue(n)
        })
      }
    })
  }
  let Sd;

  function Ed(e) {
    return e.reduce((e, t) => e + t.length, 0)
  }

  function Td(e, t) {
    if (e[0].length === t) return e.shift();
    const n = new Uint8Array(t);
    let r = 0;
    for (let i = 0; i < t; i++) n[i] = e[0][r++], r === e[0].length && (e.shift(), r = 0);
    return e.length && r < e[0].length && (e[0] = e[0].slice(r)), n
  }

  function Cd(e) {
    if (e) return function(e) {
      for (var t in Cd.prototype) e[t] = Cd.prototype[t];
      return e
    }(e)
  }
  Cd.prototype.on = Cd.prototype.addEventListener = function(e, t) {
    return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
  }, Cd.prototype.once = function(e, t) {
    function n() {
      this.off(e, n), t.apply(this, arguments)
    }
    return n.fn = t, this.on(e, n), this
  }, Cd.prototype.off = Cd.prototype.removeListener = Cd.prototype.removeAllListeners = Cd.prototype.removeEventListener = function(e, t) {
    if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
    var n, r = this._callbacks["$" + e];
    if (!r) return this;
    if (1 == arguments.length) return delete this._callbacks["$" + e], this;
    for (var i = 0; i < r.length; i++)
      if ((n = r[i]) === t || n.fn === t) {
        r.splice(i, 1);
        break
      } return 0 === r.length && delete this._callbacks["$" + e], this
  }, Cd.prototype.emit = function(e) {
    this._callbacks = this._callbacks || {};
    for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    if (n) {
      r = 0;
      for (var i = (n = n.slice(0)).length; r < i; ++r) n[r].apply(this, t)
    }
    return this
  }, Cd.prototype.emitReserved = Cd.prototype.emit, Cd.prototype.listeners = function(e) {
    return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
  }, Cd.prototype.hasListeners = function(e) {
    return !!this.listeners(e).length
  };
  const Od = "function" === typeof Promise && "function" === typeof Promise.resolve ? e => Promise.resolve().then(e) : (e, t) => t(e, 0),
    Pd = "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : Function("return this")();

  function Ad(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
    return n.reduce((t, n) => (e.hasOwnProperty(n) && (t[n] = e[n]), t), {})
  }
  const Rd = Pd.setTimeout,
    Md = Pd.clearTimeout;

  function Ld(e, t) {
    t.useNativeTimers ? (e.setTimeoutFn = Rd.bind(Pd), e.clearTimeoutFn = Md.bind(Pd)) : (e.setTimeoutFn = Pd.setTimeout.bind(Pd), e.clearTimeoutFn = Pd.clearTimeout.bind(Pd))
  }

  function jd(e) {
    return "string" === typeof e ? function(e) {
      let t = 0,
        n = 0;
      for (let r = 0, i = e.length; r < i; r++) t = e.charCodeAt(r), t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (r++, n += 4);
      return n
    }(e) : Math.ceil(1.33 * (e.byteLength || e.size))
  }

  function Nd() {
    return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5)
  }
  class Id extends Error {
    constructor(e, t, n) {
      super(e), this.description = t, this.context = n, this.type = "TransportError"
    }
  }
  class Dd extends Cd {
    constructor(e) {
      super(), this.writable = !1, Ld(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64
    }
    onError(e, t, n) {
      return super.emitReserved("error", new Id(e, t, n)), this
    }
    open() {
      return this.readyState = "opening", this.doOpen(), this
    }
    close() {
      return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
    }
    send(e) {
      "open" === this.readyState && this.write(e)
    }
    onOpen() {
      this.readyState = "open", this.writable = !0, super.emitReserved("open")
    }
    onData(e) {
      const t = bd(e, this.socket.binaryType);
      this.onPacket(t)
    }
    onPacket(e) {
      super.emitReserved("packet", e)
    }
    onClose(e) {
      this.readyState = "closed", super.emitReserved("close", e)
    }
    pause(e) {}
    createUri(e) {
      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t)
    }
    _hostname() {
      const e = this.opts.hostname;
      return -1 === e.indexOf(":") ? e : "[" + e + "]"
    }
    _port() {
      return this.opts.port && (this.opts.secure && Number(443 !== this.opts.port) || !this.opts.secure && 80 !== Number(this.opts.port)) ? ":" + this.opts.port : ""
    }
    _query(e) {
      const t = function(e) {
        let t = "";
        for (let n in e) e.hasOwnProperty(n) && (t.length && (t += "&"), t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
        return t
      }(e);
      return t.length ? "?" + t : ""
    }
  }
  class zd extends Dd {
    constructor() {
      super(...arguments), this._polling = !1
    }
    get name() {
      return "polling"
    }
    doOpen() {
      this._poll()
    }
    pause(e) {
      this.readyState = "pausing";
      const t = () => {
        this.readyState = "paused", e()
      };
      if (this._polling || !this.writable) {
        let e = 0;
        this._polling && (e++, this.once("pollComplete", function() {
          --e || t()
        })), this.writable || (e++, this.once("drain", function() {
          --e || t()
        }))
      } else t()
    }
    _poll() {
      this._polling = !0, this.doPoll(), this.emitReserved("poll")
    }
    onData(e) {
      ((e, t) => {
        const n = e.split(xd),
          r = [];
        for (let i = 0; i < n.length; i++) {
          const e = bd(n[i], t);
          if (r.push(e), "error" === e.type) break
        }
        return r
      })(e, this.socket.binaryType).forEach(e => {
        if ("opening" === this.readyState && "open" === e.type && this.onOpen(), "close" === e.type) return this.onClose({
          description: "transport closed by the server"
        }), !1;
        this.onPacket(e)
      }), "closed" !== this.readyState && (this._polling = !1, this.emitReserved("pollComplete"), "open" === this.readyState && this._poll())
    }
    doClose() {
      const e = () => {
        this.write([{
          type: "close"
        }])
      };
      "open" === this.readyState ? e() : this.once("open", e)
    }
    write(e) {
      this.writable = !1, ((e, t) => {
        const n = e.length,
          r = new Array(n);
        let i = 0;
        e.forEach((e, s) => {
          dd(e, !1, e => {
            r[s] = e, ++i === n && t(r.join(xd))
          })
        })
      })(e, e => {
        this.doWrite(e, () => {
          this.writable = !0, this.emitReserved("drain")
        })
      })
    }
    uri() {
      const e = this.opts.secure ? "https" : "http",
        t = this.query || {};
      return !1 !== this.opts.timestampRequests && (t[this.opts.timestampParam] = Nd()), this.supportsBinary || t.sid || (t.b64 = 1), this.createUri(e, t)
    }
  }
  let Fd = !1;
  try {
    Fd = "undefined" !== typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
  } catch (jf) {}
  const Bd = Fd;

  function Ud() {}
  class Wd extends zd {
    constructor(e) {
      if (super(e), "undefined" !== typeof location) {
        const t = "https:" === location.protocol;
        let n = location.port;
        n || (n = t ? "443" : "80"), this.xd = "undefined" !== typeof location && e.hostname !== location.hostname || n !== e.port
      }
    }
    doWrite(e, t) {
      const n = this.request({
        method: "POST",
        data: e
      });
      n.on("success", t), n.on("error", (e, t) => {
        this.onError("xhr post error", e, t)
      })
    }
    doPoll() {
      const e = this.request();
      e.on("data", this.onData.bind(this)), e.on("error", (e, t) => {
        this.onError("xhr poll error", e, t)
      }), this.pollXhr = e
    }
  }
  class Hd extends Cd {
    constructor(e, t, n) {
      super(), this.createRequest = e, Ld(this, n), this._opts = n, this._method = n.method || "GET", this._uri = t, this._data = void 0 !== n.data ? n.data : null, this._create()
    }
    _create() {
      var e;
      const t = Ad(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      t.xdomain = !!this._opts.xd;
      const n = this._xhr = this.createRequest(t);
      try {
        n.open(this._method, this._uri, !0);
        try {
          if (this._opts.extraHeaders) {
            n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0);
            for (let e in this._opts.extraHeaders) this._opts.extraHeaders.hasOwnProperty(e) && n.setRequestHeader(e, this._opts.extraHeaders[e])
          }
        } catch (Lf) {}
        if ("POST" === this._method) try {
          n.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
        } catch (Lf) {}
        try {
          n.setRequestHeader("Accept", "*/*")
        } catch (Lf) {}
        null === (e = this._opts.cookieJar) || void 0 === e || e.addCookies(n), "withCredentials" in n && (n.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (n.timeout = this._opts.requestTimeout), n.onreadystatechange = () => {
          var e;
          3 === n.readyState && (null === (e = this._opts.cookieJar) || void 0 === e || e.parseCookies(n.getResponseHeader("set-cookie"))), 4 === n.readyState && (200 === n.status || 1223 === n.status ? this._onLoad() : this.setTimeoutFn(() => {
            this._onError("number" === typeof n.status ? n.status : 0)
          }, 0))
        }, n.send(this._data)
      } catch (Lf) {
        return void this.setTimeoutFn(() => {
          this._onError(Lf)
        }, 0)
      }
      "undefined" !== typeof document && (this._index = Hd.requestsCount++, Hd.requests[this._index] = this)
    }
    _onError(e) {
      this.emitReserved("error", e, this._xhr), this._cleanup(!0)
    }
    _cleanup(e) {
      if ("undefined" !== typeof this._xhr && null !== this._xhr) {
        if (this._xhr.onreadystatechange = Ud, e) try {
          this._xhr.abort()
        } catch (Lf) {}
        "undefined" !== typeof document && delete Hd.requests[this._index], this._xhr = null
      }
    }
    _onLoad() {
      const e = this._xhr.responseText;
      null !== e && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup())
    }
    abort() {
      this._cleanup()
    }
  }
  if (Hd.requestsCount = 0, Hd.requests = {}, "undefined" !== typeof document)
    if ("function" === typeof attachEvent) attachEvent("onunload", Vd);
    else if ("function" === typeof addEventListener) {
    addEventListener("onpagehide" in Pd ? "pagehide" : "unload", Vd, !1)
  }

  function Vd() {
    for (let e in Hd.requests) Hd.requests.hasOwnProperty(e) && Hd.requests[e].abort()
  }
  const qd = function() {
    const e = Kd({
      xdomain: !1
    });
    return e && null !== e.responseType
  }();

  function Kd(e) {
    const t = e.xdomain;
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!t || Bd)) return new XMLHttpRequest
    } catch (Lf) {}
    if (!t) try {
      return new(Pd[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
    } catch (Lf) {}
  }
  const $d = "undefined" !== typeof navigator && "string" === typeof navigator.product && "reactnative" === navigator.product.toLowerCase();
  class Yd extends Dd {
    get name() {
      return "websocket"
    }
    doOpen() {
      const e = this.uri(),
        t = this.opts.protocols,
        n = $d ? {} : Ad(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
      try {
        this.ws = this.createSocket(e, t, n)
      } catch (jf) {
        return this.emitReserved("error", jf)
      }
      this.ws.binaryType = this.socket.binaryType, this.addEventListeners()
    }
    addEventListeners() {
      this.ws.onopen = () => {
        this.opts.autoUnref && this.ws._socket.unref(), this.onOpen()
      }, this.ws.onclose = e => this.onClose({
        description: "websocket connection closed",
        context: e
      }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e)
    }
    write(e) {
      this.writable = !1;
      for (let t = 0; t < e.length; t++) {
        const n = e[t],
          r = t === e.length - 1;
        dd(n, this.supportsBinary, e => {
          try {
            this.doWrite(n, e)
          } catch (Lf) {}
          r && Od(() => {
            this.writable = !0, this.emitReserved("drain")
          }, this.setTimeoutFn)
        })
      }
    }
    doClose() {
      "undefined" !== typeof this.ws && (this.ws.onerror = () => {}, this.ws.close(), this.ws = null)
    }
    uri() {
      const e = this.opts.secure ? "wss" : "ws",
        t = this.query || {};
      return this.opts.timestampRequests && (t[this.opts.timestampParam] = Nd()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t)
    }
  }
  const Jd = Pd.WebSocket || Pd.MozWebSocket;
  const Gd = {
      websocket: class extends Yd {
        createSocket(e, t, n) {
          return $d ? new Jd(e, t, n) : t ? new Jd(e, t) : new Jd(e)
        }
        doWrite(e, t) {
          this.ws.send(t)
        }
      },
      webtransport: class extends Dd {
        get name() {
          return "webtransport"
        }
        doOpen() {
          try {
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name])
          } catch (jf) {
            return this.emitReserved("error", jf)
          }
          this._transport.closed.then(() => {
            this.onClose()
          }).catch(e => {
            this.onError("webtransport error", e)
          }), this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then(e => {
              const t = function(e, t) {
                  Sd || (Sd = new TextDecoder);
                  const n = [];
                  let r = 0,
                    i = -1,
                    s = !1;
                  return new TransformStream({
                    transform(o, a) {
                      for (n.push(o);;) {
                        if (0 === r) {
                          if (Ed(n) < 1) break;
                          const e = Td(n, 1);
                          s = 128 === (128 & e[0]), i = 127 & e[0], r = i < 126 ? 3 : 126 === i ? 1 : 2
                        } else if (1 === r) {
                          if (Ed(n) < 2) break;
                          const e = Td(n, 2);
                          i = new DataView(e.buffer, e.byteOffset, e.length).getUint16(0), r = 3
                        } else if (2 === r) {
                          if (Ed(n) < 8) break;
                          const e = Td(n, 8),
                            t = new DataView(e.buffer, e.byteOffset, e.length),
                            s = t.getUint32(0);
                          if (s > Math.pow(2, 21) - 1) {
                            a.enqueue(ld);
                            break
                          }
                          i = s * Math.pow(2, 32) + t.getUint32(4), r = 3
                        } else {
                          if (Ed(n) < i) break;
                          const e = Td(n, i);
                          a.enqueue(bd(s ? e : Sd.decode(e), t)), r = 0
                        }
                        if (0 === i || i > e) {
                          a.enqueue(ld);
                          break
                        }
                      }
                    }
                  })
                }(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
                n = e.readable.pipeThrough(t).getReader(),
                r = kd();
              r.readable.pipeTo(e.writable), this._writer = r.writable.getWriter();
              const i = () => {
                n.read().then(e => {
                  let {
                    done: t,
                    value: n
                  } = e;
                  t || (this.onPacket(n), i())
                }).catch(e => {})
              };
              i();
              const s = {
                type: "open"
              };
              this.query.sid && (s.data = '{"sid":"'.concat(this.query.sid, '"}')), this._writer.write(s).then(() => this.onOpen())
            })
          })
        }
        write(e) {
          this.writable = !1;
          for (let t = 0; t < e.length; t++) {
            const n = e[t],
              r = t === e.length - 1;
            this._writer.write(n).then(() => {
              r && Od(() => {
                this.writable = !0, this.emitReserved("drain")
              }, this.setTimeoutFn)
            })
          }
        }
        doClose() {
          var e;
          null === (e = this._transport) || void 0 === e || e.close()
        }
      },
      polling: class extends Wd {
        constructor(e) {
          super(e);
          const t = e && e.forceBase64;
          this.supportsBinary = qd && !t
        }
        request() {
          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return Object.assign(e, {
            xd: this.xd
          }, this.opts), new Hd(Kd, this.uri(), e)
        }
      }
    },
    Qd = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
    Xd = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];

  function Zd(e) {
    if (e.length > 8e3) throw "URI too long";
    const t = e,
      n = e.indexOf("["),
      r = e.indexOf("]"); - 1 != n && -1 != r && (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ";") + e.substring(r, e.length));
    let i = Qd.exec(e || ""),
      s = {},
      o = 14;
    for (; o--;) s[Xd[o]] = i[o] || "";
    return -1 != n && -1 != r && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = function(e, t) {
      const n = /\/{2,9}/g,
        r = t.replace(n, "/").split("/");
      "/" != t.slice(0, 1) && 0 !== t.length || r.splice(0, 1);
      "/" == t.slice(-1) && r.splice(r.length - 1, 1);
      return r
    }(0, s.path), s.queryKey = function(e, t) {
      const n = {};
      return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(e, t, r) {
        t && (n[t] = r)
      }), n
    }(0, s.query), s
  }
  const ef = "function" === typeof addEventListener && "function" === typeof removeEventListener,
    tf = [];
  ef && addEventListener("offline", () => {
    tf.forEach(e => e())
  }, !1);
  class nf extends Cd {
    constructor(e, t) {
      if (super(), this.binaryType = "arraybuffer", this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && "object" === typeof e && (t = e, e = null), e) {
        const n = Zd(e);
        t.hostname = n.host, t.secure = "https" === n.protocol || "wss" === n.protocol, t.port = n.port, n.query && (t.query = n.query)
      } else t.host && (t.hostname = Zd(t.host).host);
      Ld(this, t), this.secure = null != t.secure ? t.secure : "undefined" !== typeof location && "https:" === location.protocol, t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || ("undefined" !== typeof location ? location.hostname : "localhost"), this.port = t.port || ("undefined" !== typeof location && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach(e => {
        const t = e.prototype.name;
        this.transports.push(t), this._transportsByName[t] = e
      }), this.opts = Object.assign({
        path: "/engine.io",
        agent: !1,
        withCredentials: !1,
        upgrade: !0,
        timestampParam: "t",
        rememberUpgrade: !1,
        addTrailingSlash: !0,
        rejectUnauthorized: !0,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: !1
      }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), "string" === typeof this.opts.query && (this.opts.query = function(e) {
        let t = {},
          n = e.split("&");
        for (let r = 0, i = n.length; r < i; r++) {
          let e = n[r].split("=");
          t[decodeURIComponent(e[0])] = decodeURIComponent(e[1])
        }
        return t
      }(this.opts.query)), ef && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
        this.transport && (this.transport.removeAllListeners(), this.transport.close())
      }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), "localhost" !== this.hostname && (this._offlineEventListener = () => {
        this._onClose("transport close", {
          description: "network connection lost"
        })
      }, tf.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open()
    }
    createTransport(e) {
      const t = Object.assign({}, this.opts.query);
      t.EIO = 4, t.transport = e, this.id && (t.sid = this.id);
      const n = Object.assign({}, this.opts, {
        query: t,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[e]);
      return new this._transportsByName[e](n)
    }
    _open() {
      if (0 === this.transports.length) return void this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available")
      }, 0);
      const e = this.opts.rememberUpgrade && nf.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket") ? "websocket" : this.transports[0];
      this.readyState = "opening";
      const t = this.createTransport(e);
      t.open(), this.setTransport(t)
    }
    setTransport(e) {
      this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", e => this._onClose("transport close", e))
    }
    onOpen() {
      this.readyState = "open", nf.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved("open"), this.flush()
    }
    _onPacket(e) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this._onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data)
      }
    }
    onHandshake(e) {
      this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), "closed" !== this.readyState && this._resetPingTimeout()
    }
    _resetPingTimeout() {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      const e = this._pingInterval + this._pingTimeout;
      this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
        this._onClose("ping timeout")
      }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref()
    }
    _onDrain() {
      this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush()
    }
    flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        const e = this._getWritablePackets();
        this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush")
      }
    }
    _getWritablePackets() {
      if (!(this._maxPayload && "polling" === this.transport.name && this.writeBuffer.length > 1)) return this.writeBuffer;
      let e = 1;
      for (let t = 0; t < this.writeBuffer.length; t++) {
        const n = this.writeBuffer[t].data;
        if (n && (e += jd(n)), t > 0 && e > this._maxPayload) return this.writeBuffer.slice(0, t);
        e += 2
      }
      return this.writeBuffer
    }
    _hasPingExpired() {
      if (!this._pingTimeoutTime) return !0;
      const e = Date.now() > this._pingTimeoutTime;
      return e && (this._pingTimeoutTime = 0, Od(() => {
        this._onClose("ping timeout")
      }, this.setTimeoutFn)), e
    }
    write(e, t, n) {
      return this._sendPacket("message", e, t, n), this
    }
    send(e, t, n) {
      return this._sendPacket("message", e, t, n), this
    }
    _sendPacket(e, t, n, r) {
      if ("function" === typeof t && (r = t, t = void 0), "function" === typeof n && (r = n, n = null), "closing" === this.readyState || "closed" === this.readyState) return;
      (n = n || {}).compress = !1 !== n.compress;
      const i = {
        type: e,
        data: t,
        options: n
      };
      this.emitReserved("packetCreate", i), this.writeBuffer.push(i), r && this.once("flush", r), this.flush()
    }
    close() {
      const e = () => {
          this._onClose("forced close"), this.transport.close()
        },
        t = () => {
          this.off("upgrade", t), this.off("upgradeError", t), e()
        },
        n = () => {
          this.once("upgrade", t), this.once("upgradeError", t)
        };
      return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
        this.upgrading ? n() : e()
      }) : this.upgrading ? n() : e()), this
    }
    _onError(e) {
      if (nf.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && "opening" === this.readyState) return this.transports.shift(), this._open();
      this.emitReserved("error", e), this._onClose("transport error", e)
    }
    _onClose(e, t) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), ef && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
          const e = tf.indexOf(this._offlineEventListener); - 1 !== e && tf.splice(e, 1)
        }
        this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0
      }
    }
  }
  nf.protocol = 4;
  class rf extends nf {
    constructor() {
      super(...arguments), this._upgrades = []
    }
    onOpen() {
      if (super.onOpen(), "open" === this.readyState && this.opts.upgrade)
        for (let e = 0; e < this._upgrades.length; e++) this._probe(this._upgrades[e])
    }
    _probe(e) {
      let t = this.createTransport(e),
        n = !1;
      nf.priorWebsocketSuccess = !1;
      const r = () => {
        n || (t.send([{
          type: "ping",
          data: "probe"
        }]), t.once("packet", e => {
          if (!n)
            if ("pong" === e.type && "probe" === e.data) {
              if (this.upgrading = !0, this.emitReserved("upgrading", t), !t) return;
              nf.priorWebsocketSuccess = "websocket" === t.name, this.transport.pause(() => {
                n || "closed" !== this.readyState && (c(), this.setTransport(t), t.send([{
                  type: "upgrade"
                }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush())
              })
            } else {
              const e = new Error("probe error");
              e.transport = t.name, this.emitReserved("upgradeError", e)
            }
        }))
      };

      function i() {
        n || (n = !0, c(), t.close(), t = null)
      }
      const s = e => {
        const n = new Error("probe error: " + e);
        n.transport = t.name, i(), this.emitReserved("upgradeError", n)
      };

      function o() {
        s("transport closed")
      }

      function a() {
        s("socket closed")
      }

      function l(e) {
        t && e.name !== t.name && i()
      }
      const c = () => {
        t.removeListener("open", r), t.removeListener("error", s), t.removeListener("close", o), this.off("close", a), this.off("upgrading", l)
      };
      t.once("open", r), t.once("error", s), t.once("close", o), this.once("close", a), this.once("upgrading", l), -1 !== this._upgrades.indexOf("webtransport") && "webtransport" !== e ? this.setTimeoutFn(() => {
        n || t.open()
      }, 200) : t.open()
    }
    onHandshake(e) {
      this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e)
    }
    _filterUpgrades(e) {
      const t = [];
      for (let n = 0; n < e.length; n++) ~this.transports.indexOf(e[n]) && t.push(e[n]);
      return t
    }
  }
  class sf extends rf {
    constructor(e) {
      const t = "object" === typeof e ? e : arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      (!t.transports || t.transports && "string" === typeof t.transports[0]) && (t.transports = (t.transports || ["polling", "websocket", "webtransport"]).map(e => Gd[e]).filter(e => !!e)), super(e, t)
    }
  }
  const of = "function" === typeof ArrayBuffer, af = Object.prototype.toString, lf = "function" === typeof Blob || "undefined" !== typeof Blob && "[object BlobConstructor]" === af.call(Blob), cf = "function" === typeof File || "undefined" !== typeof File && "[object FileConstructor]" === af.call(File);

  function uf(e) {
    return of && (e instanceof ArrayBuffer || (e => "function" === typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer)(e)) || lf && e instanceof Blob || cf && e instanceof File
  }

  function hf(e, t) {
    if (!e || "object" !== typeof e) return !1;
    if (Array.isArray(e)) {
      for (let t = 0, n = e.length; t < n; t++)
        if (hf(e[t])) return !0;
      return !1
    }
    if (uf(e)) return !0;
    if (e.toJSON && "function" === typeof e.toJSON && 1 === arguments.length) return hf(e.toJSON(), !0);
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && hf(e[n])) return !0;
    return !1
  }

  function df(e) {
    const t = [],
      n = e.data,
      r = e;
    return r.data = ff(n, t), r.attachments = t.length, {
      packet: r,
      buffers: t
    }
  }

  function ff(e, t) {
    if (!e) return e;
    if (uf(e)) {
      const n = {
        _placeholder: !0,
        num: t.length
      };
      return t.push(e), n
    }
    if (Array.isArray(e)) {
      const n = new Array(e.length);
      for (let r = 0; r < e.length; r++) n[r] = ff(e[r], t);
      return n
    }
    if ("object" === typeof e && !(e instanceof Date)) {
      const n = {};
      for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = ff(e[r], t));
      return n
    }
    return e
  }

  function pf(e, t) {
    return e.data = gf(e.data, t), delete e.attachments, e
  }

  function gf(e, t) {
    if (!e) return e;
    if (e && !0 === e._placeholder) {
      if ("number" === typeof e.num && e.num >= 0 && e.num < t.length) return t[e.num];
      throw new Error("illegal attachments")
    }
    if (Array.isArray(e))
      for (let n = 0; n < e.length; n++) e[n] = gf(e[n], t);
    else if ("object" === typeof e)
      for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (e[n] = gf(e[n], t));
    return e
  }
  const mf = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"],
    yf = 5;
  var vf;
  ! function(e) {
    e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK"
  }(vf || (vf = {}));
  class bf {
    constructor(e) {
      this.replacer = e
    }
    encode(e) {
      return e.type !== vf.EVENT && e.type !== vf.ACK || !hf(e) ? [this.encodeAsString(e)] : this.encodeAsBinary({
        type: e.type === vf.EVENT ? vf.BINARY_EVENT : vf.BINARY_ACK,
        nsp: e.nsp,
        data: e.data,
        id: e.id
      })
    }
    encodeAsString(e) {
      let t = "" + e.type;
      return e.type !== vf.BINARY_EVENT && e.type !== vf.BINARY_ACK || (t += e.attachments + "-"), e.nsp && "/" !== e.nsp && (t += e.nsp + ","), null != e.id && (t += e.id), null != e.data && (t += JSON.stringify(e.data, this.replacer)), t
    }
    encodeAsBinary(e) {
      const t = df(e),
        n = this.encodeAsString(t.packet),
        r = t.buffers;
      return r.unshift(n), r
    }
  }

  function wf(e) {
    return "[object Object]" === Object.prototype.toString.call(e)
  }
  class _f extends Cd {
    constructor(e) {
      super(), this.reviver = e
    }
    add(e) {
      let t;
      if ("string" === typeof e) {
        if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
        t = this.decodeString(e);
        const n = t.type === vf.BINARY_EVENT;
        n || t.type === vf.BINARY_ACK ? (t.type = n ? vf.EVENT : vf.ACK, this.reconstructor = new xf(t), 0 === t.attachments && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t)
      } else {
        if (!uf(e) && !e.base64) throw new Error("Unknown type: " + e);
        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t))
      }
    }
    decodeString(e) {
      let t = 0;
      const n = {
        type: Number(e.charAt(0))
      };
      if (void 0 === vf[n.type]) throw new Error("unknown packet type " + n.type);
      if (n.type === vf.BINARY_EVENT || n.type === vf.BINARY_ACK) {
        const r = t + 1;
        for (;
          "-" !== e.charAt(++t) && t != e.length;);
        const i = e.substring(r, t);
        if (i != Number(i) || "-" !== e.charAt(t)) throw new Error("Illegal attachments");
        n.attachments = Number(i)
      }
      if ("/" === e.charAt(t + 1)) {
        const r = t + 1;
        for (; ++t;) {
          if ("," === e.charAt(t)) break;
          if (t === e.length) break
        }
        n.nsp = e.substring(r, t)
      } else n.nsp = "/";
      const r = e.charAt(t + 1);
      if ("" !== r && Number(r) == r) {
        const r = t + 1;
        for (; ++t;) {
          const n = e.charAt(t);
          if (null == n || Number(n) != n) {
            --t;
            break
          }
          if (t === e.length) break
        }
        n.id = Number(e.substring(r, t + 1))
      }
      if (e.charAt(++t)) {
        const r = this.tryParse(e.substr(t));
        if (!_f.isPayloadValid(n.type, r)) throw new Error("invalid payload");
        n.data = r
      }
      return n
    }
    tryParse(e) {
      try {
        return JSON.parse(e, this.reviver)
      } catch (Lf) {
        return !1
      }
    }
    static isPayloadValid(e, t) {
      switch (e) {
        case vf.CONNECT:
          return wf(t);
        case vf.DISCONNECT:
          return void 0 === t;
        case vf.CONNECT_ERROR:
          return "string" === typeof t || wf(t);
        case vf.EVENT:
        case vf.BINARY_EVENT:
          return Array.isArray(t) && ("number" === typeof t[0] || "string" === typeof t[0] && -1 === mf.indexOf(t[0]));
        case vf.ACK:
        case vf.BINARY_ACK:
          return Array.isArray(t)
      }
    }
    destroy() {
      this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null)
    }
  }
  class xf {
    constructor(e) {
      this.packet = e, this.buffers = [], this.reconPack = e
    }
    takeBinaryData(e) {
      if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
        const e = pf(this.reconPack, this.buffers);
        return this.finishedReconstruction(), e
      }
      return null
    }
    finishedReconstruction() {
      this.reconPack = null, this.buffers = []
    }
  }

  function kf(e, t, n) {
    return e.on(t, n),
      function() {
        e.off(t, n)
      }
  }
  const Sf = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
  });
  class Ef extends Cd {
    constructor(e, t, n) {
      super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, n && n.auth && (this.auth = n.auth), this._opts = Object.assign({}, n), this.io._autoConnect && this.open()
    }
    get disconnected() {
      return !this.connected
    }
    subEvents() {
      if (this.subs) return;
      const e = this.io;
      this.subs = [kf(e, "open", this.onopen.bind(this)), kf(e, "packet", this.onpacket.bind(this)), kf(e, "error", this.onerror.bind(this)), kf(e, "close", this.onclose.bind(this))]
    }
    get active() {
      return !!this.subs
    }
    connect() {
      return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this
    }
    open() {
      return this.connect()
    }
    send() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      return t.unshift("message"), this.emit.apply(this, t), this
    }
    emit(e) {
      var t, n, r;
      if (Sf.hasOwnProperty(e)) throw new Error('"' + e.toString() + '" is a reserved event name');
      for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) s[o - 1] = arguments[o];
      if (s.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(s), this;
      const a = {
        type: vf.EVENT,
        data: s,
        options: {}
      };
      if (a.options.compress = !1 !== this.flags.compress, "function" === typeof s[s.length - 1]) {
        const e = this.ids++,
          t = s.pop();
        this._registerAckCallback(e, t), a.id = e
      }
      const l = null === (n = null === (t = this.io.engine) || void 0 === t ? void 0 : t.transport) || void 0 === n ? void 0 : n.writable,
        c = this.connected && !(null === (r = this.io.engine) || void 0 === r ? void 0 : r._hasPingExpired());
      return this.flags.volatile && !l || (c ? (this.notifyOutgoingListeners(a), this.packet(a)) : this.sendBuffer.push(a)), this.flags = {}, this
    }
    _registerAckCallback(e, t) {
      var n, r = this;
      const i = null !== (n = this.flags.timeout) && void 0 !== n ? n : this._opts.ackTimeout;
      if (void 0 === i) return void(this.acks[e] = t);
      const s = this.io.setTimeoutFn(() => {
          delete this.acks[e];
          for (let t = 0; t < this.sendBuffer.length; t++) this.sendBuffer[t].id === e && this.sendBuffer.splice(t, 1);
          t.call(this, new Error("operation has timed out"))
        }, i),
        o = function() {
          r.io.clearTimeoutFn(s);
          for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
          t.apply(r, n)
        };
      o.withError = !0, this.acks[e] = o
    }
    emitWithAck(e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
      return new Promise((t, r) => {
        const i = (e, n) => e ? r(e) : t(n);
        i.withError = !0, n.push(i), this.emit(e, ...n)
      })
    }
    _addToQueue(e) {
      var t = this;
      let n;
      "function" === typeof e[e.length - 1] && (n = e.pop());
      const r = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: !1,
        args: e,
        flags: Object.assign({
          fromQueue: !0
        }, this.flags)
      };
      e.push(function(e) {
        if (r !== t._queue[0]) return;
        if (null !== e) r.tryCount > t._opts.retries && (t._queue.shift(), n && n(e));
        else if (t._queue.shift(), n) {
          for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) s[o - 1] = arguments[o];
          n(null, ...s)
        }
        return r.pending = !1, t._drainQueue()
      }), this._queue.push(r), this._drainQueue()
    }
    _drainQueue() {
      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (!this.connected || 0 === this._queue.length) return;
      const t = this._queue[0];
      t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args))
    }
    packet(e) {
      e.nsp = this.nsp, this.io._packet(e)
    }
    onopen() {
      "function" == typeof this.auth ? this.auth(e => {
        this._sendConnectPacket(e)
      }) : this._sendConnectPacket(this.auth)
    }
    _sendConnectPacket(e) {
      this.packet({
        type: vf.CONNECT,
        data: this._pid ? Object.assign({
          pid: this._pid,
          offset: this._lastOffset
        }, e) : e
      })
    }
    onerror(e) {
      this.connected || this.emitReserved("connect_error", e)
    }
    onclose(e, t) {
      this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks()
    }
    _clearAcks() {
      Object.keys(this.acks).forEach(e => {
        if (!this.sendBuffer.some(t => String(t.id) === e)) {
          const t = this.acks[e];
          delete this.acks[e], t.withError && t.call(this, new Error("socket has been disconnected"))
        }
      })
    }
    onpacket(e) {
      if (e.nsp === this.nsp) switch (e.type) {
        case vf.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case vf.EVENT:
        case vf.BINARY_EVENT:
          this.onevent(e);
          break;
        case vf.ACK:
        case vf.BINARY_ACK:
          this.onack(e);
          break;
        case vf.DISCONNECT:
          this.ondisconnect();
          break;
        case vf.CONNECT_ERROR:
          this.destroy();
          const t = new Error(e.data.message);
          t.data = e.data.data, this.emitReserved("connect_error", t)
      }
    }
    onevent(e) {
      const t = e.data || [];
      null != e.id && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t))
    }
    emitEvent(e) {
      if (this._anyListeners && this._anyListeners.length) {
        const t = this._anyListeners.slice();
        for (const n of t) n.apply(this, e)
      }
      super.emit.apply(this, e), this._pid && e.length && "string" === typeof e[e.length - 1] && (this._lastOffset = e[e.length - 1])
    }
    ack(e) {
      const t = this;
      let n = !1;
      return function() {
        if (!n) {
          n = !0;
          for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
          t.packet({
            type: vf.ACK,
            id: e,
            data: i
          })
        }
      }
    }
    onack(e) {
      const t = this.acks[e.id];
      "function" === typeof t && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data))
    }
    onconnect(e, t) {
      this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0)
    }
    emitBuffered() {
      this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => {
        this.notifyOutgoingListeners(e), this.packet(e)
      }), this.sendBuffer = []
    }
    ondisconnect() {
      this.destroy(), this.onclose("io server disconnect")
    }
    destroy() {
      this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this)
    }
    disconnect() {
      return this.connected && this.packet({
        type: vf.DISCONNECT
      }), this.destroy(), this.connected && this.onclose("io client disconnect"), this
    }
    close() {
      return this.disconnect()
    }
    compress(e) {
      return this.flags.compress = e, this
    }
    get volatile() {
      return this.flags.volatile = !0, this
    }
    timeout(e) {
      return this.flags.timeout = e, this
    }
    onAny(e) {
      return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this
    }
    prependAny(e) {
      return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this
    }
    offAny(e) {
      if (!this._anyListeners) return this;
      if (e) {
        const t = this._anyListeners;
        for (let n = 0; n < t.length; n++)
          if (e === t[n]) return t.splice(n, 1), this
      } else this._anyListeners = [];
      return this
    }
    listenersAny() {
      return this._anyListeners || []
    }
    onAnyOutgoing(e) {
      return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this
    }
    prependAnyOutgoing(e) {
      return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this
    }
    offAnyOutgoing(e) {
      if (!this._anyOutgoingListeners) return this;
      if (e) {
        const t = this._anyOutgoingListeners;
        for (let n = 0; n < t.length; n++)
          if (e === t[n]) return t.splice(n, 1), this
      } else this._anyOutgoingListeners = [];
      return this
    }
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || []
    }
    notifyOutgoingListeners(e) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const t = this._anyOutgoingListeners.slice();
        for (const n of t) n.apply(this, e.data)
      }
    }
  }

  function Tf(e) {
    e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0
  }
  Tf.prototype.duration = function() {
    var e = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var t = Math.random(),
        n = Math.floor(t * this.jitter * e);
      e = 0 == (1 & Math.floor(10 * t)) ? e - n : e + n
    }
    return 0 | Math.min(e, this.max)
  }, Tf.prototype.reset = function() {
    this.attempts = 0
  }, Tf.prototype.setMin = function(e) {
    this.ms = e
  }, Tf.prototype.setMax = function(e) {
    this.max = e
  }, Tf.prototype.setJitter = function(e) {
    this.jitter = e
  };
  class Cf extends Cd {
    constructor(e, t) {
      var n;
      super(), this.nsps = {}, this.subs = [], e && "object" === typeof e && (t = e, e = void 0), (t = t || {}).path = t.path || "/socket.io", this.opts = t, Ld(this, t), this.reconnection(!1 !== t.reconnection), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (n = t.randomizationFactor) && void 0 !== n ? n : .5), this.backoff = new Tf({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      }), this.timeout(null == t.timeout ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
      const i = t.parser || r;
      this.encoder = new i.Encoder, this.decoder = new i.Decoder, this._autoConnect = !1 !== t.autoConnect, this._autoConnect && this.open()
    }
    reconnection(e) {
      return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection
    }
    reconnectionAttempts(e) {
      return void 0 === e ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this)
    }
    reconnectionDelay(e) {
      var t;
      return void 0 === e ? this._reconnectionDelay : (this._reconnectionDelay = e, null === (t = this.backoff) || void 0 === t || t.setMin(e), this)
    }
    randomizationFactor(e) {
      var t;
      return void 0 === e ? this._randomizationFactor : (this._randomizationFactor = e, null === (t = this.backoff) || void 0 === t || t.setJitter(e), this)
    }
    reconnectionDelayMax(e) {
      var t;
      return void 0 === e ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, null === (t = this.backoff) || void 0 === t || t.setMax(e), this)
    }
    timeout(e) {
      return arguments.length ? (this._timeout = e, this) : this._timeout
    }
    maybeReconnectOnOpen() {
      !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
    }
    open(e) {
      if (~this._readyState.indexOf("open")) return this;
      this.engine = new sf(this.uri, this.opts);
      const t = this.engine,
        n = this;
      this._readyState = "opening", this.skipReconnect = !1;
      const r = kf(t, "open", function() {
          n.onopen(), e && e()
        }),
        i = t => {
          this.cleanup(), this._readyState = "closed", this.emitReserved("error", t), e ? e(t) : this.maybeReconnectOnOpen()
        },
        s = kf(t, "error", i);
      if (!1 !== this._timeout) {
        const e = this._timeout,
          n = this.setTimeoutFn(() => {
            r(), i(new Error("timeout")), t.close()
          }, e);
        this.opts.autoUnref && n.unref(), this.subs.push(() => {
          this.clearTimeoutFn(n)
        })
      }
      return this.subs.push(r), this.subs.push(s), this
    }
    connect(e) {
      return this.open(e)
    }
    onopen() {
      this.cleanup(), this._readyState = "open", this.emitReserved("open");
      const e = this.engine;
      this.subs.push(kf(e, "ping", this.onping.bind(this)), kf(e, "data", this.ondata.bind(this)), kf(e, "error", this.onerror.bind(this)), kf(e, "close", this.onclose.bind(this)), kf(this.decoder, "decoded", this.ondecoded.bind(this)))
    }
    onping() {
      this.emitReserved("ping")
    }
    ondata(e) {
      try {
        this.decoder.add(e)
      } catch (Lf) {
        this.onclose("parse error", Lf)
      }
    }
    ondecoded(e) {
      Od(() => {
        this.emitReserved("packet", e)
      }, this.setTimeoutFn)
    }
    onerror(e) {
      this.emitReserved("error", e)
    }
    socket(e, t) {
      let n = this.nsps[e];
      return n ? this._autoConnect && !n.active && n.connect() : (n = new Ef(this, e, t), this.nsps[e] = n), n
    }
    _destroy(e) {
      const t = Object.keys(this.nsps);
      for (const n of t) {
        if (this.nsps[n].active) return
      }
      this._close()
    }
    _packet(e) {
      const t = this.encoder.encode(e);
      for (let n = 0; n < t.length; n++) this.engine.write(t[n], e.options)
    }
    cleanup() {
      this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy()
    }
    _close() {
      this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close")
    }
    disconnect() {
      return this._close()
    }
    onclose(e, t) {
      var n;
      this.cleanup(), null === (n = this.engine) || void 0 === n || n.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect()
    }
    reconnect() {
      if (this._reconnecting || this.skipReconnect) return this;
      const e = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
      else {
        const t = this.backoff.duration();
        this._reconnecting = !0;
        const n = this.setTimeoutFn(() => {
          e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), e.skipReconnect || e.open(t => {
            t ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", t)) : e.onreconnect()
          }))
        }, t);
        this.opts.autoUnref && n.unref(), this.subs.push(() => {
          this.clearTimeoutFn(n)
        })
      }
    }
    onreconnect() {
      const e = this.backoff.attempts;
      this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e)
    }
  }
  const Of = {};

  function Pf(e, t) {
    "object" === typeof e && (t = e, e = void 0);
    const n = function(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
          n = arguments.length > 2 ? arguments[2] : void 0,
          r = e;
        n = n || "undefined" !== typeof location && location, null == e && (e = n.protocol + "//" + n.host), "string" === typeof e && ("/" === e.charAt(0) && (e = "/" === e.charAt(1) ? n.protocol + e : n.host + e), /^(https?|wss?):\/\//.test(e) || (e = "undefined" !== typeof n ? n.protocol + "//" + e : "https://" + e), r = Zd(e)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
        const i = -1 !== r.host.indexOf(":") ? "[" + r.host + "]" : r.host;
        return r.id = r.protocol + "://" + i + ":" + r.port + t, r.href = r.protocol + "://" + i + (n && n.port === r.port ? "" : ":" + r.port), r
      }(e, (t = t || {}).path || "/socket.io"),
      r = n.source,
      i = n.id,
      s = n.path,
      o = Of[i] && s in Of[i].nsps;
    let a;
    return t.forceNew || t["force new connection"] || !1 === t.multiplex || o ? a = new Cf(r, t) : (Of[i] || (Of[i] = new Cf(r, t)), a = Of[i]), n.query && !t.query && (t.query = n.queryKey), a.socket(n.path, t)
  }
  Object.assign(Pf, {
    Manager: Cf,
    Socket: Ef,
    io: Pf,
    connect: Pf
  }), Hi.register(Ds, Us, os, is, bs, js, ys);
  const Af = () => {
      const [e, t] = (0, i.useState)([]), [n, r] = (0, i.useState)(!1), [s, o] = (0, i.useState)(!1), [a, l] = (0, i.useState)(!1), [c, h] = (0, i.useState)(null), [d, f] = (0, i.useState)("teams"), [p, g] = (0, i.useState)([]), [m, y] = (0, i.useState)({}), [v, b] = (0, i.useState)(!1), [w, _] = (0, i.useState)(null);
      (0, i.useEffect)(() => {
        S();
        const e = Pf(`${window.location.protocol}//${window.location.hostname}:3001`);
        h(e), e.on("connect", () => {
          r(!0)
        }), e.on("disconnect", () => {
          r(!1)
        }), e.on("stocksUpdate", e => {
          t(e);
          const n = new Date,
            r = "".concat(n.getHours().toString().padStart(2, "0"), ":").concat(n.getMinutes().toString().padStart(2, "0"), ":").concat(n.getSeconds().toString().padStart(2, "0"));
          g(e => {
            const t = [...e, r];
            return t.length > 20 ? t.slice(-20) : t
          }), y(t => {
            const n = u({}, t);
            return e.forEach(e => {
              n[e.team_id] || (n[e.team_id] = []), n[e.team_id] = [...n[e.team_id], e.current_price].slice(-20)
            }), n
          })
        }), e.on("stockUpdate", e => {
          t(t => t.map(t => t.team_id === e.team_id ? e : t));
          const n = new Date,
            r = "".concat(n.getHours().toString().padStart(2, "0"), ":").concat(n.getMinutes().toString().padStart(2, "0"), ":").concat(n.getSeconds().toString().padStart(2, "0"));
          g(e => {
            const t = [...e, r];
            return t.length > 20 ? t.slice(-20) : t
          }), y(t => {
            const n = u({}, t);
            n[e.team_id] || (n[e.team_id] = []), n[e.team_id] = [...n[e.team_id], e.current_price].slice(-20);
            return n
          })
        });
        const n = nd.channel("stock_prices").on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "stock_prices"
        }, () => {
          console.log("\uc8fc\uac00 \ub370\uc774\ud130 \ubcc0\uacbd\ub428 (Supabase)"), S()
        }).on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "investments"
        }, () => {
          console.log("\ud22c\uc790 \ub370\uc774\ud130 \ubcc0\uacbd\ub428 (Supabase)"), S()
        }).subscribe(e => {
          console.log("Supabase \uc5f0\uacb0 \uc0c1\ud0dc:", e)
        });
        return () => {
          e.disconnect(), n.unsubscribe(), w && clearInterval(w)
        }
      }, []), (0, i.useEffect)(() => {
        const e = e => {
          "Escape" === e.key && s && o(!1)
        };
        if (s) return document.addEventListener("keydown", e), () => document.removeEventListener("keydown", e)
      }, [s]), (0, i.useEffect)(() => {
        const e = () => {
          const e = window.scrollY > 10;
          e !== a && l(e)
        };
        return window.addEventListener("scroll", e, {
          passive: !0
        }), e(), () => window.removeEventListener("scroll", e)
      }, [a]);
      const [x, k] = (0, i.useState)(10);
      (0, i.useEffect)(() => {
        if (v && x > 0) {
          const e = setTimeout(() => {
            k(e => e - 1)
          }, 1e3);
          return () => clearTimeout(e)
        }
      }, [v, x]);
      const S = async () => {
        try {
          const e = await fetch(`${window.location.protocol}//${window.location.hostname}:3001/api/stocks`);
          if (!e.ok) throw new Error("\uc11c\ubc84\uc5d0\uc11c \ub370\uc774\ud130\ub97c \uac00\uc838\uc62c \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.");
          const n = await e.json();
          t(n);
          const r = new Date,
            i = "".concat(r.getHours().toString().padStart(2, "0"), ":").concat(r.getMinutes().toString().padStart(2, "0"), ":").concat(r.getSeconds().toString().padStart(2, "0"));
          g([i]);
          const s = {};
          n.forEach(e => {
            s[e.team_id] = [e.current_price]
          }), y(s)
        } catch (e) {
          console.error("\uc8fc\uac00 \ub370\uc774\ud130 \ub85c\ub4dc \uc2e4\ud328:", e)
        }
      }, E = "teams" === d ? {
        labels: e.map(e => e.team_name),
        datasets: [{
          label: "\ud604\uc7ac \uc8fc\uac00",
          data: e.map(e => e.current_price),
          borderColor: "#007aff",
          backgroundColor: "transparent",
          tension: 0,
          pointRadius: 0,
          pointHoverRadius: 4,
          borderWidth: 2,
          fill: !1,
          segment: {
            borderColor: t => {
              const n = t.p0.parsed.x;
              if (0 === n) return e[n].change_percent >= 0 ? "#30d158" : "#ff453a";
              const r = e[n - 1],
                i = e[n];
              return r && i ? i.current_price >= r.current_price ? "#30d158" : "#ff453a" : "#007aff"
            },
            backgroundColor: t => {
              const n = t.p0.parsed.x;
              if (0 === n) return e[n].change_percent >= 0 ? "rgba(48, 209, 88, 0.1)" : "rgba(255, 69, 58, 0.1)";
              const r = e[n - 1],
                i = e[n];
              return r && i ? i.current_price >= r.current_price ? "rgba(48, 209, 88, 0.1)" : "rgba(255, 69, 58, 0.1)" : "transparent"
            }
          }
        }]
      } : {
        labels: p.length > 0 ? p : ["\ud604\uc7ac"],
        datasets: e.map((e, t) => {
          const n = m[e.team_id] || [],
            r = Math.max(n.length, p.length),
            i = [];
          for (let s = 0; s < r; s++) s < n.length ? i.push(n[s]) : i.push(e.current_price);
          return {
            label: "".concat(e.team_name, " (").concat(e.team_id, "\uc870)"),
            data: i,
            borderColor: ["#ff4444", "#ff8800", "#ffdd00", "#88ff00", "#00ff88", "#0088ff", "#8800ff", "#ff0088"][t % 8],
            backgroundColor: "transparent",
            tension: .1,
            pointRadius: 2,
            pointHoverRadius: 6,
            borderWidth: 2,
            fill: !1
          }
        })
      }, T = {
        responsive: !0,
        maintainAspectRatio: !1,
        plugins: {
          title: {
            display: !1
          },
          legend: {
            display: "timeline" === d,
            position: "top",
            labels: {
              color: "#ffffff",
              font: {
                size: 10
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: !1,
            title: {
              display: "timeline" === d,
              text: "\uc8fc\uac00 (\uc6d0)",
              color: "#ffffff"
            },
            grid: {
              color: "rgba(255, 255, 255, 0.1)",
              drawBorder: !1
            },
            ticks: {
              color: "#8e8e93",
              font: {
                size: 12,
                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
              }
            }
          },
          x: {
            title: {
              display: "timeline" === d,
              text: "\uc2dc\uac04",
              color: "#ffffff"
            },
            grid: {
              display: !1
            },
            ticks: {
              color: "#8e8e93",
              font: {
                size: 12,
                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
              }
            }
          }
        }
      };
      return (0, id.jsxs)("div", {
        className: "App",
        children: [(0, id.jsxs)("header", {
          className: "app-header ".concat(a ? "shrink" : ""),
          children: [(0, id.jsx)("div", {
            className: "logo-container",
            children: (0, id.jsx)("img", {
              src: "/PRX_LOGO.png?t=".concat(Date.now()),
              alt: "PRX",
              className: "logo"
            })
          }), (0, id.jsxs)("div", {
            className: "header-actions",
            children: [(0, id.jsx)("button", {
              onClick: () => f("teams" === d ? "timeline" : "teams"),
              className: "chart-toggle-button",
              disabled: v,
              children: "teams" === d ? "\uc2dc\uac04\ucd95 \ucc28\ud2b8" : "\ud300\ubcc4 \ucc28\ud2b8"
            }), (0, id.jsx)("button", {
              onClick: () => {
                if (v) w && (clearInterval(w), _(null)), b(!1), k(10);
                else {
                  k(10);
                  const e = setInterval(() => {
                    f(e => "teams" === e ? "timeline" : "teams"), k(10)
                  }, 1e4);
                  _(e), b(!0)
                }
              },
              className: "auto-switch-button ".concat(v ? "active" : ""),
              children: v ? "\uc790\ub3d9\uc804\ud658 \uc911\uc9c0" : "\uc790\ub3d9\uc804\ud658 \uc2dc\uc791"
            }), (0, id.jsx)("button", {
              onClick: () => {
                document.fullscreenElement ? (document.exitFullscreen(), o(!1)) : (document.documentElement.requestFullscreen(), o(!0))
              },
              className: "fullscreen-button",
              children: s ? "\uc804\uccb4\ud654\uba74 \uc885\ub8cc" : "\uc804\uccb4\ud654\uba74"
            }), (0, id.jsx)(Al, {
              to: "/admin",
              className: "admin-link",
              children: "\uad00\ub9ac\uc790"
            }), (0, id.jsx)("div", {
              className: "connection-status ".concat(n ? "connected" : "disconnected"),
              children: n ? "\uc5f0\uacb0\ub428" : "\uc5f0\uacb0 \ub04a\uae40"
            })]
          })]
        }), (0, id.jsxs)("main", {
          className: "app-main ".concat(s ? "fullscreen-mode" : ""),
          children: [(0, id.jsxs)("section", {
            className: "chart-section",
            children: [(0, id.jsxs)("div", {
              className: "chart-header",
              children: [(0, id.jsxs)("h2", {
                children: ["teams" === d ? "\ud300\ubcc4 \uc8fc\uac00 \ube44\uad50" : "\uc2dc\uac04\ubcc4 \uc8fc\uac00 \ubcc0\ud654", v && (0, id.jsx)("span", {
                  className: "auto-indicator",
                  children: " (\uc790\ub3d9 \uc804\ud658 \uc911)"
                })]
              }), v && (0, id.jsxs)("div", {
                className: "switch-timer",
                children: ["\ub2e4\uc74c \uc804\ud658\uae4c\uc9c0: ", (0, id.jsx)("span", {
                  children: x
                }), "\ucd08"]
              })]
            }), (0, id.jsx)("div", {
              className: "chart-container",
              children: (0, id.jsx)(Eo, {
                data: E,
                options: T
              })
            })]
          }), (0, id.jsxs)("section", {
            className: "stocks-table-section",
            children: [(0, id.jsx)("h2", {
              children: "\uc2e4\uc2dc\uac04 \uc8fc\uac00 \ud604\ud669"
            }), (0, id.jsx)("div", {
              className: "stocks-table",
              children: (0, id.jsxs)("table", {
                children: [(0, id.jsx)("thead", {
                  children: (0, id.jsxs)("tr", {
                    children: [(0, id.jsx)("th", {
                      children: "\uc885\ubaa9 \ucf54\ub4dc"
                    }), (0, id.jsx)("th", {
                      children: "\uc885\ubaa9\uba85"
                    }), (0, id.jsx)("th", {
                      children: "\ud604\uc7ac \uc8fc\uac00"
                    }), (0, id.jsx)("th", {
                      children: "\ubcc0\ub3d9\ub960"
                    }), (0, id.jsx)("th", {
                      children: "\ucd1d \ud22c\uc790\uc561"
                    })]
                  })
                }), (0, id.jsx)("tbody", {
                  children: e.map(e => {
                    return (0, id.jsxs)("tr", {
                      children: [(0, id.jsx)("td", {
                        children: e.team_name
                      }), (0, id.jsx)("td", {
                        children: (t = e.team_name, {
                          TJR: "TeamJR",
                          HZMB: "\ud5cc\ud130\uc880\ube44",
                          KHH: "TeamKHH",
                          JCPK: "\uc804\ucc28\ubc15",
                          JMAI: "jamAI",
                          "6\uc870": "6\uc870",
                          FKR: "FAKER",
                          YWSH: "YHAN_WORKSHOP"
                        } [t] || t)
                      }), (0, id.jsxs)("td", {
                        className: "price",
                        children: [e.current_price.toFixed(2), "\uc6d0"]
                      }), (0, id.jsxs)("td", {
                        className: "change ".concat(e.change_percent >= 0 ? "positive" : "negative"),
                        children: [e.change_percent >= 0 ? "+" : "", e.change_percent.toFixed(2), "%"]
                      }), (0, id.jsxs)("td", {
                        className: "investment",
                        children: [e.total_investment.toLocaleString(), "\uc6d0"]
                      })]
                    }, e.team_id);
                    var t
                  })
                })]
              })
            })]
          })]
        })]
      })
    },
    Rf = () => (0, id.jsx)(Ol, {
      children: (0, id.jsxs)(Ja, {
        children: [(0, id.jsx)($a, {
          path: "/",
          element: (0, id.jsx)(Af, {})
        }), (0, id.jsx)($a, {
          path: "/admin",
          element: (0, id.jsx)(sd, {})
        })]
      })
    }),
    Mf = e => {
      e && e instanceof Function && n.e(453).then(n.bind(n, 453)).then(t => {
        let {
          getCLS: n,
          getFID: r,
          getFCP: i,
          getLCP: s,
          getTTFB: o
        } = t;
        n(e), r(e), i(e), s(e), o(e)
      })
    };
  "serviceWorker" in navigator && window.addEventListener("load", () => {
    navigator.serviceWorker.register("/sw.js").catch(() => {})
  });
  s.createRoot(document.getElementById("root")).render((0, id.jsx)(Rf, {})), Mf()
})();
//# sourceMappingURL=main.30c01397.js.map